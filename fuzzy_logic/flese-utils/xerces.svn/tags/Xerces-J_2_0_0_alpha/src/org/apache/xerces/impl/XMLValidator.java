/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import org.apache.xerces.impl.XMLErrorReporter;
import org.apache.xerces.impl.msg.XMLMessageFormatter;
import org.apache.xerces.impl.validation.ContentModelValidator;
import org.apache.xerces.impl.validation.Grammar;
import org.apache.xerces.impl.validation.GrammarPool;
import org.apache.xerces.impl.validation.XMLAttributeDecl;
import org.apache.xerces.impl.validation.XMLElementDecl;
import org.apache.xerces.impl.validation.XMLEntityDecl;
import org.apache.xerces.impl.validation.XMLSimpleType ;
import org.apache.xerces.impl.validation.grammars.DTDGrammar;
import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.XMLChar;
import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLString;
import org.apache.xerces.xni.XMLAttributes;
import org.apache.xerces.xni.XMLDocumentFilter;
import org.apache.xerces.xni.XMLDocumentHandler;
import org.apache.xerces.xni.XMLDTDFilter;
import org.apache.xerces.xni.XMLDTDHandler;
import org.apache.xerces.xni.XMLDTDContentModelFilter;
import org.apache.xerces.xni.XMLDTDContentModelHandler;

import org.apache.xerces.impl.validation.DatatypeValidator;
import org.apache.xerces.impl.validation.datatypes.DatatypeValidatorFactoryImpl;
import org.apache.xerces.impl.validation.datatypes.ENTITYDatatypeValidator;
import org.apache.xerces.impl.validation.datatypes.IDDatatypeValidator;
import org.apache.xerces.impl.validation.datatypes.IDREFDatatypeValidator;
import org.apache.xerces.impl.validation.datatypes.ListDatatypeValidator;
import org.apache.xerces.impl.validation.datatypes.NOTATIONDatatypeValidator;
import org.apache.xerces.impl.validation.InvalidDatatypeFacetException;
import org.apache.xerces.impl.validation.InvalidDatatypeValueException;

import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.StringTokenizer;

/**
 * @author Eric Ye, IBM
 * @author Stubs generated by DesignDoc on Mon Sep 11 11:10:57 PDT 2000
 * @author Andy Clark, IBM
 * @author Jeffrey Rodriguez IBM
 *
 * @version $Id: XMLValidator.java 316692 2000-12-06 02:05:54Z andyc $
 */
public class XMLValidator
implements XMLComponent, 
XMLDocumentFilter, XMLDTDFilter, XMLDTDContentModelFilter {

    //        
    // Data
    //

    // components

    /** fSymbolTable */
    protected SymbolTable fSymbolTable;

    /** fErrorReporter */
    protected XMLErrorReporter fErrorReporter;

    /** fGrammarPool */
    protected GrammarPool fGrammarPool;

    /** fNamespaceBinder */
    protected XMLNamespaceBinder fNamespaceBinder;

    // features

    /** fNamespaces */
    protected boolean fNamespaces;

    /** fValidation */
    protected boolean fValidation;

    /** fDynamicValidation */
    protected boolean fDynamicValidation;

    // handlers

    /** Document handler. */
    protected XMLDocumentHandler fDocumentHandler;

    /** DTD handler. */
    protected XMLDTDHandler fDTDHandler;

    /** DTD content model handler. */
    protected XMLDTDContentModelHandler fDTDContentModelHandler;

    // grammars

    /** Current grammar. */
    protected Grammar fCurrentGrammar;
    protected boolean fCurrentGrammarIsDTD;
    protected boolean fCurrentGrammarIsSchema;

    /** DTD Grammar. */
    protected DTDGrammar fDTDGrammar;

    // state

    /** True if currently in the DTD. */
    protected boolean fInDTD;

    /** True if in an ignore conditional section of the DTD. */
    protected boolean fInDTDIgnore;

    /** Cache all infor regarding the current element */
    private QName fCurrentElement = new QName();
    private int fCurrentElementIndex = -1;
    private int fCurrentContentSpecType = -1;
    private boolean fNamespacesEnabled = false;
    private int fNamespacesPrefix = -1;
    private QName fRootElement = new QName();
    private boolean fSeenDoctypeDecl = false;

    private final int TOP_LEVEL_SCOPE = -1;
    private int fEmptyURI = - 1; 

    /** element stack */
    private int[] fElementIndexStack = new int[8];
    private int[] fContentSpecTypeStack = new int[8];
    private QName[] fElementQNamePartsStack      = new QName[8];

    /** childrent list and offset stack */
    private QName[] fElementChildren = new QName[32];
    private int fElementChildrenLength = 0;
    private int[] fElementChildrenOffsetStack = new int[32];
    private int fElementDepth = -1;

    /** validation states */
    private boolean fStandaloneIsYes = false;
    private boolean fSeenRootElement = false;
    private boolean fBufferDatatype = false;
    private boolean fInElementContent = false;

    /** temporary variables so that we create less objects */
    private XMLElementDecl fTempElementDecl = new XMLElementDecl();
    private XMLAttributeDecl fTempAttDecl = new XMLAttributeDecl();
    private XMLEntityDecl fEntityDecl = new XMLEntityDecl();
    private QName fTempQName = new QName();
    private StringBuffer fDatatypeBuffer = new StringBuffer();

    /** ndata notation hash */
    private Hashtable fNDataDeclNotations = new Hashtable();

    /** mixed element type hash */
    private String fDTDElementDeclName = null;
    private Vector fMixedElementTypes = new Vector();

    /** elementDecls in DTD */
    private Vector fDTDElementDecls = new Vector();

    // symbols

    private String fEMPTYSymbol ;
    private String fANYSymbol ;
    private String fMIXEDSymbol ;
    private String fCHILDRENSymbol ;
    private String fCDATASymbol ;
    private String fIDSymbol ;
    private String fIDREFSymbol ;
    private String fIDREFSSymbol ;
    private String fENTITYSymbol ;
    private String fENTITIESSymbol ;
    private String fNMTOKENSymbol ;
    private String fNMTOKENSSymbol ;
    private String fNOTATIONSymbol ;
    private String fENUMERATIONSymbol ;
    private String fREQUIREDSymbol ;
    private String fFIXEDSymbol ;
    private String fDATATYPESymbol ;


    /** Datatype Registry and attribute validators */

    private DatatypeValidatorFactoryImpl fDataTypeReg;
    private IDDatatypeValidator          fValID;
    private IDREFDatatypeValidator       fValIDRef;
    private ListDatatypeValidator        fValIDRefs;
    private ENTITYDatatypeValidator      fValENTITY;
    private ListDatatypeValidator        fValENTITIES;
    private DatatypeValidator            fValNMTOKEN;
    private DatatypeValidator            fValNMTOKENS;
    private NOTATIONDatatypeValidator    fValNOTATION;

    private Hashtable fTableOfIDs; //This table has to be own by instance of XMLValidator and shared among ID, IDREF and IDREFS
                                   //Only ID has read/write access
                                   //Should revisit and replace with a ligther structure

    /** DEBUG flags */
    private boolean DEBUG_ATTRIBUTES;
    private boolean DEBUG_ELEMENT_CHILDREN;

    /** to check for duplicate ID or ANNOTATION attribute declare in ATTLIST, and misc VCs*/

    private Hashtable fTableOfIDAttributeNames;
    private Hashtable fTableOfNOTATIONAttributeNames;
    private Hashtable fNotationEnumVals;


    //
    // Constructors
    //

    /** Default constructor. */
    public XMLValidator() {
    } // <init>()

    //
    // XMLComponent methods
    //

    /*
     * Resets the component. The component can query the component manager
     * about any features and properties that affect the operation of the
     * component.
     * 
     * @param componentManager The component manager.
     *
     * @throws SAXException Thrown by component on finitialization error.
     *                      For example, if a feature or property is
     *                      required for the operation of the component, the
     *                      component manager may throw a 
     *                      SAXNotRecognizedException or a
     *                      SAXNotSupportedException.
     */
    public void reset(XMLComponentManager configurationManager)
    throws SAXException {


        // clear grammars
        fCurrentGrammar = null;
        fDTDGrammar = null;
        fCurrentGrammarIsDTD = false;
        fCurrentGrammarIsSchema = true;

        // initialize state
        fInDTD = false;
        fInDTDIgnore = false;
        fStandaloneIsYes = false;
        fSeenRootElement = false;
        fBufferDatatype = false;
        fInElementContent = false;
        fCurrentElementIndex = -1;
        fCurrentContentSpecType = -1;

        fRootElement.clear();

        fNDataDeclNotations.clear();

        // sax features
        fValidation = configurationManager.getFeature(Constants.SAX_FEATURE_PREFIX+Constants.VALIDATION_FEATURE);

        // get needed components
        fErrorReporter = (XMLErrorReporter) configurationManager.getProperty(Constants.XERCES_PROPERTY_PREFIX+Constants.ERROR_REPORTER_PROPERTY);
        fSymbolTable = (SymbolTable) configurationManager.getProperty(Constants.XERCES_PROPERTY_PREFIX+Constants.SYMBOL_TABLE_PROPERTY);
        fGrammarPool = (GrammarPool) configurationManager.getProperty(Constants.XERCES_PROPERTY_PREFIX+Constants.GRAMMAR_POOL_PROPERTY);

        // plug in XMLNamespaceBinder
        fNamespaceBinder = new XMLNamespaceBinder();
        fNamespaceBinder.setOnlyPassPrefixMappingEvents(true);
        fNamespaceBinder.setDocumentHandler(fDocumentHandler);

        for (int i = 0; i < fElementQNamePartsStack.length; i++) {
            fElementQNamePartsStack[i] = new QName();
        }


        fElementDepth = -1;

        init();
    } // reset(XMLComponentManager)

    /**
     * Sets the state of a feature. This method is called by the component
     * manager any time after reset when a feature changes state. 
     * <p>
     * <strong>Note:</strong> Components should silently ignore features
     * that do not affect the operation of the component.
     * 
     * @param featureId The feature identifier.
     * @param state     The state of the feature.
     *
     * @throws SAXNotRecognizedException The component should not throw
     *                                   this exception.
     * @throws SAXNotSupportedException The component should not throw
     *                                  this exception.
     */
    public void setFeature(String featureId, boolean state)
    throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setFeature(String,boolean)

    /**
     * Sets the value of a property. This method is called by the component
     * manager any time after reset when a property changes value. 
     * <p>
     * <strong>Note:</strong> Components should silently ignore properties
     * that do not affect the operation of the component.
     * 
     * @param propertyId The property identifier.
     * @param value      The value of the property.
     *
     * @throws SAXNotRecognizedException The component should not throw
     *                                   this exception.
     * @throws SAXNotSupportedException The component should not throw
     *                                  this exception.
     */
    public void setProperty(String propertyId, Object value)
    throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setProperty(String,Object)

    //
    // XMLDocumentSource methods
    //

    /**
     * Sets the document handler to receive information about the document.
     * 
     * @param documentHandler The document handler.
     */
    public void setDocumentHandler(XMLDocumentHandler documentHandler) {
        fDocumentHandler = documentHandler;
    } // setDocumentHandler(XMLDocumentHandler)

    //
    // XMLDTDSource methods
    //

    /**
     * Sets the DTD handler.
     * 
     * @param dtdHandler The DTD handler.
     */
    public void setDTDHandler(XMLDTDHandler dtdHandler) {
        fDTDHandler = dtdHandler;
    } // setDTDHandler(XMLDTDHandler)

    //
    // XMLDTDContentModelSource methods
    //

    /**
     * Sets the DTD content model handler.
     * 
     * @param dtdContentModelHandler The DTD content model handler.
     */
    public void setDTDContentModelHandler(XMLDTDContentModelHandler dtdContentModelHandler) {
        fDTDContentModelHandler = dtdContentModelHandler;
    } // setDTDContentModelHandler(XMLDTDContentModelHandler)

    //
    // XMLDocumentHandler methods
    //

    /**
     * The start of the document.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startDocument() throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.startDocument();
        }

    } // startDocument()

    /**
     * Notifies of the presence of an XMLDecl line in the document. If
     * present, this method will be called immediately following the
     * startDocument call.
     * 
     * @param version    The XML version.
     * @param encoding   The IANA encoding name of the document, or null if
     *                   not specified.
     * @param standalone The standalone value, or null if not specified.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void xmlDecl(String version, String encoding, String standalone)
    throws SAXException {

        if (standalone != null)
            if (standalone.equals("yes")) {
                fStandaloneIsYes = true;
            }

            // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.xmlDecl(version, encoding, standalone);
        }

    } // xmlDecl(String,String,String)

    /**
     * Notifies of the presence of the DOCTYPE line in the document.
     * 
     * @param rootElement The name of the root element.
     * @param publicId    The public identifier if an external DTD or null
     *                    if the external DTD is specified using SYSTEM.
     * @param systemId    The system identifier if an external DTD, null
     *                    otherwise.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void doctypeDecl(String rootElement, String publicId, String systemId)
    throws SAXException {

        fRootElement.setValues(null, rootElement, rootElement, null);

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.doctypeDecl(rootElement, publicId, systemId);
        }

    } // doctypeDecl(String,String,String)

    /**
     * The start of a namespace prefix mapping. This method will only be
     * called when namespace processing is enabled.
     * 
     * @param prefix The namespace prefix.
     * @param uri    The URI bound to the prefix.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startPrefixMapping(String prefix, String uri)
    throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.startPrefixMapping(prefix, uri);
        }

    } // startPrefixMapping(String,String)

    /**
     * The start of an element. If the document specifies the start element
     * by using an empty tag, then the startElement method will immediately
     * be followed by the endElement method, with no intervening methods.
     * 
     * @param element    The name of the element.
     * @param attributes The element attributes.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startElement(QName element, XMLAttributes attributes)
    throws SAXException {

        // VC: Root Element Type
        // see if the root element's name matches the one in DoctypeDecl 
        if (!fSeenRootElement) {
            fSeenRootElement = true;
            rootElementSpecified(element);
        }

        //if fCurrentGrammar is Schema, do namespace binding here.
        if (fNamespaces && fCurrentGrammarIsSchema) {
            fNamespaceBinder.startElement(element, attributes);
        }

        if (fCurrentGrammar == null && !fValidation) {
            fCurrentElementIndex = -1;
            fCurrentContentSpecType = -1;
            fInElementContent = false;
        } else {

            if (fCurrentGrammarIsDTD) {
                //  resolve the element
                fCurrentElementIndex = fCurrentGrammar.getElementDeclIndex(element, -1);

                fCurrentContentSpecType = getContentSpecType(fCurrentElementIndex);
                if (fCurrentElementIndex == -1 && fValidation) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                               "MSG_ELEMENT_NOT_DECLARED",
                                               new Object[]{ element.rawname},
                                               XMLErrorReporter.SEVERITY_ERROR);
                } else {
                    //  0. insert default attributes
                    //  1. normalize the attributes
                    //  2. validate the attrivute list.
                    // TO DO: 
                    // 
                    addDTDDefaultAttrsAndValidate(fCurrentElementIndex, attributes);
                }
            }
            // fCurrentGrammar Is a Schema
            else {
            }

        }

        if (fValidation && fCurrentContentSpecType == XMLElementDecl.TYPE_SIMPLE) {
            fBufferDatatype = true;
            fDatatypeBuffer.setLength(0);
        }

        fInElementContent = (fCurrentContentSpecType == XMLElementDecl.TYPE_CHILDREN);

        // increment the element depth, add this element's 
        // QName to its enclosing element 's children list
        fElementDepth++;
        //if (fElementDepth >= 0) {
        if (fValidation) {
            // push current length onto stack
            if (fElementChildrenOffsetStack.length < fElementDepth) {
                int newarray[] = new int[fElementChildrenOffsetStack.length * 2];
                System.arraycopy(fElementChildrenOffsetStack, 0, newarray, 0, fElementChildrenOffsetStack.length);
                fElementChildrenOffsetStack = newarray;
            }
            fElementChildrenOffsetStack[fElementDepth] = fElementChildrenLength;

            // add this element to children
            if (fElementChildren.length <= fElementChildrenLength) {
                QName[] newarray = new QName[fElementChildrenLength * 2];
                System.arraycopy(fElementChildren, 0, newarray, 0, fElementChildren.length);
                fElementChildren = newarray;
            }
            QName qname = fElementChildren[fElementChildrenLength];
            if (qname == null) {
                for (int i = fElementChildrenLength; i < fElementChildren.length; i++) {
                    fElementChildren[i] = new QName();
                }
                qname = fElementChildren[fElementChildrenLength];
            }
            qname.setValues(element);
            fElementChildrenLength++;

        }


        ensureStackCapacity(fElementDepth);

        fCurrentElement.setValues(element);

        fElementQNamePartsStack[fElementDepth].setValues(fCurrentElement); 

        fElementIndexStack[fElementDepth] = fCurrentElementIndex;
        fContentSpecTypeStack[fElementDepth] = fCurrentContentSpecType;

        //if fCurrentGrammar is DTD, do namespace binding here.
        if (fNamespaces && fCurrentGrammarIsDTD) {
            fNamespaceBinder.startElement(element, attributes);
        }

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.startElement(element, attributes);
        }

    } // startElement(QName,XMLAttributes)

    /**
     * Character content.
     * 
     * @param text The content.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void characters(XMLString text) throws SAXException {
        boolean callNextCharacters = true;

        boolean allWhiteSpace = true;
        for (int i=text.offset; i< text.offset+text.length; i++) {
            if (!XMLChar.isSpace(text.ch[i])) {
                allWhiteSpace = false;
                break;
            }
        }

        // if in children model, and all charaters are white spaces, call the ignoreableWhiteSpace callback.
        if (fInElementContent && allWhiteSpace) {
            if (fDocumentHandler != null) {
                fDocumentHandler.ignorableWhitespace(text);
                callNextCharacters = false;
            }
        }

        if (fValidation) {
            if (fInElementContent) {
                if (fCurrentGrammarIsDTD && 
                    fStandaloneIsYes &&
                    ((DTDGrammar)fCurrentGrammar).getElementDeclIsExternal(fCurrentElementIndex)) {
                    if (allWhiteSpace) {
                        fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                    "MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE",
                                                    null, XMLErrorReporter.SEVERITY_ERROR);
                    }
                }
                if (!allWhiteSpace) {
                    charDataInContent();
                }
            }

            if (fCurrentContentSpecType == XMLElementDecl.TYPE_EMPTY) {
                charDataInContent();
            }
            if (fBufferDatatype) {
                fDatatypeBuffer.append(text.ch, text.offset, text.length);
            }
        }
        // call handlers
        if (callNextCharacters && fDocumentHandler != null) {
            fDocumentHandler.characters(text);
        }

    } // characters(XMLString)

    /**
     * Ignorable whitespace. For this method to be called, the document
     * source must have some way of determining that the text containing
     * only whitespace characters should be considered ignorable. For
     * example, the validator can determine if a length of whitespace
     * characters in the document are ignorable based on the element
     * content model.
     * 
     * @param text The ignorable whitespace.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void ignorableWhitespace(XMLString text) throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.ignorableWhitespace(text);
        }

    } // ignorableWhitespace(XMLString)

    /**
     * The end of an element.
     * 
     * @param element The name of the element.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endElement(QName element) throws SAXException {

        fElementDepth--;

        if (fValidation) {
            int elementIndex = fCurrentElementIndex;
            if (elementIndex != -1 && fCurrentContentSpecType != -1) {
                QName children[] = fElementChildren;
                int childrenOffset = fElementChildrenOffsetStack[fElementDepth + 1] + 1;
                int childrenLength = fElementChildrenLength - childrenOffset;
                int result = checkContent(elementIndex, 
                                          children, childrenOffset, childrenLength);


                if (result != -1) {
                    fCurrentGrammar.getElementDecl(elementIndex, fTempElementDecl);
                    if (fTempElementDecl.type == XMLElementDecl.TYPE_EMPTY) {
                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                                   "MSG_CONTENT_INVALID",
                                                   new Object[]{ element.rawname, "EMPTY"},
                                                   XMLErrorReporter.SEVERITY_ERROR);
                    } else {
                        String messageKey = result != childrenLength ? 
                                            "MSG_CONTENT_INVALID" : "MSG_CONTENT_INCOMPLETE";
                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                                   messageKey,
                                                   new Object[]{ element.rawname, 
                                                       fCurrentGrammar.getContentSpecAsString(elementIndex)},
                                                   XMLErrorReporter.SEVERITY_ERROR);
                    }
                }
            }
            fElementChildrenLength = fElementChildrenOffsetStack[fElementDepth + 1] + 1;
        }

        // call handlers
        if (fDocumentHandler != null) {
            // call fNamesapceBinder to fire up endPrefixMapping events
            fNamespaceBinder.endElement(fCurrentElement);
            fDocumentHandler.endElement(fCurrentElement);
        }

        // now pop this element off the top of the element stack
        if (fElementDepth < -1) {
            throw new RuntimeException("FWK008 Element stack underflow");
        }
        if (fElementDepth < 0) {
            fCurrentElement.clear();
            fCurrentElementIndex = -1;
            fCurrentContentSpecType = -1;
            fInElementContent = false;

            // TO DO : fix this
            //
            // Check after document is fully parsed
            // (1) check that there was an element with a matching id for every
            //   IDREF and IDREFS attr (V_IDREF0)
            //

            if (fValidation) {
                try {
                    fValIDRef.validate();//Do final validation of IDREFS against IDs
                    fValIDRefs.validate();
                } catch (InvalidDatatypeValueException ex) {
                    String  key = ex.getKeyIntoReporter();

                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                key,
                                                new Object[]{ ex.getMessage()},
                                                XMLErrorReporter.SEVERITY_ERROR );
                }
            fTableOfIDs.clear();//Clear table of IDs
            }
            return;
        }

        if (fNamespaces) { //If Namespace enable then localName != rawName
            fCurrentElement.localpart = fElementQNamePartsStack[fElementDepth].localpart;
        } else {//REVISIT - jeffreyr - This is so we still do old behavior when namespace is off 
            fCurrentElement.localpart = fElementQNamePartsStack[fElementDepth].rawname;
        }
        fCurrentElement.rawname      = fElementQNamePartsStack[fElementDepth].rawname;
        fCurrentElement.uri          = fElementQNamePartsStack[fElementDepth].uri;
        fCurrentElement.prefix       = fElementQNamePartsStack[fElementDepth].prefix;

        fCurrentElementIndex = fElementIndexStack[fElementDepth];
        fCurrentContentSpecType = fContentSpecTypeStack[fElementDepth];
        fInElementContent = (fCurrentContentSpecType == XMLElementDecl.TYPE_CHILDREN);

        if (fValidation) {
            fBufferDatatype = false;
        }

    } // endElement(QName)

    /**
     * The end of a namespace prefix mapping. This method will only be
     * called when namespace processing is enabled.
     * 
     * @param prefix The namespace prefix.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endPrefixMapping(String prefix) throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.endPrefixMapping(prefix);
        }

    } // endPrefixMapping(String)

    /** 
     * The start of a CDATA section. 
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startCDATA() throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.startCDATA();
        }

    } // startCDATA()

    /**
     * The end of a CDATA section. 
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endCDATA() throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.endCDATA();
        }

    } // endCDATA()

    /**
     * The end of the document.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endDocument() throws SAXException {

        // call handlers
        if (fDocumentHandler != null) {
            fDocumentHandler.endDocument();
        }

    } // endDocument()

    //
    // XMLDocumentHandler and XMLDTDHandler methods
    //

    /**
     * This method notifies of the start of an entity. The document entity
     * has the pseudo-name of "[xml]"; The DTD has the pseudo-name of "[dtd]; 
     * parameter entity names start with '%'; and general entity names are
     * just the entity name.
     * <p>
     * <strong>Note:</strong> Since the document is an entity, the handler
     * will be notified of the start of the document entity by calling the
     * startEntity method with the entity name "[xml]" <em>before</em> calling
     * the startDocument method. When exposing entity boundaries through the
     * SAX API, the document entity is never reported, however.
     * <p>
     * <strong>Note:</strong> Since the DTD is an entity, the handler
     * will be notified of the start of the DTD entity by calling the
     * startEntity method with the entity name "[dtd]" <em>before</em> calling
     * the startDTD method.
     * <p>
     * <strong>Note:</strong> This method is not called for entity references
     * appearing as part of attribute values.
     * 
     * @param name     The name of the entity.
     * @param publicId The public identifier of the entity if the entity
     *                 is external, null otherwise.
     * @param systemId The system identifier of the entity if the entity
     *                 is external, null otherwise.
     * @param encoding The auto-detected IANA encoding name of the entity
     *                 stream. This value will be null in those situations
     *                 where the entity encoding is not auto-detected (e.g.
     *                 internal parameter entities).
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startEntity(String name, String publicId, String systemId,
                            String encoding) throws SAXException {
        // call handlers
        if (fInDTD) {
            fDTDGrammar.startEntity(name, publicId, systemId, encoding);
            if (fDTDHandler != null) {
                fDTDHandler.startEntity(name, publicId, systemId, encoding);
            }
        } else {
            // check VC: Standalone Document Declartion, entities references appear in the document.
            if (fValidation && fCurrentGrammar != null) {
                if (fStandaloneIsYes && !name.startsWith("[")) {
                    int entIndex = fCurrentGrammar.getEntityDeclIndex(name);
                    if (entIndex > -1) {
                        fCurrentGrammar.getEntityDecl(entIndex, fEntityDecl);
                        if (fEntityDecl.inExternal) {
                            fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                        "MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE",
                                                        new Object[]{name}, XMLErrorReporter.SEVERITY_ERROR);
                        }
                    }
                }
            }

            if (fDocumentHandler != null) {
                fDocumentHandler.startEntity(name, publicId, systemId, encoding);
            }
        }

    } // startEntity(String,String,String,String)

    /**
     * Notifies of the presence of a TextDecl line in an entity. If present,
     * this method will be called immediately following the startEntity call.
     * <p>
     * <strong>Note:</strong> This method will never be called for the
     * document entity; it is only called for external general entities
     * referenced in document content.
     * <p>
     * <strong>Note:</strong> This method is not called for entity references
     * appearing as part of attribute values.
     * 
     * @param version  The XML version, or null if not specified.
     * @param encoding The IANA encoding name of the entity.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void textDecl(String version, String encoding) throws SAXException {

        // call handlers
        if (fInDTD) {
            fDTDGrammar.textDecl(version, encoding);
            if (fDTDHandler != null) {
                fDTDHandler.textDecl(version, encoding);
            }
        } else {
            if (fDocumentHandler != null) {
                fDocumentHandler.textDecl(version, encoding);
            }
        }

    } // textDecl(String,String)

    /**
     * A comment.
     * 
     * @param text The text in the comment.
     *
     * @throws SAXException Thrown by application to signal an error.
     */
    public void comment(XMLString text) throws SAXException {

        // call handlers
        if (fInDTD) {
            fDTDGrammar.comment(text);
            if (fDTDHandler != null) {
                fDTDHandler.comment(text);
            }
        } else {
            if (fDocumentHandler != null) {
                fDocumentHandler.comment(text);
            }
        }

    } // comment(XMLString)

    /**
     * A processing instruction. Processing instructions consist of a
     * target name and, optionally, text data. The data is only meaningful
     * to the application.
     * <p>
     * Typically, a processing instruction's data will contain a series
     * of pseudo-attributes. These pseudo-attributes follow the form of
     * element attributes but are <strong>not</strong> parsed or presented
     * to the application as anything other than text. The application is
     * responsible for parsing the data.
     * 
     * @param target The target.
     * @param data   The data or null if none specified.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void processingInstruction(String target, XMLString data)
    throws SAXException {

        // call handlers
        if (fInDTD) {
            fDTDGrammar.processingInstruction(target, data);
            if (fDTDHandler != null) {
                fDTDHandler.processingInstruction(target, data);
            }
        } else {
            if (fDocumentHandler != null) {
                fDocumentHandler.processingInstruction(target, data);
            }
        }

    } // processingInstruction(String,XMLString)

    /**
     * This method notifies the end of an entity. The document entity has
     * the pseudo-name of "[xml]"; the DTD has the pseudo-name of "[dtd]; 
     * parameter entity names start with '%'; and general entity names are
     * just the entity name.
     * <p>
     * <strong>Note:</strong> Since the document is an entity, the handler
     * will be notified of the end of the document entity by calling the
     * endEntity method with the entity name "[xml]" <em>after</em> calling
     * the endDocument method. When exposing entity boundaries through the
     * SAX API, the document entity is never reported, however.
     * <p>
     * <strong>Note:</strong> Since the DTD is an entity, the handler
     * will be notified of the end of the DTD entity by calling the
     * endEntity method with the entity name "[dtd]" <em>after</em> calling
     * the endDTD method.
     * <p>
     * <strong>Note:</strong> This method is not called for entity references
     * appearing as part of attribute values.
     * 
     * @param name The name of the entity.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endEntity(String name) throws SAXException {

        // call handlers
        if (fInDTD) {
            fDTDGrammar.endEntity(name);
            if (fDTDHandler != null) {
                fDTDHandler.endEntity(name);
            }
        } else {
            if (fDocumentHandler != null) {
                fDocumentHandler.endEntity(name);
            }
        }

    } // endEntity(String)

    //
    // XMLDTDHandler methods
    //

    /**
     * The start of the DTD.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startDTD() throws SAXException {

        // initialize state
        fInDTD = true;
        fNDataDeclNotations.clear();
        fDTDElementDecls.removeAllElements();

        // create DTD grammar
        fDTDGrammar = new DTDGrammar();
        // REVISIT: should we use the systemId as the key instead?
        fGrammarPool.putGrammar("", fDTDGrammar);


        // call handlers
        fDTDGrammar.startDTD();
        if (fDTDHandler != null) {
            fDTDHandler.startDTD();
        }

    } // startDTD()

    /**
     * An element declaration.
     * 
     * @param name         The name of the element.
     * @param contentModel The element content model.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void elementDecl(String name, String contentModel)
    throws SAXException {

        //check VC: Unique Element Declaration
        if (fValidation) {
            if (fDTDElementDecls.contains(name)) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "MSG_ELEMENT_ALREADY_DECLARED",
                                           new Object[]{ name},
                                           XMLErrorReporter.SEVERITY_ERROR);
            } else {
                fDTDElementDecls.addElement(name);
            }
        }

        // call handlers
        fDTDGrammar.elementDecl(name, contentModel);
        if (fDTDHandler != null) {
            fDTDHandler.elementDecl(name, contentModel);
        }

    } // elementDecl(String,String)

    /**
     * The start of an attribute list.
     * 
     * @param elementName The name of the element that this attribute
     *                    list is associated with.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startAttlist(String elementName) throws SAXException {
        // call handlers

        fDTDGrammar.startAttlist(elementName);
        if (fDTDHandler != null) {
            fDTDHandler.startAttlist(elementName);
        }

    } // startAttlist(String)

    /**
     * An attribute declaration.
     * 
     * @param elementName   The name of the element that this attribute
     *                      is associated with.
   * @param attributeName The name of the attribute.
     * @param type          The attribute type. This value will be one of
     *                      the following: "CDATA", "ENTITY", "ENTITIES",
     *                      "ENUMERATION", "ID", "IDREF", "IDREFS", 
     *                      "NMTOKEN", "NMTOKENS", or "NOTATION".
     * @param enumeration   If the type has the value "ENUMERATION", this
     *                      array holds the allowed attribute values;
     *                      otherwise, this array is null.
     * @param defaultType   The attribute default type. This value will be
     *                      one of the following: "#FIXED", "#IMPLIED",
     *                      "#REQUIRED", or null.
     * @param defaultValue  The attribute default value, or null if no
     *                      default value is specified.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    String fnameOfElement;

    public void attributeDecl(String elementName, String attributeName, 
                              String type, String[] enumeration, 
                              String defaultType, XMLString defaultValue)
    throws SAXException {

        if (fValidation) {
            //
            // a) VC: One ID per Element Type, If duplicate ID attribute 
            // b) VC: ID attribute Default. if there is a declareared attribute default for ID it should be of type #IMPLIED or #REQUIRED                                               
            if (type.equals("ID")) {

                if (defaultValue != null) {
                    if (defaultValue.length != 0) {
                        if (defaultType == null || ! ( defaultType.equals("#IMPLIED") || defaultType.equals("#REQUIRED" ) )) {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "IDDefaultTypeInvalid",
                                                       new Object[]{ attributeName},
                                                       XMLErrorReporter.SEVERITY_ERROR);
                        }
                    }
                }

                if (fTableOfIDAttributeNames.containsKey( elementName ) == false) {
                    fTableOfIDAttributeNames.put( elementName, attributeName);
                } else {
                    String previousIDAttributeName = (String) fTableOfIDAttributeNames.get( elementName );//rule a)
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "MSG_MORE_THAN_ONE_ID_ATTRIBUTE",
                                               new Object[]{ elementName, previousIDAttributeName, attributeName},
                                               XMLErrorReporter.SEVERITY_ERROR);
                }
            }

            //
            //  VC: One Notaion Per Element Type, should check if there is a duplicate NOTATION attribute 

            if (type.equals("NOTATION")) {
                // VC: Notation Attributes:
                //     all notation names in the (attribute) declaration must be declared.
                for (int i=0; i<enumeration.length; i++) {
                    fNotationEnumVals.put(enumeration[i], attributeName);
                }

                if (fTableOfNOTATIONAttributeNames.containsKey( elementName ) == false) {
                    fTableOfNOTATIONAttributeNames.put( elementName, attributeName);
                } else {
                    String previousNOTATIONAttributeName = (String) fTableOfNOTATIONAttributeNames.get( elementName );
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE",
                                               new Object[]{ elementName, previousNOTATIONAttributeName, attributeName},
                                               XMLErrorReporter.SEVERITY_ERROR);
                }
            }

            // VC: Attribute Default Legal
            boolean ok = true;
            if (defaultValue != null && 
                (defaultType==null || (defaultType != null && defaultType.equals("#FIXED"))))
                if (type.equals("NMTOKENS") || type.equals("ENTITIES") || type.equals("IDREFS")) {

                    // Since the default value has been normalized, there should be any leading or trailing spaces
                    String trimmedValue = defaultValue.toString().trim();

                    if (trimmedValue.length() == 0 || ! defaultValue.equals(trimmedValue)) {
                        ok = false;
                    } else {
                        StringTokenizer tokenizer = new StringTokenizer(trimmedValue);
                        if (tokenizer.hasMoreTokens()) {
                            while (true) {
                                String nmtoken = tokenizer.nextToken();
                                if (type.equals("NMTOKENS")) {
                                    if (!XMLChar.isValidNmtoken(nmtoken)) {
                                        ok = false;
                                        break;
                                    }
                                } else if (type.equals("ENTITIES")||type.equals("IDREFS")) {
                                    if (!XMLChar.isValidName(nmtoken)) {
                                        ok = false;
                                        break;
                                    }
                                }
                                if (!tokenizer.hasMoreTokens()) {
                                    break;
                                }
                            }
                        }
                    }

                } else {
                    if (type.equals("ENTITY") ||
                        type.equals("ID") ||
                        type.equals("IDREF") ||
                        type.equals("NOTATION")) {


                        if (!XMLChar.isValidName( defaultValue.toString())) {
                            ok = false;
                        }

                    } else if (type.equals("NMTOKEN") ||
                               type.equals("ENUMERATION")) {

                        if (!XMLChar.isValidNmtoken( defaultValue.toString())) {
                            ok = false;
                        }
                    }

                    if (type.equals("NOTATION") ||
                        type.equals("ENUMERATION")) {
                        ok = false;
                        for (int i=0; i<enumeration.length; i++) {
                            if (defaultValue.equals(enumeration[i])) {
                                ok = true;
                            }
                        }
                    }

                }
            if (!ok) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "MSG_ATT_DEFAULT_INVALID",
                                           new Object[]{attributeName, defaultValue.toString()},
                                           XMLErrorReporter.SEVERITY_ERROR);
            }

        }

        // call handlers
        fDTDGrammar.attributeDecl(elementName, attributeName, 
                                  type, enumeration,
                                  defaultType, defaultValue);
        if (fDTDHandler != null) {
            fDTDHandler.attributeDecl(elementName, attributeName, 
                                      type, enumeration, 
                                      defaultType, defaultValue);
        }

    } // attributeDecl(String,String,String,String[],String,XMLString)

    /**
     * The end of an attribute list.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endAttlist() throws SAXException {


        // call handlers

        fDTDGrammar.endAttlist();
        if (fDTDHandler != null) {
            fDTDHandler.endAttlist();
        }

    } // endAttlist()

    /**
     * An internal entity declaration.
     * 
     * @param name The name of the entity. Parameter entity names start with
     *             '%', whereas the name of a general entity is just the 
     *             entity name.
     * @param text The value of the entity.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void internalEntityDecl(String name, XMLString text) 
    throws SAXException {

        // call handlers
        fDTDGrammar.internalEntityDecl(name, text);
        if (fDTDHandler != null) {
            fDTDHandler.internalEntityDecl(name, text);
        }

    } // internalEntityDecl(String,XMLString)

    /**
     * An external entity declaration.
     * 
     * @param name     The name of the entity. Parameter entity names start
     *                 with '%', whereas the name of a general entity is just
     *                 the entity name.
     * @param publicId The public identifier of the entity or null if the
     *                 the entity was specified with SYSTEM.
     * @param systemId The system identifier of the entity.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void externalEntityDecl(String name, 
                                   String publicId, String systemId) 
    throws SAXException {

        // call handlers
        fDTDGrammar.externalEntityDecl(name, publicId, systemId);
        if (fDTDHandler != null) {
            fDTDHandler.externalEntityDecl(name, publicId, systemId);
        }

    } // externalEntityDecl(String,String,String)

    /**
     * An unparsed entity declaration.
     * 
     * @param name     The name of the entity.
     * @param publicId The public identifier of the entity, or null if not
     *                 specified.
     * @param systemId The system identifier of the entity, or null if not
     *                 specified.
     * @param notation The name of the notation.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void unparsedEntityDecl(String name, 
                                   String publicId, String systemId, 
                                   String notation) throws SAXException {

        // VC: Notation declared,  in the production of NDataDecl
        if (fValidation) {
            fNDataDeclNotations.put(name, notation);
        }

        // call handlers
        fDTDGrammar.unparsedEntityDecl(name, publicId, systemId, notation);
        if (fDTDHandler != null) {
            fDTDHandler.unparsedEntityDecl(name, publicId, systemId, notation);
        }

    } // unparsedEntityDecl(String,String,String,String)

    /**
     * A notation declaration
     * 
     * @param name     The name of the notation.
     * @param publicId The public identifier of the notation, or null if not
     *                 specified.
     * @param systemId The system identifier of the notation, or null if not
     *                 specified.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void notationDecl(String name, String publicId, String systemId)
    throws SAXException {

        // call handlers
        fDTDGrammar.notationDecl(name, publicId, systemId);
        if (fDTDHandler != null) {
            fDTDHandler.notationDecl(name, publicId, systemId);
        }

    } // notationDecl(String,String,String)

    /**
     * The start of a conditional section.
     * 
     * @param type The type of the conditional section. This value will
     *             either be CONDITIONAL_INCLUDE or CONDITIONAL_IGNORE.
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see CONDITIONAL_INCLUDE
     * @see CONDITIONAL_IGNORE
     */
    public void startConditional(short type) throws SAXException {

        // set state
        fInDTDIgnore = type == XMLDTDHandler.CONDITIONAL_IGNORE;

        // call handlers
        fDTDGrammar.startConditional(type);
        if (fDTDHandler != null) {
            fDTDHandler.startConditional(type);
        }

    } // startConditional(short)

    /**
     * The end of a conditional section.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endConditional() throws SAXException {

        // set state
        fInDTDIgnore = false;

        // call handlers
        fDTDGrammar.endConditional();
        if (fDTDHandler != null) {
            fDTDHandler.endConditional();
        }

    } // endConditional()

    /**
     * The end of the DTD.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endDTD() throws SAXException {

        // set state
        fInDTD = false;

        // save grammar
        fDTDGrammar.endDTD();
        fCurrentGrammar = fDTDGrammar;
        fDTDGrammar = null;
        // REVESIT: if schema validation is turned on, we shouldn't be doing this.
        fCurrentGrammarIsDTD = true;
        fCurrentGrammarIsSchema = false;

        // check VC: Notation declared,  in the production of NDataDecl
        if (fValidation) {

            fValENTITY.initialize(fCurrentGrammar);//Initialize ENTITY, ENTITIES validators 
            fValENTITIES.initialize(fCurrentGrammar);

            // VC : Notation Declared. for external entity declaration [Production 76].
            Enumeration entities = fNDataDeclNotations.keys();
            while (entities.hasMoreElements()) {
                String entity = (String) entities.nextElement();
                String notation = (String) fNDataDeclNotations.get(entity);
                if (fCurrentGrammar.getNotationDeclIndex(notation) == -1) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL",
                                               new Object[]{entity, notation},
                                               XMLErrorReporter.SEVERITY_ERROR);
                }
            }

            // VC: Notation Attributes:
            //     all notation names in the (attribute) declaration must be declared.
            Enumeration notationVals = fNotationEnumVals.keys();
            while (notationVals.hasMoreElements()) {
                String notation = (String) notationVals.nextElement();
                String attributeName = (String) fNotationEnumVals.get(notation);
                if (fCurrentGrammar.getNotationDeclIndex(notation) == -1) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE",
                                               new Object[]{attributeName, notation},
                                               XMLErrorReporter.SEVERITY_ERROR);
                }
            }

            fTableOfIDAttributeNames = null;//should be safe to release these references
            fTableOfNOTATIONAttributeNames = null;
        }

        // call handlers
        if (fDTDHandler != null) {
            fDTDHandler.endDTD();
        }

    } // endDTD()

    //
    // XMLDTDContentModelHandler methods
    //

    /**
     * The start of a content model. Depending on the type of the content
     * model, specific methods may be called between the call to the
     * startContentModel method and the call to the endContentModel method.
     * 
     * @param elementName The name of the element.
     * @param type        The content model type.
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see TYPE_EMPTY
     * @see TYPE_ANY
     * @see TYPE_MIXED
     * @see TYPE_CHILDREN
     */
    public void startContentModel(String elementName, short type)
    throws SAXException {

        if (fValidation) {
            fDTDElementDeclName = elementName;
            fMixedElementTypes.removeAllElements();
        }

        // call handlers
        fDTDGrammar.startContentModel(elementName, type);
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.startContentModel(elementName, type);
        }

    } // startContentModel(String,short)

    /**
     * A referenced element in a mixed content model. If the mixed content 
     * model only allows text content, then this method will not be called
     * for that model. However, if this method is called for a mixed
     * content model, then the zero or more occurrence count is implied.
     * <p>
     * <strong>Note:</strong> This method is only called after a call to 
     * the startContentModel method where the type is TYPE_MIXED.
     * 
     * @param elementName The name of the referenced element. 
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see TYPE_MIXED
     */
    public void mixedElement(String elementName) throws SAXException {
        // check VC: No duplicate Types, in a single mixed-content declaration
        if (fValidation) {
            if (fMixedElementTypes.contains(elementName)) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "DuplicateTypeInMixedContent",
                                           new Object[]{fDTDElementDeclName, elementName},
                                           XMLErrorReporter.SEVERITY_ERROR);
            } else {
                fMixedElementTypes.addElement(elementName);
            }
        }

        // call handlers
        fDTDGrammar.mixedElement(elementName);
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.mixedElement(elementName);
        }

    } // mixedElement(elementName)

    /**
     * The start of a children group.
     * <p>
     * <strong>Note:</strong> This method is only called after a call to
     * the startContentModel method where the type is TYPE_CHILDREN.
     * <p>
     * <strong>Note:</strong> Children groups can be nested and have
     * associated occurrence counts.
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see TYPE_CHILDREN
     */
    public void childrenStartGroup() throws SAXException {

        // call handlers
        fDTDGrammar.childrenStartGroup();
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.childrenStartGroup();
        }

    } // childrenStartGroup()

    /**
     * A referenced element in a children content model.
     * 
     * @param elementName The name of the referenced element.
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see TYPE_CHILDREN
     */
    public void childrenElement(String elementName) throws SAXException {

        // call handlers
        fDTDGrammar.childrenElement(elementName);
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.childrenElement(elementName);
        }

    } // childrenElement(String)

    /**
     * The separator between choices or sequences of a children content
     * model.
     * <p>
     * <strong>Note:</strong> This method is only called after a call to
     * the startContentModel method where the type is TYPE_CHILDREN.
     * 
     * @param separator The type of children separator.
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see SEPARATOR_CHOICE
     * @see SEPARATOR_SEQUENCE
     * @see TYPE_CHILDREN
     */
    public void childrenSeparator(short separator) throws SAXException {

        // call handlers
        fDTDGrammar.childrenSeparator(separator);
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.childrenSeparator(separator);
        }

    } // childrenSeparator(short)

    /**
     * The occurrence count for a child in a children content model.
     * <p>
     * <strong>Note:</strong> This method is only called after a call to
     * the startContentModel method where the type is TYPE_CHILDREN.
     * 
     * @param occurrence The occurrence count for the last children element
     *                   or children group.
     *
     * @throws SAXException Thrown by handler to signal an error.
     *
     * @see OCCURS_ZERO_OR_ONE
     * @see OCCURS_ZERO_OR_MORE
     * @see OCCURS_ONE_OR_MORE
     * @see TYPE_CHILDREN
     */
    public void childrenOccurrence(short occurrence) throws SAXException {

        // call handlers
        fDTDGrammar.childrenOccurrence(occurrence);
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.childrenOccurrence(occurrence);
        }

    } // childrenOccurrence(short)

    /**
     * The end of a children group.
     * <p>
     * <strong>Note:</strong> This method is only called after a call to
     * the startContentModel method where the type is TYPE_CHILDREN.
     *
     * @see TYPE_CHILDREN
     */
    public void childrenEndGroup() throws SAXException {

        // call handlers
        fDTDGrammar.childrenEndGroup();
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.childrenEndGroup();
        }

    } // childrenEndGroup()

    /**
     * The end of a content model.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endContentModel() throws SAXException {

        // call handlers
        fDTDGrammar.endContentModel();
        if (fDTDContentModelHandler != null) {
            fDTDContentModelHandler.endContentModel();
        }

    } // endContentModel()



    //
    //
    //private methods
    //
    //


    /** addDTDDefaultAttributes. */
    private void addDTDDefaultAttrsAndValidate( int elementIndex, XMLAttributes attributes) throws SAXException {

        if (elementIndex == -1) {
            return ;
        }

        fCurrentGrammar.getElementDecl(elementIndex,fTempElementDecl);

        QName element = fTempElementDecl.name;

        //
        // Check after all specified attrs are scanned
        // (1) report error for REQUIRED attrs that are missing (V_TAGc)
        // (2) add default attrs (FIXED and NOT_FIXED)
        //
        int attlistIndex = fCurrentGrammar.getFirstAttributeDeclIndex(elementIndex);

        while (attlistIndex != -1) {

            fCurrentGrammar.getAttributeDecl(attlistIndex, fTempAttDecl);

            if (DEBUG_ATTRIBUTES)
                if (fTempAttDecl != null) {
                    XMLElementDecl elementDecl = new XMLElementDecl();
                    fCurrentGrammar.getElementDecl(elementIndex, elementDecl);
                    System.out.println("element: "+(elementDecl.name.localpart));
                    System.out.println("attlistIndex " + attlistIndex + "\n"+
                                       "attName : '"+(fTempAttDecl.name.localpart) + "'\n"
                                       + "attType : "+fTempAttDecl.simpleType.type + "\n"
                                       + "attDefaultType : "+fTempAttDecl.simpleType.defaultType + "\n"
                                       + "attDefaultValue : '"+fTempAttDecl.simpleType.defaultValue + "'\n"
                                       + attributes.getLength() +"\n"
                                      );
                }

            String attPrefix = fTempAttDecl.name.prefix;
            String attRawName = fTempAttDecl.name.rawname;
            String attLocalpart = fTempAttDecl.name.localpart;
            String attType = attributeTypeName(fTempAttDecl);
            int attDefaultType =fTempAttDecl.simpleType.defaultType;
            String attValue = null;

            if (fTempAttDecl.simpleType.defaultValue != null) {
                attValue = fTempAttDecl.simpleType.defaultValue;
            }
            boolean specified = false;
            boolean required = attDefaultType == XMLSimpleType.DEFAULT_TYPE_REQUIRED;
            boolean cdata = attType == fCDATASymbol;

            if (!cdata || required || attValue != null) {
                int attrCount = attributes.getLength();
                for (int i = 0; i < attrCount; i++) {
                    if (attributes.getName(i) == attRawName) {
                        specified = true;
                        break;
                    }
                }
            }

            if (!specified) {
                if (required) {
                    if (fValidation) {
                        Object[] args = { element.localpart,
                            attRawName};
                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                   "MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED", args,
                                                   XMLErrorReporter.SEVERITY_ERROR);
                    }
                } else if (attValue != null) {
                    if (fValidation && fStandaloneIsYes)
                        if (((DTDGrammar) fCurrentGrammar).getAttributeDeclIsExternal(attlistIndex)) {

                            Object[] args = { element.localpart,
                                attRawName};
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED", args,
                                                       XMLErrorReporter.SEVERITY_ERROR);
                        }

                    fTempQName.setValues(attPrefix, attLocalpart, attRawName, fTempAttDecl.name.uri);
                    int newAttr = attributes.addAttribute(fTempQName, attType, attValue);
                }
            }
            // get next att decl in the Grammar for this element
            attlistIndex = fCurrentGrammar.getNextAttributeDeclIndex(attlistIndex);
        }

        // now iterate through the expanded attributes for
        // 1. if every attribute seen is declared in the DTD
        // 2. check if the VC: default_fixed holds
        // 3. validate every attribute.
        if (fValidation) {
            int attrCount = attributes.getLength();
            for (int i = 0; i< attrCount; i++) {
                String attrRawName = attributes.getName(i);
                boolean declared = false;

                if (fCurrentGrammar != null) {
                    // check VC: Standalone Document Declartion, entities references appear in the document.
                    // REVISIT: this can be combined to a single check in startEntity 
                    // if we add one more argument in startEnity, inAttrValue
                    if (fStandaloneIsYes) {
                        int entityCount = attributes.getEntityCount(i);
                        for (int j=0;  j < entityCount; j++) {
                            String entityName= attributes.getEntityName(i, j);
                            int entIndex = fCurrentGrammar.getEntityDeclIndex(entityName);
                            if (entIndex > -1) {
                                fCurrentGrammar.getEntityDecl(entIndex, fEntityDecl);
                                if (fEntityDecl.inExternal) {
                                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                                "MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE",
                                                                new Object[]{entityName}, XMLErrorReporter.SEVERITY_ERROR);
                                }
                            }

                        }
                    }

                    int attDefIndex = -1;
                    int position = fCurrentGrammar.getFirstAttributeDeclIndex(elementIndex);
                    while (position != -1) {
                        fCurrentGrammar.getAttributeDecl(position, fTempAttDecl);
                        if (fTempAttDecl.name.rawname == attrRawName 
                            || fTempAttDecl.name.rawname.equals(attrRawName)) {
                            // found the match att decl, 
                            attDefIndex = position;
                            declared = true;
                            break;
                        }
                        position = fCurrentGrammar.getNextAttributeDeclIndex(position);
                    }
                    if (attDefIndex == -1) {
                        // REVISIT - cache the elem/attr tuple so that we only give
                        //  this error once for each unique occurrence
                        Object[] args = { element.localpart,
                            attrRawName};

                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                   "MSG_ATTRIBUTE_NOT_DECLARED",
                                                   args,XMLErrorReporter.SEVERITY_ERROR);   
                    } else {

                        // fTempAttDecl should have the right value set now, so the following is not needed
                        // fGrammar.getAttributeDecl(attDefIndex, fTempAttDecl); 

                        String attributeType = attributeTypeName(fTempAttDecl);
                        attributes.setType(i, attributeType);
                    }
                }

                // REVISIT: this is done in XMLScanner, Just that entity ref positions not being moved accordingly
                //normalizeAttrValue(attributes, i);

                if (declared) {
                    String attrValue = attributes.getValue(i);
                    if (fTempAttDecl.simpleType.defaultType == XMLSimpleType.DEFAULT_TYPE_FIXED) {
                        String defaultValue = fTempAttDecl.simpleType.defaultValue;

                        if (!attrValue.equals(defaultValue)) {
                            Object[] args = { 
                                (element.localpart),
                                (attrRawName),
                                (attrValue),
                                (defaultValue)};
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "MSG_FIXED_ATTVALUE_INVALID",
                                                       args, XMLErrorReporter.SEVERITY_ERROR);
                        }
                    }

                    if (fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_ENTITY ||
                        fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_ENUMERATION ||
                        fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_ID ||
                        fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_IDREF ||
                        fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_NMTOKEN ||
                        fTempAttDecl.simpleType.type == XMLSimpleType.TYPE_NOTATION
                       ) {
                        validateDTDattribute(element, attrValue, fTempAttDecl);
                    }
                }
            } // for all attributes
        } // if validation

        return;

    } // addDTDDefaultAttrsAndValidate(int,XMLAttrList,int,boolean,boolean):int

    /**
    * Validate attributes in DTD fashion.
    * @return normalized attribute value
    */
    private String validateDTDattribute(QName element, String attValue, 
                                        XMLAttributeDecl attributeDecl) throws SAXException {
        //AttributeValidator av = null;


        switch (attributeDecl.simpleType.type) {
        
        case XMLSimpleType.TYPE_ENTITY:
            {
                boolean isAlistAttribute = attributeDecl.simpleType.list;//Caveat - Save this information because invalidStandaloneAttDef
                String  unTrimValue      = attValue;
                String  value            = unTrimValue.trim();


                if (fValidation) {
                    if (value != unTrimValue) {
                        if (invalidStandaloneAttDef(element, attributeDecl.name)) {
                            fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                        "MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE",
                                                        new Object[]{ value, attributeDecl.name.rawname, unTrimValue},
                                                        XMLErrorReporter.SEVERITY_ERROR );
                        }
                    }
                }

                try {
                    if (isAlistAttribute) {
                        fValENTITIES.validate( value, null );
                    } else {
                        fValENTITY.validate( value, null );
                    }
                } catch (InvalidDatatypeValueException ex) {
                    String  key = ex.getKeyIntoReporter();

                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                key,
                                                new Object[]{ ex.getMessage()},
                                                XMLErrorReporter.SEVERITY_ERROR );

                }

                /*if (attributeDecl.list) {
                    av = fAttValidatorENTITIES;
                }
                else {
                    av = fAttValidatorENTITY;
                }*/
                /*
                if (fNormalizeAttributeValues) {
                    if (attributeDecl.list) {
                        attValue = normalizeListAttribute(value, attValue, unTrimValue);
                    } else {
                        if (value != unTrimValue) {
                            attValue = value;
                        }
                    }
                }
                */

            }

            break;

        case XMLSimpleType.TYPE_NOTATION:
        case XMLSimpleType.TYPE_ENUMERATION:
            boolean found = false;
            String [] enumVals = attributeDecl.simpleType.enumeration;
            if (enumVals == null) {
                found = false;
            }
            else
                for (int i=0; i<enumVals.length; i++) {
                    if (attValue == enumVals[i] || attValue.equals(enumVals[i])) {
                        found = true;
                        break;
                    }
                }

            if (!found ) {
                StringBuffer enumValueString = new StringBuffer();
                if (enumVals != null)
                    for (int i=0; i<enumVals.length; i++) {
                        enumValueString.append(enumVals[i]+" ");
                    }

                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                           "MSG_ATTRIBUTE_VALUE_NOT_IN_LIST",
                                           new Object[]{attributeDecl.name.rawname, attValue, enumValueString},
                                           XMLErrorReporter.SEVERITY_ERROR);
            }
            break;
        case XMLSimpleType.TYPE_ID:
            {
                String  unTrimValue = attValue;
                String  value       = unTrimValue.trim();
                if (fValidation) {
                    if (value != unTrimValue) {
                        if (invalidStandaloneAttDef(element, attributeDecl.name)) {
                            /*
                            reportRecoverableXMLError(XMLMessages.MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE,
                                                      XMLMessages.VC_STANDALONE_DOCUMENT_DECLARATION,
                                                      fStringPool.toString(attributeDecl.name.rawname), unTrimValue, value);
                                                      */
                        }
                    }
                }
                try {
                    fValID.validate( value, null );
                } catch (InvalidDatatypeValueException ex) {
                    String  key = ex.getKeyIntoReporter();

                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                key,
                                                new Object[]{ ex.getMessage()},
                                                XMLErrorReporter.SEVERITY_ERROR );
                }
                /*
                if (fNormalizeAttributeValues && value != unTrimValue) {
                    attValue = value;
                } */
            }
            break;
        case XMLSimpleType.TYPE_IDREF:
            {
                String  unTrimValue = attValue;
                String  value       = unTrimValue.trim();
                boolean isAlistAttribute = attributeDecl.simpleType.list;//Caveat - Save this information because invalidStandaloneAttDef

                if (fValidation) {
                    if (value != unTrimValue) {
                        if (invalidStandaloneAttDef(element, attributeDecl.name)) {
                            /*
                            reportRecoverableXMLError(XMLMessages.MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE,
                                                      XMLMessages.VC_STANDALONE_DOCUMENT_DECLARATION,
                                                      fStringPool.toString(attributeDecl.name.rawname), unTrimValue, value);
                                                      */
                        }
                    }
                }
                try {
                    if (isAlistAttribute == true) {
                        //System.out.println("values = >>" + value + "<<" );
                        fValIDRefs.validate(value, null );
                    } else {
                        fValIDRef.validate(value, null );
                    }
                } catch (InvalidDatatypeValueException ex) {
                    String  key = ex.getKeyIntoReporter();
                    
                    if( key == null ){
                        key = "IDREFSInvalid";
                    }
                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                                                key,
                                                new Object[]{ ex.getMessage()},
                                                XMLErrorReporter.SEVERITY_ERROR );

                }
                /*
                if (fNormalizeAttributeValues) {
                    if (attributeDecl.list) {
                        attValue = normalizeListAttribute(value, attValue, unTrimValue);
                    } else {
                        if (value != unTrimValue) {
                            attValue = value;
                        }
                    }
                } */
            }
            break;
        case XMLSimpleType.TYPE_NMTOKEN:
            {
                String  unTrimValue = attValue;
                String  value       = unTrimValue.trim();
                boolean isAlistAttribute = attributeDecl.simpleType.list;//Caveat - Save this information because invalidStandaloneAttDef
                //changes fTempAttDef
                if (fValidation) {
                    if (value != unTrimValue) {
                        if (invalidStandaloneAttDef(element, attributeDecl.name)) {
                            /*
                            reportRecoverableXMLError(XMLMessages.MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE,
                                                      XMLMessages.VC_STANDALONE_DOCUMENT_DECLARATION,
                                                      fStringPool.toString(attributeDecl.name.rawname), unTrimValue, value);
                                                      */
                        }
                    }
                }
                try {
                    if (isAlistAttribute == true ) {
                        fValNMTOKENS.validate( value, null );
                    } else {
                        fValNMTOKEN.validate( value, null );
                    }
                } catch (InvalidDatatypeValueException ex) {

                    //System.out.println("ex = " + ex.getMessage() );
                    if( isAlistAttribute == true ){
                        fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                        "NMTOKENSInvalid",
                        new Object[]{ value },
                        XMLErrorReporter.SEVERITY_ERROR );
                    } else{
                        fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN,
                        "NMTOKENInvalid",
                         new Object[]{ value },
                         XMLErrorReporter.SEVERITY_ERROR );
                    }
                }

                /*
                if (fNormalizeAttributeValues) {
                    if (attributeDecl.list) {
                        attValue = normalizeListAttribute(value, attValue, unTrimValue);
                    } else {
                        if (value != unTrimValue) {
                            attValue = value;
                        }
                    }
                } */
            }
            break;
        }
        /*
        if (av != null) {
            int newValue = av.normalize(element, attributeDecl.name, attValue, 
                                        attributeDecl.type, attributeDecl.enumeration);
            if (fNormalizeAttributeValues)
                attValue = newValue;
        }
        */
        return attValue;
    }


    /** Returns true if invalid standalone attribute definition. */
    boolean invalidStandaloneAttDef(QName element, QName attribute) {
        boolean state = true;
        /*
       if (fStandaloneReader == -1) {
          return false;
       }
       // we are normalizing a default att value...  this ok?
       if (element.rawname == -1) {
          return false;
       }
       return getAttDefIsExternal(element, attribute);
       */
        return state;
    }




    StringBuffer fBuffer = new StringBuffer("");
    /** normalize the attribute in the attributes, index is the position */
    private void normalizeAttrValue(XMLAttributes attributes, int index) {
        String attrValue = attributes.getValue(index);
        char[] attValue = new char[attrValue.length()];
        boolean isCDATA = attributes.getType(index) == fCDATASymbol;
        fBuffer.setLength(0);

        attrValue.getChars(0, attrValue.length(), attValue, 0);

        if (isCDATA) {
            for (int i=0; i<attValue.length; i++) {
                if (attValue[i] == '\r' || attValue[i] == '\n' || attValue[i] == ' ') {
                    attValue[i] = ' ';
                }
                fBuffer.append(attValue[i]);
            }
        } else {
            boolean leadingSpace = true;
            boolean spaceStart = false;
            boolean readingNonSpace = false;
            int count = 0;
            int eaten = 0;

            for (int i=0; i<attValue.length; i++) {

                if (attValue[i] == '\r' || attValue[i] == '\n' || attValue[i] == ' ') {
                    attValue[i] = ' ';
                    // now the tricky part

                    if (readingNonSpace) {
                        spaceStart = true;
                        readingNonSpace = false;
                    }

                    if (spaceStart && !leadingSpace) {
                        spaceStart = false;
                        fBuffer.append(attValue[i]);
                        count++;
                    } else {
                        if (leadingSpace || !spaceStart) {
                            eaten ++;
                            int entityCount = attributes.getEntityCount(index);
                            for (int j=0;  j < entityCount; j++) {
                                int offset = attributes.getEntityOffset(index, j);
                                int length = attributes.getEntityLength(index, j);
                                if (offset <= i-eaten+1) {
                                    if (offset+length >= i-eaten+1) {
                                        if (length > 0)
                                            length--;
                                    }
                                } else {
                                    if (offset > 0)
                                        offset--;
                                }
                                attributes.setEntityOffset(index, j, offset);
                                attributes.setEntityLength(index, j, length);
                            }
                        }
                    }

                } else {
                    readingNonSpace = true;
                    spaceStart = false;
                    leadingSpace = false;
                    fBuffer.append(attValue[i]);
                    count++;
                }
            }
            // check if the last appended character is a space.
            if (count > 0 && fBuffer.charAt(count-1) == ' ') {
                fBuffer.setLength(count-1);
                int entityCount = attributes.getEntityCount(index);
                for (int j=0;  j < entityCount; j++) {
                    int offset = attributes.getEntityOffset(index, j);
                    int length = attributes.getEntityLength(index, j);
                    if (offset < count-1) {
                        if (offset+length == count) {
                            length--;
                        }
                    } else {
                        offset--;
                    }
                    attributes.setEntityOffset(index, j, offset);
                    attributes.setEntityLength(index, j, length);
                }
            }

        }
        attributes.setValue(index, fBuffer.toString());
    }

    /** normalize the default attribute value with such a type */
    private String normalizeDefaultAttrValue(String defaultValue, short type) {

        char[] attValue = new char[defaultValue.length()];
        boolean isCDATA = type == XMLSimpleType.TYPE_CDATA;
        fBuffer.setLength(0);

        defaultValue.getChars(0, defaultValue.length(), attValue, 0);

        if (isCDATA) {
            for (int i=0; i<attValue.length; i++) {
                if (attValue[i] == '\r' || attValue[i] == '\n' || attValue[i] == ' ') {
                    attValue[i] = ' ';
                }
                fBuffer.append(attValue[i]);
            }
        } else {
            boolean leadingSpace = true;
            boolean spaceStart = false;
            boolean readingNonSpace = false;
            int count = 0;

            for (int i=0; i<attValue.length; i++) {

                if (attValue[i] == '\r' || attValue[i] == '\n' || attValue[i] == ' ') {
                    attValue[i] = ' ';

                    if (readingNonSpace) {
                        spaceStart = true;
                        readingNonSpace = false;
                    }

                    if (spaceStart && !leadingSpace) {
                        spaceStart = false;
                        fBuffer.append(attValue[i]);
                        count++;
                    } else {
                        // just skip it.
                    }

                } else {
                    readingNonSpace = true;
                    spaceStart = false;
                    leadingSpace = false;
                    fBuffer.append(attValue[i]);
                    count++;
                }
            }
        }
        return fBuffer.toString();
    }


    /** Root element specified. */
    private void rootElementSpecified(QName rootElement) throws SAXException {
        if (fValidation) {
            String root1 = fRootElement.rawname;
            String root2 = rootElement.rawname;
            if (root1 == null || !root1.equals(root2)) {
                fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, 
                                            "RootElementTypeMustMatchDoctypedecl", 
                                            new Object[]{root1, root2}, 
                                            XMLErrorReporter.SEVERITY_ERROR);
            }
        }
    } // rootElementSpecified(QName)


    /**
     * Check that the content of an element is valid.
     * <p>
     * This is the method of primary concern to the validator. This method is called
     * upon the scanner reaching the end tag of an element. At that time, the
     * element's children must be structurally validated, so it calls this method.
     * The index of the element being checked (in the decl pool), is provided as
     * well as an array of element name indexes of the children. The validator must
     * confirm that this element can have these children in this order.
     * <p>
     * This can also be called to do 'what if' testing of content models just to see
     * if they would be valid.
     * <p>
     * Note that the element index is an index into the element decl pool, whereas
     * the children indexes are name indexes, i.e. into the string pool.
     * <p>
     * A value of -1 in the children array indicates a PCDATA node. All other
     * indexes will be positive and represent child elements. The count can be
     * zero, since some elements have the EMPTY content model and that must be
     * confirmed.
     *
     * @param elementIndex The index within the <code>ElementDeclPool</code> of this
     *                     element.
     * @param childCount The number of entries in the <code>children</code> array.
     * @param children The children of this element.  
     *
     * @return The value -1 if fully valid, else the 0 based index of the child
     *         that first failed. If the value returned is equal to the number
     *         of children, then additional content is required to reach a valid
     *         ending state.
     *
     * @exception Exception Thrown on error.
     */
    private int checkContent(int elementIndex, 
                             QName[] children,
                             int childOffset, 
                             int childCount) throws SAXException {

        fCurrentGrammar.getElementDecl(elementIndex, fTempElementDecl);

        // Get the element name index from the element
        final String elementType = fCurrentElement.rawname;

        // Get out the content spec for this element
        final int contentType = fCurrentContentSpecType;


        //
        //  Deal with the possible types of content. We try to optimized here
        //  by dealing specially with content models that don't require the
        //  full DFA treatment.
        //
        if (contentType == XMLElementDecl.TYPE_EMPTY) {
            //
            //  If the child count is greater than zero, then this is
            //  an error right off the bat at index 0.
            //
            if (childCount != 0) {
                return 0;
            }
        } else if (contentType == XMLElementDecl.TYPE_ANY) {
            //
            //  This one is open game so we don't pass any judgement on it
            //  at all. Its assumed to fine since it can hold anything.
            //
        } else if (contentType == XMLElementDecl.TYPE_MIXED ||  
                   contentType == XMLElementDecl.TYPE_CHILDREN) {
            // Get the content model for this element, faulting it in if needed
            ContentModelValidator cmElem = null;
            cmElem = fTempElementDecl.contentModelValidator;
            int result = cmElem.validate(children, childOffset, childCount);
            return result;
        } else if (contentType == -1) {
            //REVISIT
            /****
            reportRecoverableXMLError(XMLMessages.MSG_ELEMENT_NOT_DECLARED,
                                      XMLMessages.VC_ELEMENT_VALID,
                                      elementType);
            /****/
        } else if (contentType == XMLElementDecl.TYPE_SIMPLE) {

            //REVISIT
            // this should never be reached in the case of DTD validation.

        } else {
            //REVISIT
            /****
            fErrorReporter.reportError(fErrorReporter.getLocator(),
                                       ImplementationMessages.XERCES_IMPLEMENTATION_DOMAIN,
                                       ImplementationMessages.VAL_CST,
                                       0,
                                       null,
                                       XMLErrorReporter.ERRORTYPE_FATAL_ERROR);
            /****/
        }

        // We succeeded
        return -1;

    } // checkContent(int,int,QName[]):int


    /** Returns the content spec type for an element index. */
    private int getContentSpecType(int elementIndex) {

        int contentSpecType = -1;
        if (elementIndex > -1) {
            if (fCurrentGrammar.getElementDecl(elementIndex,fTempElementDecl)) {
                contentSpecType = fTempElementDecl.type;
            }
        }
        return contentSpecType;
    }

    /** Character data in content. */
    private void charDataInContent() {

        if (DEBUG_ELEMENT_CHILDREN) {
            System.out.println("charDataInContent()");
        }
        if (fElementChildren.length <= fElementChildrenLength) {
            QName[] newarray = new QName[fElementChildren.length * 2];
            System.arraycopy(fElementChildren, 0, newarray, 0, fElementChildren.length);
            fElementChildren = newarray;
        }
        QName qname = fElementChildren[fElementChildrenLength];
        if (qname == null) {
            for (int i = fElementChildrenLength; i < fElementChildren.length; i++) {
                fElementChildren[i] = new QName();
            }
            qname = fElementChildren[fElementChildrenLength];
        }
        qname.clear();
        fElementChildrenLength++;

    } // charDataInCount()

    /** convert attribute type from ints to strings */
    private String attributeTypeName(XMLAttributeDecl attrDecl) {
        switch (attrDecl.simpleType.type) {
        case XMLSimpleType.TYPE_ENTITY: {
                return attrDecl.simpleType.list ? fENTITIESSymbol : fENTITYSymbol;
            }
        case XMLSimpleType.TYPE_ENUMERATION: {
                StringBuffer buffer = new StringBuffer();
                for (int i=0; i<attrDecl.simpleType.enumeration.length ; i++) {
                    if (i > 0) {
                        buffer.append("|");
                    }
                    buffer.append(attrDecl.simpleType.enumeration[i]);
                }
                return fSymbolTable.addSymbol(buffer.toString());
            }
        case XMLSimpleType.TYPE_ID: {
                return fIDSymbol;
            }
        case XMLSimpleType.TYPE_IDREF: {
                return attrDecl.simpleType.list ? fIDREFSSymbol : fIDREFSymbol;
            }
        case XMLSimpleType.TYPE_NMTOKEN: {
                return attrDecl.simpleType.list ? fNMTOKENSSymbol : fNMTOKENSSymbol;
            }
        case XMLSimpleType.TYPE_NOTATION: {
                return fNOTATIONSymbol;
            }

        }
        return fCDATASymbol;
    }

    /** intialization */
    private void init() {

        //fEmptyURI = fSymbolTable.addSymbol("");
        //fXsiURI = fSymbolTable.addSymbol(SchemaSymbols.URI_XSI);


        fEMPTYSymbol = fSymbolTable.addSymbol("EMPTY");
        fANYSymbol = fSymbolTable.addSymbol("ANY");
        fMIXEDSymbol = fSymbolTable.addSymbol("MIXED");
        fCHILDRENSymbol = fSymbolTable.addSymbol("CHILDREN");

        fCDATASymbol = fSymbolTable.addSymbol("CDATA");
        fIDSymbol = fSymbolTable.addSymbol("ID");
        fIDREFSymbol = fSymbolTable.addSymbol("IDREF");
        fIDREFSSymbol = fSymbolTable.addSymbol("IDREFS");
        fENTITYSymbol = fSymbolTable.addSymbol("ENTITY");
        fENTITIESSymbol = fSymbolTable.addSymbol("ENTITIES");
        fNMTOKENSymbol = fSymbolTable.addSymbol("NMTOKEN");
        fNMTOKENSSymbol = fSymbolTable.addSymbol("NMTOKENS");
        fNOTATIONSymbol = fSymbolTable.addSymbol("NOTATION");
        fENUMERATIONSymbol = fSymbolTable.addSymbol("ENUMERATION");
        fREQUIREDSymbol = fSymbolTable.addSymbol("#REQUIRED");
        fFIXEDSymbol = fSymbolTable.addSymbol("#FIXED");
        fDATATYPESymbol = fSymbolTable.addSymbol("<<datatype>>");

        //Initialize Validators
        //Datatype Registry

        if (fValidation == true) {
            /* uncomment when using Registry with no Singleton
            fDataTypeReg = new DatatypeValidatorFactoryImpl();
            */

            fDataTypeReg = DatatypeValidatorFactoryImpl.getDatatypeRegistry();//To be commented or deleted  when no Singleton
            fDataTypeReg.initializeDTDRegistry();

            fValID       = (IDDatatypeValidator) fDataTypeReg.getDatatypeValidator("ID" );
            fValIDRef    = (IDREFDatatypeValidator) fDataTypeReg.getDatatypeValidator("IDREF" );
            fValIDRefs   = (ListDatatypeValidator) fDataTypeReg.getDatatypeValidator("IDREFS" );
            fValENTITY   = (ENTITYDatatypeValidator) fDataTypeReg.getDatatypeValidator("ENTITY" );
            fValENTITIES = (ListDatatypeValidator) fDataTypeReg.getDatatypeValidator("ENTITIES" );
            fValNMTOKEN  = fDataTypeReg.getDatatypeValidator("NMTOKEN");
            fValNMTOKENS = fDataTypeReg.getDatatypeValidator("NMTOKENS");
            fValNOTATION = (NOTATIONDatatypeValidator) fDataTypeReg.getDatatypeValidator("NOTATION" );


            //Initialize ID, IDREF, IDREFS validators
            if (fTableOfIDs == null) {
                fTableOfIDs = new Hashtable();//Initialize table of IDs
            }
            fTableOfIDs.clear();
            fValID.initialize(fTableOfIDs);
            fValIDRef.initialize(fTableOfIDs);
            fValIDRefs.initialize(fTableOfIDs);

            if (fNotationEnumVals == null) {
                fNotationEnumVals = new Hashtable(); 
            }
            fNotationEnumVals.clear();

            fTableOfIDAttributeNames = new Hashtable();
            fTableOfNOTATIONAttributeNames = new Hashtable();
        }
    }

    /** ensure element stack capacity */
    private void ensureStackCapacity ( int newElementDepth) {
        if (newElementDepth == fElementQNamePartsStack.length) {
            int[] newStack = new int[newElementDepth * 2];

            QName[] newStackOfQueue = new QName[newElementDepth * 2];
            System.arraycopy(this.fElementQNamePartsStack, 0, newStackOfQueue, 0, newElementDepth );
            fElementQNamePartsStack      = newStackOfQueue;

            QName qname = fElementQNamePartsStack[newElementDepth];
            if (qname == null) {
                for (int i = newElementDepth; i < fElementQNamePartsStack.length; i++) {
                    fElementQNamePartsStack[i] = new QName();
                }
            }

            newStack = new int[newElementDepth * 2];
            System.arraycopy(fElementIndexStack, 0, newStack, 0, newElementDepth);
            fElementIndexStack = newStack;

            newStack = new int[newElementDepth * 2];
            System.arraycopy(fContentSpecTypeStack, 0, newStack, 0, newElementDepth);
            fContentSpecTypeStack = newStack;

        }
    } // ensureStackCapacity


} // class XMLValidator

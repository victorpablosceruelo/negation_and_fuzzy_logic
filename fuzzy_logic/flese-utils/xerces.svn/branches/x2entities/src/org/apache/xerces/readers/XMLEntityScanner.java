/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.readers;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.PushbackReader;
import java.io.Reader;

import org.apache.xerces.framework.XMLString;
import org.apache.xerces.utils.QName;
import org.apache.xerces.utils.SymbolTable;
import org.apache.xerces.utils.XMLChar;

import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;

/**
 * @author Stubs generated by DesignDoc on Mon Sep 18 18:23:16 PDT 2000
 * @version $Id: XMLEntityScanner.java 316180 2000-10-01 04:12:32Z andyc $
 */
public class XMLEntityScanner
    implements Locator {

    //
    // Constants
    //

    // debugging

    /** Debugging. */
    private static final boolean DEBUG = false;

    //
    // Data
    //

    /** fEntityHandler */
    protected XMLEntityHandler fEntityHandler;

    /** fInputSource */
    protected InputSource fInputSource;

    /** fLineNumber */
    protected int fLineNumber;

    /** fColumnNumber */
    protected int fColumnNumber;

    /** fBytePosition */
    protected long fBytePosition;

    /** fCharPosition */
    protected long fCharPosition;

    /** Symbol table. */
    protected SymbolTable fSymbolTable;

    // private

    /** Reader. */
    private PushbackReader fReader;

    /** Character buffer. */
    private char[] fBuffer = new char[1024];

    /** Buffer length. */
    private int fLength;

    //
    // Constructors
    //

    /**
     * 
     */
    public XMLEntityScanner() {
    }

    //
    // Public methods
    //

    /**
     * setEntityHandler
     * 
     * @param entityHandler 
     */
    public void setEntityHandler(XMLEntityHandler entityHandler) {
        fEntityHandler = entityHandler;
    } // setEntityHandler(XMLEntityHandler)

    /**
     * getBytePosition
     * 
     * @return 
     */
    public long getBytePosition() {
        return -1;
    } // getBytePosition

    /**
     * getCharPosition
     * 
     * @return 
     */
    public long getCharPosition() {
        return -1;
    } // getCharPosition

    /**
     * peekChar
     * 
     * @return 
     */
    public int peekChar() throws IOException {
        if (DEBUG) System.out.println("#peekChar()");
        return peek(); 
    } // peekChar

    /**
     * scanChar
     * 
     * @return 
     */
    public int scanChar() throws IOException, SAXException {
        if (DEBUG) System.out.println("#scanChar()");
        int c = read();
        if (c == -1) {
            endEntity();
        }
        return c;
    } // scanChar

    /**
     * scanNmtoken
     * 
     * @return 
     */
    public String scanNmtoken() throws IOException, SAXException {
        if (DEBUG) System.out.println("#scanNmtoken()");

        fLength = 0;
        boolean nmtoken = false;
        while (XMLChar.isName(peek())) {
            nmtoken = true;
            fBuffer[fLength++] = (char)read();
        }

        String symbol = null;
        if (nmtoken) {
            symbol = fSymbolTable.addSymbol(fBuffer, 0, fLength);
        }
        return symbol;

    } // scanNmtoken

    /**
     * scanName
     * 
     * @return 
     */
    public String scanName() throws IOException, SAXException {
        if (DEBUG) System.out.println("#scanName()");

        fLength = 0;
        boolean name = false;
        if (XMLChar.isNameStart(peek())) {
            name = true;
            fBuffer[fLength++] = (char)read();
            while (XMLChar.isName(peek())) {
                fBuffer[fLength++] = (char)read();
            }
        }

        String symbol = null;
        if (name) {
            symbol = fSymbolTable.addSymbol(fBuffer, 0, fLength);
        }
        return symbol;

    } // scanName

    /**
     * scanQName
     * 
     * @param qname 
     */
    public boolean scanQName(QName qname) throws IOException, SAXException {
        if (DEBUG) System.out.println("#scanQName()");

        String prefix = null;
        String localpart = null;
        String rawname = null;

        fLength = 0;
        int colons = -1;
        int index = 0;
        if (XMLChar.isNameStart(peek())) {
            colons = 0;
            fBuffer[fLength++] = (char)read();
            int c = -1;
            while (XMLChar.isName(c = peek())) {
                if (c == ':') {
                    colons++;
                    if (colons == 1) {
                        index = fLength + 1;
                        prefix = fSymbolTable.addSymbol(fBuffer, 0, fLength);
                    }
                }
                fBuffer[fLength++] = (char)read();
            }
            localpart = fSymbolTable.addSymbol(fBuffer, index, fLength - index);
            rawname = fSymbolTable.addSymbol(fBuffer, 0, fLength);
        }

        if (colons >= 0 && colons < 2) {
            qname.setValues(prefix, localpart, rawname, null);
            return true;
        }

        return false;

    } // scanQName

    /**
     * scanContent
     * 
     * @param content 
     */
    public int scanContent(XMLString content) 
        throws IOException, SAXException {

        fLength = 0;
        while (peek() != '<' && peek() != '&') {
            fBuffer[fLength++] = (char)read();
            if (fLength == fBuffer.length) {
                break;
            }
        }
        content.setValues(fBuffer, 0, fLength);

        return peek();

    } // scanContent

    /**
     * scanAttContent
     * 
     * @param quote
     * @param content 
     */
    public int scanAttContent(int quote, XMLString content)
        throws IOException, SAXException {

        fLength = 0;
        while (peek() != quote) {
            fBuffer[fLength++] = (char)read();
            if (fLength == fBuffer.length) {
                break;
            }
        }
        content.setValues(fBuffer, 0, fLength);

        return peek();

    } // scanAttContent

    /**
     * scanData
     *
     * @param delimiter
     * @param data
     */
    public boolean scanData(String delimiter, XMLString data)
        throws IOException, SAXException {
        // TODO
        throw new RuntimeException("not implemented");
    } // scanData(String,XMLString)

    /**
     * skipChar
     *
     * @param c
     */
    public boolean skipChar(int c) throws IOException, SAXException {
        int pc = read();
        if (pc != c) {
            unread(pc);
        }
        return pc == c;
    }

    /**
     * skipSpaces
     */
    public boolean skipSpaces() throws IOException, SAXException {
        if (DEBUG) System.out.println("#skipSpaces()");

        boolean spaces = false;
        while (XMLChar.isSpace(peek())) {
            spaces = true;
            read();
        }

        return spaces;

    } // skipSpaces

    /**
     * skipString
     *
     * @param s
     */
    public boolean skipString(String s) throws IOException, SAXException {
        if (DEBUG) System.out.println("#skipString(\""+s+"\")");

        int length = s.length();
        for (int i = 0; i < length; i++) {
            int c = read();
            if (c != s.charAt(i)) {
                unread(c);
                if (i > 0) {
                    char[] ch = new char[i];
                    s.getChars(0, i, ch, 0);
                    unread(ch, 0, ch.length);
                }
                return false;
            }
        }

        return true;

    } // skipString

    //
    // Locator methods
    //

    /**
     * getPublicId
     * 
     * @return 
     */
    public String getPublicId() {
        return null;
    } // getPublicId

    /**
     * getSystemId
     * 
     * @return 
     */
    public String getSystemId() {
        return null;
    } // getSystemId

    /**
     * getLineNumber
     * 
     * @return 
     */
    public int getLineNumber() {
        return -1;
    } // getLineNumber

    /**
     * getColumnNumber
     * 
     * @return 
     */
    public int getColumnNumber() {
        return -1;
    } // getColumnNumber

    //
    // Package methods
    //

    void startEntity(InputSource inputSource) 
        throws IOException, SAXException {
        
        fInputSource = inputSource;
        
        Reader reader = inputSource.getCharacterStream();
        if (reader != null) {
            fReader = new PushbackReader(reader, 32);
            startEntity();
            return;
        }

        InputStream stream = inputSource.getByteStream();
        if (stream != null) {
            reader = new InputStreamReader(stream);
            fReader = new PushbackReader(reader, 32);
            startEntity();
            return;
        }

        String systemId = inputSource.getSystemId();
        if (systemId != null) {
            stream = new FileInputStream(systemId);
            reader = new InputStreamReader(stream);
            fReader = new PushbackReader(reader, 32);
            startEntity();
            return;
        }

        throw new FileNotFoundException(systemId);

    } // startEntity(InputSource)

    /** Starts an entity. */
    void startEntity() throws SAXException {
        if (fEntityHandler != null) {
            fEntityHandler.startEntity("name", "publicId", "systemId");
        }
    }

    /** Ends an entity. */
    void endEntity() throws SAXException {
        if (fEntityHandler != null) {
            fEntityHandler.endEntity("entityName");
        }
    }

    void setSymbolTable(SymbolTable symbolTable) {
        fSymbolTable = symbolTable;
    }

    //
    // Private methods
    //

    /** Peeks the next character. */
    private final int peek() throws IOException {
        int c = fReader.read();
        if (c == -1) {
            throw new EOFException();
        }
        if (DEBUG) System.out.println("?"+(char)c);
        fReader.unread(c);
        return c;
    }

    /** Reads the next character. */
    private int read() throws IOException {
        int c = fReader.read();
        if (c == -1) {
            throw new EOFException();
        }
        if (DEBUG) System.out.println("+"+(char)c);
        return c;
    }

    private void unread(int c) throws IOException {
        if (DEBUG) System.out.println("-"+(char)c);
        fReader.unread(c);
    }

    private void unread(char[] ch, int offset, int length) throws IOException {
        if (DEBUG) System.out.println("-"+new String(ch, offset, length));
        fReader.unread(ch, offset, length);
    }

} // class XMLEntityScanner

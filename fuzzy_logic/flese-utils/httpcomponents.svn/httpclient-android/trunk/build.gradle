repositories {
    mavenCentral()
}

configurations.create('hcApi')

dependencies {
    hcApi 'org.apache.httpcomponents:httpcore:4.0-beta3'
    hcApi 'org.apache.httpcomponents:httpclient:4.0-beta1'
}

String branchName = 'test-branch'
URI branchUri = new URI("${REPO_ROOT}/httpclient-android/branches/${branchName}")
File localDir = file("$buildDir/${branchName}")
File srcRoot = new File(localDir, 'src/main/java')
File allClassesFile = file("$buildDir/all-classes.txt")
File reservedClassesFile = file("$buildDir/reserved-classes.txt")

task createSvnBranch {
    group = 'SVN'
    description = "Creates Android specific branch of HttpClient ${HTTPCLIENT_VERSION}"
    onlyIf {
        !localDir.exists()
    }
    doLast {
        println "Creating Android port branch based on HttpCore ${HTTPCORE_VERSION} and HttpClient ${HTTPCLIENT_VERSION}"
        HC.createAndroidBranch(
                new URI("${REPO_ROOT}"),
                "${HTTPCORE_VERSION}",
                "${HTTPCLIENT_VERSION}",
                branchName)
    }
}

task checkout(dependsOn: createSvnBranch) {
    group = 'SVN'
    description = "Checks out Android specific branch from ${branchUri}"
    onlyIf {
        !localDir.exists()
    }
    doLast {
        Svn.checkout(branchUri, localDir)
    }
}

task update {
    group = 'SVN'
    description = "Updates local checkout from ${branchUri}"
    onlyIf {
        localDir.exists()
    }
    doLast {
        Svn.update(localDir)
    }
}

task commit {
    group = 'SVN'
    description = "Commits local changes to ${branchUri}"
    onlyIf {
        localDir.exists()
    }
    doLast {
        Svn.commit(localDir, "Android specific modifications of HttpClient ${HTTPCLIENT_VERSION}")
        println()
    }
}

task prepare(dependsOn: checkout) {
    group = 'Code'
    description = "Prepares code migration"
    onlyIf {
        !allClassesFile.exists() || !reservedClassesFile.exists()
    }
    doLast {
        Collection<File> jars = configurations.hcApi.resolvedConfiguration.resolvedArtifacts.collect { ResolvedArtifact artifact ->
            artifact.file
        }
        Set<Class<?>> allClasses = HC.getClasses('org.apache.http', jars)
        Set<Class<?>> reservedClasses = HC.getApiClasses(allClasses)
        TreeSet<String> allClassNames = new TreeSet()
        allClasses.each { Class<?> clazz ->
            String classname = clazz.name
            if (!(classname ==~ /^org\.apache\.http\.client\.utils\.(\w*Idn|Punycode)$/)) {
                allClassNames.add(clazz.name)
            }
        }

        TreeSet<String> reservedClassNames = new TreeSet()
        reservedClasses.each { Class<?> clazz ->
            String classname = clazz.name
            if (classname != 'org.apache.http.client.utils.Idn') {
                reservedClassNames.add(classname)
            }
        }
        allClassNames.each { String line ->
            if (line ==~ /^org\.apache\.http\.\w+$/) {
                reservedClassNames.add(line)
            } else if (line ==~ /^org\.apache\.http\.message\.\w+$/) {
                if (!(line ==~ /^org\.apache\.http\.message\.Basic\w+(Parser|Formatter)$/)) {
                    reservedClassNames.add(line)
                }
            } else if (line ==~ /^org\.apache\.http\.conn\.routing\.\w+$/) {
                reservedClassNames.add(line)
            } else if (line ==~ /^org\.apache\.http\.conn\.scheme\.\w+$/) {
                reservedClassNames.add(line)
            } else if (line ==~ /^org\.apache\.http\.cookie\.\w+$/) {
                reservedClassNames.add(line)
            } else if (line ==~ /^org\.apache\.http\.auth\.\w+$/) {
                if (line != 'org.apache.http.auth.AuthState') {
                    reservedClassNames.add(line)
                }
            } else if (line ==~ /^org\.apache\.http\.impl\.conn\.tsccm\.\w+$/) {
                reservedClassNames.add(line)
            } else if (line ==~ /^org\.apache\.http(\.\w+)*Params$/) {
                reservedClassNames.add(line)
            } else if (line ==~ /^org\.apache\.http(\.\w+)*Exception$/) {
                reservedClassNames.add(line)
            }
        }
        reservedClassNames.addAll([
                'org.apache.http.util.ByteArrayBuffer',
                'org.apache.http.util.EncodingUtils',
                'org.apache.http.util.LangUtils',
                'org.apache.http.entity.EntityTemplate',
                'org.apache.http.protocol.HTTP',
                'org.apache.http.protocol.HttpRequestExecutor',
                'org.apache.http.protocol.HttpService',
                'org.apache.http.protocol.RequestExpectContinue',
                'org.apache.http.protocol.ResponseContent',
                'org.apache.http.protocol.ResponseDate',
                'org.apache.http.protocol.ResponseServer',
                'org.apache.http.protocol.UriPatternMatcher',
                'org.apache.http.protocol.HttpDateGenerator',
                'org.apache.http.protocol.UriHttpRequestHandlerMapper',
                'org.apache.http.conn.ssl.SSLSocketFactory',
                'org.apache.http.impl.client.RequestWrapper',
                'org.apache.http.impl.HttpConnectionMetricsImpl',
                'org.apache.http.impl.io.HttpTransportMetricsImpl',
                'org.apache.http.impl.cookie.DateUtils'
        ])

        String lineDelimiter = System.getProperty('line.separator')
        allClassesFile.withWriter { Writer w ->
            allClassNames.each { String s ->
                w << s + lineDelimiter
            }
        }
        reservedClassesFile.withWriter { Writer w ->
            reservedClassNames.each { String s ->
                w << s + lineDelimiter
            }
        }
    }
}

task shade(dependsOn: prepare) {
    group = 'SVN'
    description = "Shades newer implementation classes"
    doLast {
        Set<String> classesToRemove = [
                'org.apache.http.impl.auth.GGSSchemeBase',
                'org.apache.http.impl.auth.SPNegoScheme',
                'org.apache.http.impl.auth.SPNegoSchemeFactory',
                'org.apache.http.impl.auth.KerberosScheme',
                'org.apache.http.impl.auth.KerberosSchemeFactory'
        ]
        reservedClassesFile.eachLine { String line ->
            classesToRemove.add(line)
        }
        List<File> filesToRemove = []
        classesToRemove.each{ String line ->
            String name = line.replaceAll('\\.', '/')
            File file = new File(srcRoot, name + '.java')
            if (file.exists()) {
                filesToRemove.add(file)
            }
        }
        if (!filesToRemove.empty) {
            Svn.scheduleForRemoval(filesToRemove)
        }
        allClassesFile.eachLine { String line ->
            String name = line.replaceAll('\\.', '/')
            File src = new File(srcRoot, name + '.java')
            if (src.exists()) {
                File dst = new File(srcRoot, name + 'HC4.java')
                Svn.move(src, dst)
            }
        }
    }
}

task rewriteImpl(dependsOn: shade) {
    group = 'Code'
    description = "Rewrites implementation classes"
    doLast {
        Set<String> allClasses = []
        allClassesFile.eachLine { String line ->
            allClasses.add(line)
        }
        Set<String> removedClasses = []
        reservedClassesFile.eachLine { String line ->
            removedClasses.add(line)
        }
        Set<String> movedClasses = allClasses - removedClasses

        List<Replacement> replacements = []
        movedClasses.each { String line ->
            int i = line.lastIndexOf('.')
            String className = i != -1 ? line.substring(i + 1) : line
            replacements.add(new Replacement(~/([ \.\(\!\#])(${className})(([ \(\)\<\.;#]|$))/, '$1$2HC4$3'))
        }
        replacements.addAll([
                new Replacement(~/HttpMessageWriter\<.*\>/, 'HttpMessageWriter'),
                new Replacement(~/HttpMessageParser\<.*\>/, 'HttpMessageParser'),
                new Replacement(~/AbstractMessageParser\<.*\>/, 'AbstractMessageParser'),
                new Replacement(~/AbstractMessageWriter\<.*\>/, 'AbstractMessageWriter'),
                new Replacement(~/HttpMessageParser\<Http(Request|Response)\>/, 'HttpMessageParser'),
                new Replacement(~/HttpMessageWriter\<Http(Request|Response)\>/, 'HttpMessageWriter'),
                new Replacement(~/HTTP\.DEF_CONTENT_CHARSET/, 'Charset.forName(HTTP.DEFAULT_CONTENT_CHARSET)'),
                new Replacement(~/HTTP\#DEF_CONTENT_CHARSET/, 'HTTP#DEFAULT_CONTENT_CHARSET'),
                new Replacement(~/route\.getLocalSocketAddress\(\)/, 'route.getLocalAddress() != null ? new InetSocketAddress(route.getLocalAddress(), 0) : null;'),
                new Replacement(~/new AuthScope\((proxy|target|host)([,)])/, 'new AuthScope($1.getHostName(), $1.getPort()$2'),
                new Replacement(~/new Base64\(0\)/, 'new Base64()')
        ])
        srcRoot.traverse(namefilter: ~/.*\.java$/) { File file ->
            if (!file.directory) {
                HC.replacePatterns(file, replacements)
            }
        }
    }
}

task rewriteLogging(dependsOn: rewriteImpl) {
    group = 'Code'
    description = "Rewrites logging"
    doLast {
        List<Replacement> replacements = [
                new Replacement(~/^import org\.apache\.commons\.logging\.LogFactory;/, ''),
                new Replacement(~/^(.*)Log log = LogFactory.getLog\(.*\);/, '$1String tag = getClass().getSimpleName();'),
                new Replacement(~/^import org\.apache\.commons\.logging\.Log;/, 'import android.util.Log;'),
                new Replacement(~/^(.*?)(?:this\.)?log\.debug\((.*)$/, '$1Log.d(tag, $2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.isDebugEnabled\(\)(.*)$/, '$1Log.isLoggable(tag, Log.DEBUG)$2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.info\((.*)$/, '$1Log.i(tag, $2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.isInfoEnabled\(\)(.*)$/, '$1Log.isLoggable(tag, Log.INFO)$2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.warn\((.*)$/, '$1Log.w(tag, $2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.isWarnEnabled\(\)(.*)$/, '$1Log.isLoggable(tag, Log.WARN)$2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.error\((.*)$/, '$1Log.e(tag, $2'),
                new Replacement(~/^(.*?)(?:this\.)?log\.isErrorEnabled\(\)(.*)$/, '$1Log.isLoggable(tag, Log.ERROR)$2')
        ]
        srcRoot.traverse(namefilter: ~/.*\.java$/) { File file ->
            if (!file.directory) {
                HC.replacePatterns(file, replacements)
            }
        }
    }

}

task rewriteBase64(dependsOn: rewriteImpl) {
    group = 'Code'
    description = "Rewrites Base64 coding"
    doLast {
        List<Replacement> replacements = [
                new Replacement(~/^import org\.apache\.commons\.codec\.binary\.Base64;/, 'import android.util.Base64;'),
                new Replacement(~/^(.*?)Base64\.encodeBase64\((.*?)\)(.*)$/, '$1Base64.encode($2, Base64.DEFAULT)$3'),
        ]
        srcRoot.traverse(namefilter: ~/.*\.java$/) { File file ->
            if (!file.directory) {
                HC.replacePatterns(file, replacements)
            }
        }
    }

}

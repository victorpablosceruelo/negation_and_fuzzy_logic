:- module(gauge, [
	profile_reset/1,
	profile_data/4
        ],[dcg,assertions]).

:- use_module(engine(internals)).
:- use_module(library(aggregates)).
:- use_module(library(lists)).
:- use_module(library(streams)).

:- data
	'$g_clause_model'/3,
	'$g_insn_count'/3.

:- multifile do_on_abolish/1.

do_on_abolish(Head) :- retractall_fact('$g_clause_model'(Head,_,_)).
do_on_abolish(Head) :- retractall_fact('$g_insn_count'(Head,_,_)).

/*
:- dynamic
	'$g_clause_model'(Key, InternalName, ClauseModel).

where ClauseModel maps profile points to counters (modelField/3)

:- dynamic
	'$g_insn_count'(Key, InternalName, InsnModel).

where InsnModel is a list of (PointName-insn_cnt(M,N,C))
where M is # insns up to next profile point,
      N is # bytecodes up to next profile point (?),
      C is {none,pred(_),internal_pred(_),
	    builtin_pred(_),builtin_function(_)}
*/

/*

Assumptions on how gauge uses the counters
------------------------------------------

There are two levels of counters:
	1) The physical counters actually stepped by WAM-instructions. Theire
           number and placements differ in different clauses.
        2) The logical counters counting for exampel entries in try-mode,
	   entries into body-goal N and so on.

A set of MODELS generated by the compiler links those two levels, so in
this file only 2) need to be refered.

The counters are inserted in a clause like this:


        counter(try(var))  -- counter(try(indexed))   %Incremented depending on
                                                      %how the caluse was 
                                                      %found: var=non-indexed.
                                                      %Hardcoded in the emulator
<start of code>:
 +--     ifshallow
 |	 profile_point(entry(shallow))
 1       <code in head>
 |	 profile_point(head_sucess(shallow))	%SIC!
 +--
 |       profile_point(body_goal(1,shallow))
 |       <code for body-goal 1>
 |                   .
 2                   .
 |                   .
 |       profile_point(body_goal(n,shallow))
 |       <code for body-goal n>
 +--     else
 |       profile_point(entry(deep))
 3       <code in head>
 |	 profile_point(head_sucess(deep))	%SIC!
 +--
 |       profile_point(body_goal(1,deep))
 |       <code for body-goal 1>
 |                   .
 4                   .
 |                   .
 |       profile_point(body_goal(n,deep))
 |       <code for body-goal n>
 +--     endif
 |       profile_point(entry(body))
 5       <code>
 |       profile_point(body_goal('n+1',body))
 |       <code for body-goal 'n+1'>
 +--

Where 1 = The head, shallow part
      2 = The part of the body before creating a deep choice-point
      3 = The head, deep part
      4 = Analogous to 2
      5 = Body, excluding 2

Note that the profile_points does not correspond to instructions. There are
instructions BUMP_COUNTER that do the real incrementing. They are placed at
other places, but the models tells what or wich counters that implements
any profile_point. BUMP_COUNTER has one parameter namely the counter-number.

Counters number 1 and 2 are always stepped by the emulator. Therefor is the
first BUMP_COUNTER number 3.

There is also an instruction COUNTED_NECK that does a NECK but increments
one of two counters depending on if the NEXK is for a try or for a retry.
This instruction has two parameters: the counternumber for try and for 
retry.

The following logical counters does not correspond to a profile_point but
are implemented by other counters:
	neck(try)         -- COUNTED_NECK
        neck(retry)       -- COUNTED_NECK
        neck(cut)     seem to be present only in generated clauses
        exit(shallow)
        exit(deep)
*/



/* profile_reset(System) :-
   reset all counters for predicates defined in System
*/
profile_reset(System) :-
	system_file(System, File),
	source_file(Pred, File),
	predicate_counters(Pred, _, _, CounterRef, Count),
	'$reset_counters'(CounterRef, Count),
	fail.
profile_reset(_).
	
%%% usage is deterministic
predicate_counters(SubDef/Arity/ClauseNumber, Counters) :-
	get_key(SubDef, Arity, Head),
	predicate_counters(Head, SubDef/Arity, ClauseNumber, CounterRef, Count), !,
	'$counter_values'(CounterRef, Count, Counters).

predicate_counters(Head, Pred, ClauseNumber, CounterRef, Count) :-
	current_fact('$g_clause_model'(Head, Pred/ClauseNumber, _)),
	'$emulated_clause_counters'(Pred, ClauseNumber, CounterRef, Count).

/* profile_data(System, Selection, Resolution, Data) :-
   Selection ::= {calls,backtracks,choice_points,shallow_fails,deep_fails,
                  execution_time},		% approx Sun-3 milliseconds

   switch (Resolution)
   {
   case predicate:
     Data is a list of PredName-Count where
     PredName is Atom/Arity,
     Count is a sum of the corresponding counts per clause;
   case clause:
     Data is a list of ClauseName-Count where
     ClauseName is PredName/J,
     Count includes counts for any disjunctions occurring
     inside that clause.  However, 'calls' and 'backtracks' do not include
     counts for such disjunctions;
   case all:
     Data is a list of InternalName-Count where
     InternalName is either
         ClauseName --- corresponding to a user clause, or
         (ClauseName-I)/Arity/J --- corresponding to a disjunct;
   }
*/
profile_data(System, Selection, Resolution, Data) :-
	findall(P, all_clause_aux(System, P), List),
	profile_data(List, Selection, Data0),
	profile_resolution(Resolution),
	profile_selection(Selection, CountDisjs),
	(   Resolution=all -> Data0=Data
	;   CountDisjs=0 -> 
	    profile_filter(Data0, Data1, []),
	    profile_sums(Data1, Resolution, Data)
	;   profile_sums(Data0, Resolution, Data)
	).

profile_data([], _, []).
profile_data([Ptr|Clauses], Selection, [Clause-Value|Data]) :-
	Ptr1 is Ptr,				% force deref
	'$instance'('$g_clause_model'(_,Clause,Model), true, Ptr1),
	predicate_counters(Clause, Counter),
	profile_value(Selection, data(Clause,Counter,Model), Value),
	profile_data(Clauses, Selection, Data).

profile_resolution(predicate).
profile_resolution(clause).
profile_resolution(all).

profile_selection(calls, 0).
profile_selection(backtracks, 0).
profile_selection(choice_points, 1).
profile_selection(shallow_fails, 1).
profile_selection(deep_fails, 1).
profile_selection(execution_time, 1).

profile_filter([]) --> [].
profile_filter([Item|Items]) -->
	{Item = (_-_)/_/_-_}, !,
	profile_filter(Items).
profile_filter([Item|Items]) --> [Item],
	profile_filter(Items).

profile_sums([], _, []).
profile_sums([Clause-Value0|Clauses], What, [Name-Value|Data]) :-
	profile_name(What, Clause, Name),
	profile_sums(Clauses, What, Data, Name, Value0, Value).

profile_sums([Clause-Value1|Clauses], What, Data, Name, Value0, Value) :-
	profile_name(What, Clause, Name), !,
	Value2 is Value0 + Value1,
	profile_sums(Clauses, What, Data, Name, Value2, Value).
profile_sums(Clauses, What, Data, _, Value, Value) :-
	profile_sums(Clauses, What, Data).

profile_name(predicate, N/A/_, Name) :-
	get_predicate_name(N, A, Name).
profile_name(clause, N/A/I, Name) :-
	get_clause_name(N, A, I, Name).
profile_name(all, Clause, Clause).

get_predicate_name(N/Ar/_-_, _, Name) :- !,
	get_predicate_name(N, Ar, Name).
get_predicate_name(N, Ar, N/Ar).

get_clause_name(N/Ar/I-_, _, _, Name) :- !,
	get_clause_name(N, Ar, I, Name).
get_clause_name(N, Ar, I, N/Ar/I).

profile_value(clause_entries, CounterData, Value) :-
	counter_value(entry(deep), CounterData, DeepEntry),
	counter_value(entry(shallow), CounterData, ShallowEntry),
	Value is DeepEntry + ShallowEntry.
profile_value(calls, CounterData, Value) :-
	counter_value(try(var), CounterData, VarEntries),
	counter_value(try(indexed), CounterData, IndexEntries),
	Value is VarEntries + IndexEntries.
profile_value(choice_points, CounterData, Value) :-
	counter_value(neck(try), CounterData, Value).
profile_value(shallow_fails, CounterData, Value) :-
	counter_value(entry(shallow), CounterData, Entry),
        counter_value(neck(try), CounterData, NeckTry),
        counter_value(neck(retry), CounterData, NeckRetry),
        counter_value(neck(cut), CounterData, NeckCut),
	Value is Entry - NeckTry - NeckRetry - NeckCut.
profile_value(deep_fails, CounterData, Value) :-
	counter_value(entry(deep), CounterData, Entry),
	counter_value(exit(deep), CounterData, Exit),
	Value is Entry - Exit.
profile_value(backtracks, CounterData, Value) :-
	counter_value(try(var), CounterData, VarEntries),
	counter_value(try(indexed), CounterData, IndexEntries),
	counter_value(entry(deep), CounterData, DeepEntry),
	counter_value(entry(shallow), CounterData, ShallowEntry),
	Value is (DeepEntry+ShallowEntry) - (VarEntries+IndexEntries).
profile_value(execution_time, CounterData, Value) :-
	profile_value(choice_points, CounterData, NumChoicePoints),
	profile_value(deep_fails, CounterData, NumDeepFails),
	profile_value(clause_entries, CounterData, NumClauseEntries),
	insn_counts(CounterData, NumInstructions),
	Value is integer((70 * NumChoicePoints + 
			  50 * NumDeepFails + 
			  20 * NumClauseEntries +
			   3 * NumInstructions) / 500).

%%% usage is deterministic
insn_counts(Data, NumInstructions) :-
	Data = data(F/A/No,_,_),
	get_key(F, A, Key),
	current_fact('$g_insn_count'(Key,F/A/No,Interpretation)), !,
	insn_counts(Interpretation, Data, 0, NumInstructions).

insn_counts([], _, N, N).
insn_counts([Type-insn_cnt(Ops,Insns,Continuation)|Interpretation],
	     CounterData, N0, N) :-
        insn_count(Type, CounterData, Value),
	continuation_time(Continuation, ContTime),
	N1 is N0 + Value*(Ops+Insns+ContTime),
        insn_counts(Interpretation, CounterData, N1, N).

insn_count(entry(Type), CounterData, Value) :-
	Type\==body, !,
	counter_value(entry(Type), CounterData, T1),
	counter_value(head_sucess(Type), CounterData, T2), %SIC!
	Value is (T1+T2)>>1.
insn_count(Type, CounterData, Value) :-
	counter_value(Type, CounterData, Value).

continuation_time(none, 0).
continuation_time(pred(_), 1).
continuation_time(internal_pred(_), 1).
continuation_time(builtin_pred(_), 3).
continuation_time(builtin_function(_), 3).

counter_value(Field, data(_,Counter,Models), Value) :-
	get_model(Field, Models, Model),
	counter_eval(Model, Counter, Value).

counter_eval(N/A, _, V) :- !,
	Clause = N/A/_,
	get_key(N/A, Head),
	findall(Ptr,
                current_fact('$g_clause_model'(Head,Clause,_), Ptr),
                List),
	profile_data(List, calls, Data),
	profile_sums(Data, predicate, [_-V]).
counter_eval(N+M, Counter, V) :- !,
	counter_eval(N, Counter, V0),
	counter_eval(M, Counter, V1),
	V is V0 + V1.
counter_eval(0, _, 0) :- !.
counter_eval(N, Counter, V) :-
	arg(N, Counter, V).

all_clause_aux(System, Ptr) :-
	system_file(System, File),
	source_file(Fu, File),
	current_fact('$g_clause_model'(Fu,_,_), Ptr).

system_file([], _) :- !, fail.
system_file(user, user) :- !.
system_file(-File, AbsoluteFile) :- !,
	system_file(File, AbsoluteFile).
system_file([File|_], AbsoluteFile) :-
	system_file(File, AbsoluteFile).
system_file([_|Files], AbsoluteFile) :- !,
	system_file(Files, AbsoluteFile).
system_file(File, AbsoluteFile) :-
	absolute_file_name(File, '_opt', '.pl', '.', AbsoluteFile, _, _).

install_insn_model(F/A/No, InsnModel) :-
	get_key(F, A, Key),
	loaded_clause_name(F/A/No, ClName),
	assertz_fact('$g_insn_count'(Key,ClName,InsnModel)).
	
install_clause_model(F/A/No, Counters) :-
	functor(ModelStruct, m, 15),
	get_key(F, A, Key),
	fill_structure(Counters, ModelStruct),
	loaded_clause_name(F/A/No, ClName),
	assertz_fact('$g_clause_model'(Key,ClName,ModelStruct)).

loaded_clause_name((Super-Sub)/Ar/Cl, (Super1-Sub)/Ar/Cl) :- !,
	loaded_clause_name(Super, Super1).
loaded_clause_name(Name/Ar/0, Name/Ar/No) :-
	'$clause_number'(Name/Ar, No).

fill_structure([], m(_,_,_,_,_,_,_,A,B,C,_,_,Deep,Shallow,Body)) :-
	(var(A) -> A=0; true),
	(var(B) -> B=0; true),
	(var(C) -> C=0; true),
	dlist(Deep, _, []),
	dlist(Shallow, _, []),
	dlist(Body, _, []), !.
fill_structure([Field-(Super0-Sub)/Ar|Cnts], ModelStruct) :- !,
        loaded_clause_name(Super0, Super),
	get_model(Field, ModelStruct, (Super-Sub)/Ar),
	fill_structure(Cnts, ModelStruct).
fill_structure([Field-Cntr|Cnts], ModelStruct) :-
	get_model(Field, ModelStruct, Cntr),
	fill_structure(Cnts, ModelStruct).
	
%%% usage is deterministic
get_model(Field, Models, Model) :-
	modelField(Field, Models, Model), !.

modelField(entry(body),           m(A,_,_,_,_,_,_,_,_,_,_,_,_,_,_), A).
modelField(entry(deep),           m(_,A,_,_,_,_,_,_,_,_,_,_,_,_,_), A).
modelField(entry(shallow),        m(_,_,A,_,_,_,_,_,_,_,_,_,_,_,_), A).
modelField(exit(deep),            m(_,_,_,A,_,_,_,_,_,_,_,_,_,_,_), A).
modelField(exit(shallow),         m(_,_,_,_,A,_,_,_,_,_,_,_,_,_,_), A).
modelField(head_sucess(deep),     m(_,_,_,_,_,A,_,_,_,_,_,_,_,_,_), A).
modelField(head_sucess(shallow),  m(_,_,_,_,_,_,A,_,_,_,_,_,_,_,_), A).
modelField(neck(cut),             m(_,_,_,_,_,_,_,A,_,_,_,_,_,_,_), A).
modelField(neck(retry),           m(_,_,_,_,_,_,_,_,A,_,_,_,_,_,_), A).
modelField(neck(try),             m(_,_,_,_,_,_,_,_,_,A,_,_,_,_,_), A).
modelField(try(indexed),          m(_,_,_,_,_,_,_,_,_,_,A,_,_,_,_), A).
modelField(try(var),              m(_,_,_,_,_,_,_,_,_,_,_,A,_,_,_), A).
modelField(body_goal(N,deep),     m(_,_,_,_,_,_,_,_,_,_,_,_,A,_,_), X) :-
	member(A, N-X).
modelField(body_goal(N,shallow),  m(_,_,_,_,_,_,_,_,_,_,_,_,_,A,_), X) :-
	member(A, N-X).
modelField(body_goal(N,body),     m(_,_,_,_,_,_,_,_,_,_,_,_,_,_,A), X) :-
	member(A, N-X).

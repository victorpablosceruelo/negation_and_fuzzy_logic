#+TITLE: Internal documentation
#+AUTHOR: Jose F. Morales
#+EMAIL:  jfmc@fdi.ucm.es
#+TEXT: This document describes some Ciao/OptimComp internals
#+SETUPFILE: ../org-templates/level-0.org

* CAR executables

  In previous Ciao versions the bootstrap process was performed as
  follows: an initial fully portable statically-compiled compiler in
  bytecode, that is executed using a suitable bytecode emulator.

  However, since Ciao is able to generate C code (specially some
  parts of the bytecode emulator), we consider that the C code must
  also be part of the static executable. But we do not want to
  generate code for only one platform.

  The solution is a bootstrap executable, a .car directory where all
  the .c files, configuration sh scripts and compilation sh scripts
  are stored, in addition to the portable bytecode. That structure
  contains entry points (shell scripts) to configure, compile and run
  the executable.

** TODO explain lazy compilation, good idea? always?
** TODO rename bootstrap by srcexec or something like that?  

* Bootstrap compiler

 The bootstrap compiler is a '.car' executable, packed in the
 bootstrap/comp.tar file each time a promotion is done. Packaging is
 necessary to ease commits in subversion (an automatically generated
 directory inside a working-copy is easily handled by svn, also doing
 the commit of a single file is easier). 

 NOTE: Remember to commit the compiler whenever you do a compiler
 promotion or the repository sources may not be able to compile.
 
 The bootstrap compiler is generated compiling apps/comp, which
 is a simplified version of ciaoc. It cannot load compilation modules
 dynamically (compiler plug-ins), but contains a predefined set of
 static compilation modules required to compile itself (and ciaoc, the
 toplevel, ciaoloader, etc).

** Why the compilation modules in the bootstrap compiler are fixed and cannot be dynamically loaded?

*** TODO explain why dynamic code loading has been disabled:
 Bytecode and emulator changes are impossible unless we maintain a
 copy of the libraries used to compile the first compiler.

** =ciaoloader=

 The old engine emulator has been replaced by a Prolog program called
 ciaoloader. It is a minimum static program required to load dynamic
 programs, so it does the same task than the previous "engine"
 executable.

*** TODO .car to distribute compiled versions? without bootstrap compiler
*** TODO currently it is a .car file
*** TODO missing: generate an archdep exec


* Hacking guide

** Source description
*** Directory structure
    
:    bootstrap/  Bootstrap compiler
:    apps/       Command-line interface to the toplevel, compiler, etc.
:    modules/    Ciao modules
:    testsuite/  Test cases
:    version/    SCM files for lpdoc
 
*** Module structure

:  core/            - core modules 
:       compiler    - Ciao compiler modules
:       engine      - Ciao runtime modules
:       library     - basic modules required for the minimal system
:       toplevel    - the command-line toplevel
:  extra/           - extra modules
:       library
:  contrib/         - contributed modules
:       library
:  development/     - modules in development
:       library

    All the first-level directories are included in the =MODULEPATH=.
    In the source code, modules are specified by its module path.


** TODO Coding style and rules

   Some advices while writing/generating C code:

   - Think that most of the engine code can be generated
     automatically (working on that).

   - Do not use 'inline' functions. You cannot control when the
     compiler does or does not inline a function.

   - Use macros (even big ones) when you need to inline code. A macro
     is much better than duplicated code.

   - Do not use comma at the statement level (e.g. "int a, b;" or
     "foo(), bar();") since that confuses the CPP macro expansion
     (when that code is wrapped inside {} and passed as argument).

   - "goto" is not harmful (low level code must be fast and small,
     sometimes while/for/continue/break is not enough).

   - Use architecture or compiler dependant features or as long as you
     make them optional.

 Rerun benchmarks each time you modify a single line in the engine.
 Some variations are acceptable due to cache misaligments (randomly
 your program goes faster or slower), but no slowdown is acceptable
 unless there is a good reason, which may be:

   - A special (and OPTIONAL) execution mode 
     (improved language semantics, runtime tests, profiling, etc.)

   - A temporal step to obtain a much better speedup (you must know
     what are you doing)

 Of course, memory consumption should not increase.

*** TODO Document configuration scripts

** Testing the compiler and engine

 Always execute "ciaotool tests comp" if you are working in the
 compiler or a module used by the compiler. It will test that the
 compiler compiles itself and show resources usage (time and memory).
 Sometimes the memory usage jumps due to the GC, but in general, it
 is a good representation of how much memory the compiler needs.

 A more exhaustive tests is "ciaotool tests full". 

** Module resolution

*** TODO write what is a mod spec and how modules are located
*** TODO '_opt' support has been removed
    Better implementation: use paths for optimized libraries (maybe
    with special encoding).

*** TODO differences between a module path and an alias path

*** TODO Module identifiers inside the compiler

  Notation: 
    - modspec0 is a (full) module name, as especified in 
        ":- use_module(ModSpec)"
    - modname is a module name, as especified in "M:foo"

  In Ciao =<1.11, the predicate absolute_file_name is used to
  obtain the base, or full path name minus the extension of each module.
  That base is used as the module identifier during the compilation
  process. The modname of a module is the last name of the module
  file name, for normal modules or user(Base) for user modules.
  You cannot load or compile two modules with the same modname at 
  the same time. The predicates of each module are prefixed with the
  modname, or 'user' for user modules.

  In this branch, the process is similar, but there are some differentes.
  The identifier is not the base, but a normalized modspec0, or modspec.
  E.g.
 
:    library(foo) ===> [library,foo]
:    /home/jfran/src/ciao/lib/foo ===> [library,foo]  
:      (if /home/jfran/src/ciao/lib is an alias for library)
:    /home/jfran/foo.pl ===> [__rootfs__,home,jfran,foo]

  That base is, in principle, independent of the underlying
  file-system and the absolute path of the module paths.

  Access to the filesystem is required for filesystem module names
  (/home/...) or special cases. In other cases the modspec can be
  obtained directly (i.e. for using libraries already compiled).

  For user modules, an internal atom is created (used for fast rtexp),
  unique for each modspec.

**** TODO filesystem names should not be used as modspec0, support is given for compatibility

**** TODO Document 'find_package' in 'action__split'

*** TODO Obtaining filenames from module identifiers
 
 In Ciao =< 1.11 .itf .po .pl file names of a module are
 located appending the extension to the module base. 

 In this version that process has been abstracted in the
 module compiler(store). Using the modspec and the desired component
 (source code, some intermediate compilation pass, etc.), the predicate
 addr/2 gives the file name.

*** TODO addr/2: compilation results are not stored in the sources

*** TODO Base-independent compilation output?
    Verify that compilation results can be moved, packaged,
    redistributed without the sources (at least the modules relative
    to the module path).

*** TODO Compiling without the sources
    Extend the 'do not compile library(_) unless -x is specified'
    behaviour.

*** TODO Use an carefully build atom as base instead of a list of atoms?

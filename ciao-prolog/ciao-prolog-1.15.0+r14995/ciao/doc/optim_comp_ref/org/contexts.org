#+TITLE: Contexts in Prolog
#+AUTHOR: Jose F. Morales
#+EMAIL:  jfmc@fdi.ucm.es
#+TEXT: Draft description of contexts -- Jose F. Morales
#+SETUPFILE: ../org-templates/level-0.org

* Introduction

  NOTE: This is a draft document describing contexts and its
  applications. 

* What is a context?

  A context defines an implicit state that ...

** Constant contexts

*** The =single= context

** Mutable contexts

*** The =pair= context

*** The =hipair= context

This example creates a graph and follows its nodes using the
='$ctx_store__*'= family of predicates and =hipair= context
variables. The semantic of those predicates is pure, and equivalent to
replacing, looking up or inserting (Key-Value) pairs in a list.
 
The =hipair= context forbids directly reading or writing the
=Key-Value= table, and thus access predicates can be implemented using
attributed variables.

So, although the program does not contain impure features, the node
traversal is very efficient (and the program is supposed to scale
very well).

** An example (graphs)

#+BEGIN_SRC ciao
:- module(_, [main/0], [compiler(complang)]).

:- '$context_def'(names_acc, pair(names)).
:- '$context_ctor'(names(Xs), closed_accum(names, Xs)).

:- '$context_def'(graph, hipair(graph)).
:- '$context_ctor'(empty_graph, push_hipair(graph)).

:- '$begin_context'(graph).
% creates a node
node(Name, N) :-
	N = ~'$ctx_store__init'(graph, node(Name, no, [])).

% adds a directed arc
arc(From, To) :-
	node(Name, Seen, ToList) = ~'$ctx_store__value'(graph, From),
	'$ctx_store__assign'(graph, From, node(Name, Seen, [To|ToList])).

% obtains in pair(names) the names of all nodes reachable from From
:- '$add_context'(names_acc).
span(From) :-
	node(Name, Seen, ToList) = ~'$ctx_store__value'(graph, From),
	( Seen = no ->
	    '$ctx_store__assign'(graph, From, node(Name, yes, ToList)),
	    '$ctx_accum'(names, [Name]),
	    span_list(ToList)
	; true
	).

span_list([]).
span_list([X|Xs]) :- span(X), span_list(Xs).
:- '$end_context'.
:- '$end_context'.
#+END_SRC

Example that uses the previous definitions:

#+BEGIN_SRC ciao
main :-
	empty_graph '$ctx_on' (
	  node(a, A), node(b, B), node(c, C), node(d, D), node(e, E),
	  arc(A, B), arc(B, A), arc(A, C), arc(C, B), arc(D, A), arc(D, B), arc(C, E),
	  names(Names) '$ctx_on' span(B),
	  display(span_list_from_b_is(Names)), nl
        ).
#+END_SRC

** TODO define properties for operations on 'pair(...)' context var such as 'commutative', 'associative', etc.? or compositional?
   e.g. in the example bellow arc creation can be shuffled

** TODO Relation with intuitionistic logic

   (see motivation section in the next paper)
: @incollection{ tarau94logic,
:     author = "Paul Tarau and Veronica Dahl",
:     title = "Logic Programming and Logic Grammars with First-Order Continuations",
:     booktitle = "Logic Programming Synthesis and Transformation, Meta-Programming in Logic: Fourth International Workshops, {LOBSTR}'94 and {META}'94, Pisa, Italy",
:     publisher = "Springer-Verlag",
:     address = "Berlin",
:     editor = "Laurent Fribourg and Franco Turini",
:     pages = "215--230",
:     year = "1994",
:     url = "citeseer.ist.psu.edu/tarau94logic.html" }

* Predicate abstractions

* Local predicates

  Local predicates are predicates defined in the body of another
  predicate. For example:

#+BEGIN_SRC ciao
foo(A, B) :-
	Inc = ~'$predabs_static$'(none, [X,Y], (Y is X + 1)),
	B = ~'$predabs_static_call$'(none, Inc, [~'$predabs_static_call$'(none, Inc, [A])]).
#+END_SRC

** TODO Be able to rewrite it as:   

: foo(A, B) :-
: 	(inc(X,Y) :- Y = X + 1),
: 	B = ~inc(~inc(A)).

* Loops

  Declarative languages (functional and logic) usually restricts
  themselves to a minimum set of control structures and they do not
  supports explicit loops constructions. Instead, they rely on
  recursion to do that work. 

  Efficient loops are possible in Prolog (and declarative languages?)
  thanks to the last call optimization (or equivalent?).

** Recursion patterns

  Writing recursive predicates for some programs may be too
  verbose. It is practical to write complex control structures in just
  one goal. Some Prologs support the goal =maplist/N=, which abstracts
  a loop on a collection of lists.

  There exist two fundamental recursion patterns: catamorphisms and
  anamorphisms. Functional programming makes use of a rich collection
  of high-order functions implementing several recursion patterns
  (although those can be viewed as two fundamental recursion patterns:
  catamorphism (or fold) and anamorphism (or unfold)). Those allow to
  transform, interate, etc.  expresions based on lists or other data
  types.

** Monadic recursion patterns: state changes

  The monadic version of those recursion patterns increased its
  expressive power. TODO: Complete

  TODO: take Euclid's algorithm from
  http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
  
  Some facts about monads:

  - "The key to engineering a large software project is to make
     changes easy. Monads can be used to make functional programs far
     more adaptable."
  - "Monads make up for many of the drawbacks of Haskell relative to
     imperative languages, but without giving up any of its
     strengths."

*** TODO do monads establish threaded computations (one after another)?
*** TODO do monads allow stopping or continuing computations?
    If so, I need *continuations* here...

** A different approach

   In Haskell, special syntax for monads is provided (=do= notation).
   The contexts extension is currently implemented as a preprocessor
   that translates a program to a context-less one. It is a more
   complicated process, but the programs are easier to write (less
   typing?).

  Loops can be defined in terms of predicate abstractions as follow:
  
  - =Init= :: initialization
  - =Cond= :: condition to continue
  - =Init= :: initialization

#+BEGIN_EXAMPLE
mexpand__loop(Ctx, MaybeEmpty, Init, Cond, Goal, Next) := AR :-
 	% Inside unifies Vi with the value of context var vi, Outside sets the context var vi to Vi (for all vi in context)
 	mexpand__enter_cont_ctx(Ctx, Inside, Outside),
 	%
 	CondR = (Cond -> '$predabs_static_call$'(Ctx, LoopDef, []) ; /*finish loop*/ Inside),
 	LoopR = (Goal, Next, '$predabs_static_call$'(Ctx, CondDef, [])),
 	PD = ('$predabs_static$'(Ctx, [], CondR, CondDef),
 	      '$predabs_static$'(Ctx, [], LoopR, LoopDef)),
 	% todo: this was a todo in ptoc__impcomp: obtain MaybeEmpty automatically from the previous scheme: the first cond is true and inline after next the second cond: use builtins for iterators and properties for iterators! do not expand them during this analysis
 	( MaybeEmpty = yes -> FirstDef = CondDef % start by the condition check
 	; MaybeEmpty = no -> FirstDef = LoopDef % enter the loop, the initial status of condition is always true
 	),
 	%
 	AR = (PD, Init, '$predabs_static_call$'(Ctx, FirstDef, []), Outside).
#+END_EXAMPLE

: testloop6_a :-
: 	display(begin_testloop6), nl,
: 	List = [1,2,3,4,5,6,7,8,9,10],
:         push_pair(sum, 0) '$ctx_on' (
: 	  for_each_list_elem(pair(sum), I, List) '$ctx_on' (
:             '$ctx_inc'(sum, I)
:           ),
: 	  Sum = ~'$ctx_value'(sum)
:         ),
: 	display(sum_of_list(List, Sum)), nl,
: 	maplist(none, List, List2, X, Y) '$ctx_on' (Y is X + 1),
: 	display(list2(List2)), nl,
: 	% todo: it is necessary to use different variables! use predabs? (ala Ruby?)
: 	maplistn(none, [List, List2, List3], [X2, Y2, Z2]) '$ctx_on' (Z2 is Y2 - X2),
: 	display(list3(List3)), nl,
: 	display('end_testloop6 should appear only once here'), nl,
: 	display(end_testloop6), nl.

* Bugs 

** TODO Currently no '$ctx_store__*' predicates can be called with an unbound Id.
   With exception of '$ctx_store__init'/2. It is not possible to
   recover the key list. On the other hand, lost keys are automatically
   recovered on garbage-collection.
 

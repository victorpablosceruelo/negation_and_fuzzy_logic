1) LAMBDA EXPRESSIONS AS ATOMIC TERMS AND HIGHER ORDER PATTERN UNIFICATION.

The basic terms of Lambda Prolog are lambda expressions and that is what it used
here as well, so all "normal" Prolog terms are converted in to lambda
expressions.

Lambda expressions consist of constants, variables, abstraction and application.
A backslash is used for lamba abstraction and the '@' symbol for application.
Additionally, the traditional "functor(....)" notation is considered function
application in the context of a term. So for example (pretending the '\' is a
lambda on the left hand side) 

	\x.x		->		x \ x
	f x			-> 		f @ x or f(x)
	\x\y.f x y	->		x \ y \ f(x,y)

Note that in abstraction, the term being abstracted over can be a Prolog
constant or variable, so both "x \ foo(x, ..)" and "X \ foo(X, ...)" are allowed.


2) PREDICATE VARIABLES.

The functor of a goal can be a variable, which allows for the more traditional
form of "higher order" programming (passing the names of functions or predicates
as parameters etc.).  However, at runtime, the variable functor can be
instantiated to an arbitrary lambda term, so the treatment is a little more
involved.



"examples/ho_map2.pl" and "examples/ho_map3.pl" show existential quantification
being used with predicate variables. Note that the term passed to the "ho_map"
predicate is just a lambda term - the "sigmas" have no special meaning until
interpreted within the body of the predicate.



3) QUANTIFIERS IN GOALS (EXPLICIT QUANTIFICATION).

The syntax is

	pi x \ Goal
	sigma x \ Goal

for universal and existential quantification of "x" in Goal, respectively. Note
that a logic variable can be used as well, so "sigma X \ Goal is also legal.

The syntax is design to reflect the dual roles of quantifiers - that of binding
and predication. However, in this implementation, they actually form one
structure, so all parts are necessary.

"examples/ho_reverse2.pl" shows the use of universal quantification to hide the name of
an auxiliary predicate.

"examples/pnf.pl" uses universal quantification to add extend the signature of a
program.


4) IMPLICATION IN GOALS.
This feature allows for the controlled addition of clauses to the program. The
syntax is

	Clause => Goal

The meaning of this is "add Clause to the program, then try to prove Goal." In
the body of the implication goal, conjunction has a slightly different sense.
To illustrate this, the "&" symbol is used, so the goal

	(Clause1 & Clause2) => Goal

has the meaning "add the Clause1 _and_ Clause2 to the program, then try to
prove Goal."

The "ho_reverse" programs in the example directory illustrate the use of this
feature to define an auxiliary predicate.

The "pnf" program illustrates a common idiom using universal quantification to
add constants to a program and implication goals to add clauses _about_ those
constants.



Juan Chanco
University of Minnesota
chanco@cs.umn.edu

:- module(intmodel, [buildModel/1]).

buildModel(S) :-
% think how to use endModels:
%write(S,':- data exe_code/1, aspState/1.\n'),
write(S,'''$meta_call''(X) :- call(X).\n'),
write(S,':- data aspModel/3, endModels/1.\n\n'),

write(S,':- export(aspModel/3).\n\n'),
%write(S,':- redefining(aspModel/3).\n\n'),

write(S,'model(Q) :- \n'),
write(S,'	retractall_fact(modelFound),\n'),
write(S,'	getCState(State),\n'),
write(S,'	!,model3(State,1,Q).\n'),
write(S,'model(_).\n\n'),

write(S,'model3(State,N,Q) :- \n'),
write(S,'	aspModel(State,N,Q).\n'),
%write(S,'     display(''N=''), display(N),nl,\n'),
%write(S,'       display(''model aready computed''),nl.\n'),
write(S,'model3(State,1,Q) :- \n'),
write(S,'	\\+aspModel(State,1,Q),\n'),
write(S,'	\\+endModels(State),\n'),
%write(S,'     display(''call groundASP''),nl,\n'),
write(S,'	(existgroundASP -> true;groundAsp),\n'),
%write(S,'     display(''call getModel''),nl,\n'),
write(S,'	getModel(State,1,Q), modelFound.\n'),
write(S,'model3(State,No,Q) :- \n'),
write(S,'	No>1, \\+aspModel(State,No,Q),\n'),
write(S,'	\\+endModels(State),\n'),
write(S,'	existgroundASP,\n'),
write(S,'	getModel(State,No,Q), modelFound.\n'),
write(S,'model3(State,No,Q) :- \n'),
write(S,'	No>1, \\+aspModel(State,No,Q),\n'),
%write(S,'     prtEndModels(State), \n'),
write(S,'	\\+endModels(State),\n'),
write(S,'	getCState(State1),\n'),
write(S,'	State1=State,\n'),
write(S,'	\\+existgroundASP,\n'),
write(S,'	groundAsp,\n'),
write(S,'	getModel(State,No,Q), modelFound.\n'),
write(S,'model3(State,No,Q) :-\n'),
write(S,'	aspModel(State,No,_QQ),!,\n'),
write(S,'	No1 is No+1,\n'),
write(S,'	retractall_fact(modelFound),\n'),
write(S,'	model3(State,No1,Q).\n'),

write(S,'getModel(State,No,Q) :-\n'),
%write(S,'    display(''call runSolver''),nl,\n'),
write(S,'     currentAtom(State,_),\n'),
write(S,'	runSolver(No,OSM,1),\n'),
write(S,'	repeat,\n'),
%write(S,'      display(''getSolverData''),nl,\n'),
write(S,'	getSolverData(OSM,State,No,Q),!, close(OSM),\n'),
write(S,'	(modelFound-> true;asserta_fact(endModels(State))),\n'),

write(S,'	self(ModuleName),\n'),
write(S,'	atoms_concat([ModuleName,'':'',resetStateChanged], G),\n'),
write(S,'	''$meta_call''(G).\n'),

write(S,'getSolverData(OSM,State,No,Q) :-\n'),
write(S,'	retractall_fact(modelFound),\n'),
write(S,'	repeat,\n'),
write(S,'       get_line(OSM,L1),\n'),
%write(S,'       write_string(L1), nl,\n'),
write(S,'	store_data(L1,State,No,Q), !.\n'),

write(S,':- data modelFound/0.\n\n'),
write(S,'store_data("end.",_,_,_) :- !.\n'),
write(S,'store_data(end_of_file,_,_,_) :- !.\n'),
write(S,'store_data(L1,_,No,_) :- \n'),
write(S,'	append("Answer: ", L2, L1),\n'),
write(S,'	read_from_string_atmvars(L2,No),\n'),
write(S,'	assertz_fact(modelFound),!,fail.\n'),
write(S,'store_data(L1,State,No,Q) :- \n'),
write(S,'	modelFound, \n'),
%write(S,'       write_string(L1), nl,\n'),
write(S,'	append("Stable Model: ", L2, L1), \n'),
%write(S,'       write_string(L2), nl,\n'),
write(S,'	self(AspInterface),\n'),
write(S,'	Q new justclass(AspInterface,No),\n'),   % check class name
write(S,'	stateAtom(State,A),\n'),
write(S,'       parse1(L2,Q,A),\n'),
%write(S,'	save_curr_class(Q),\n'),
write(S,'	assertz_fact(aspModel(State,No,Q)),\n'),
write(S,'	Q:data_add(atomClass(A)),\n'),
write(S,'	A:incRef,\n'),
write(S,'	Q:getTrueAtoms(TAtoms),\n'),
%write(S,'       display(TAtoms), nl,\n'),
write(S,'	getFalseAtoms(Q,A,TAtoms),\n'),
write(S,'	(tmpST(ST)->(Q:data_add(symboltableClass(ST)),ST:incRef);\n'),
write(S,'	 true),!.\n'),
write(S,'store_date(_,_,_,_):-!,fail.\n\n'),

write(S,'parse1([],_,_):-!.\n'),
write(S,'parse1(L,Q,A) :- \n'),
write(S,'	pos(" ",L,L3,L4),\n'),
write(S,'	read_from_string_atmvars(L3,Atom),\n'),
%write(S,'       display(''adding: just: ''), display(Atom), \n'),
write(S,'	A:atom(ANo,Atom),\n'),
%write(S,'       tab(2), display(ANo), nl,\n'),
write(S,'	Q:data_add(just(ANo,1)),\n'),
write(S,'	parse1(L4,Q,A),!.\n'),

write(S,'getFalseAtoms(Q,A,TA) :-\n'),
write(S,'	A:atom(N,Atom),\n'),
write(S,'	\\+member(Atom,TA),\n'),
write(S,'	Q:data_add(just(N,0)), fail.\n'),
write(S,'getFalseAtoms(_,_,_).\n\n'),




write(S,'emptyJustClass(State,_,Q) :-\n'),
%write(S,'     display(''class is empty: destroy Q=''), display(Q), nl,\n'),
write(S,'	pushEndModels(State),\n'),
write(S,'	destroy(Q),!,fail.\n\n'),

write(S,'aspModelExist(State) :- aspModel(State,_,_),!.\n\n'),

%write(S,'save_curr_class(Q) :- remCurrClass, \n'),
%write(S,'    assertz_fact(curr_data(Q)),!.\n\n'),

%write(S,'remCurrClass :- retractall_fact(curr_data(_)).\n\n'),

write(S,'setEndModels(State) :- retractall_fact(endModels(State)),!,\n'),
write(S,'	pushEndModels(State).\n'),
write(S,'setEndModels(State) :- pushEndModels(State).\n\n'),

write(S,'pushEndModels(State) :- asserta_fact(endModels(State)).\n'),
write(S,'popEndModels(State) :- State>0,\n'),
write(S,'	retractall_fact(endModels(State)),!.\n'),
write(S,'popEndModels(_).\n\n'),

write(S,'prtEndModels(State) :- endModels(State),!,\n'),
write(S,'	display(''endModels state=''),display(State),nl.\n'),
write(S,'prtEndModels(_) :- display(''no endModels exists''),nl.\n\n'),

write(S,':- export(wfm/1).\n'),
write(S,':- data wfmState/2.\n\n'),

write(S,'wfm(Q) :- \n'),
write(S,'	getCState(State),\n'),
write(S,'	(wfmState(State,Q) -> true; wfm2(Q,State)).\n\n'),

write(S,'wfm2(Q,St) :- \n'),
write(S,'	(existgroundASP->wfm3(Q,St);(groundAsp,wfm3(Q,St))).\n'),

write(S,'wfm3(Q,State) :- \n'),
write(S,'	runSolver(0,OSM,4),\n'),
write(S,'	repeat,\n'),
write(S,'	getWellFound(OSM,State,Q),!, close(OSM),\n'),
write(S,'	self(ModuleName),\n'),
write(S,'	atoms_concat([ModuleName,'':'',resetStateChanged], G),\n'),
write(S,'	''$meta_call''(G),!.\n\n'),

write(S,'getWellFound(OSM,State,Q) :-\n'),
write(S,'	currentAtom(State,A),\n'),
write(S,'	repeat,\n'),
write(S,'	get_line(OSM,String),\n'),
%write(S,'       write_string(String), nl,\n'),
write(S,'	positive_part(OSM,String,A,Q),!,\n'),
write(S,'	Q:data_add(atomClass(A)),\n'),
write(S,'	assertz_fact(wfmState(State,Q)),!.\n\n'),

write(S,'positive_part(OSM,String,A,Q) :-\n'),
write(S,'	append("Positive part: ", L, String),\n'),
write(S,'	self(AspInterface),\n'),
write(S,'	Q new wellfound(AspInterface),\n'),   % check class name
write(S,'	parse1(L,Q,A),\n'),
write(S,'	negative_part(OSM,A,Q),!.\n'),

write(S,'negative_part(OSM,A,Q) :- \n'),
write(S,'	get_line(OSM,String1),\n'),
%write(S,'       write_string(String1), nl,\n'),
write(S,'	append("Negative part: ", L1, String1),\n'),
write(S,'	parse1(L1,Q,A),!.\n\n'),
write(S,'negative_part(_,_,_).\n').

:- module(intskep, [buildSkep/1]).

buildSkep(S) :-
	write(S,':- data stateSkep/2, ans/2.\n\n'),

	write(S,':- export(getSkep/2).\n'),
	write(S,':- export(getAllSkepTrue/1).\n\n'),

	write(S,'getAllSkepTrue(L) :-\n'),
	write(S,'	var(L),\n'),
	write(S,'	retractall_fact(ans(_,_)),\n'),
	write(S,'	getCState(State),\n'),
	write(S,'	(stateSkep(State,Sk) -> true;\n'),
	write(S,'	skep(State,Sk)),\n'),
	write(S,'	Sk:getAllSkepTrue(L),\n'),
	write(S,'	retractall_fact(ans(_,_)).\n\n'),

	write(S,'getSkep(Atom,V) :-\n'),
	write(S,'	retractall_fact(ans(_,_)),\n'),
	write(S,'	getCState(State),\n'),
	write(S,'	(stateSkep(State,Sk)-> true;\n'),
	write(S,'	skep(State,Sk)),\n'),
	write(S,'	 Sk:getSkep(Atom,V),\n'),
	write(S,'	retractall_fact(ans(_,_)).\n\n'),

	write(S,'skep(State,Sk) :-\n'),
	write(S,'	computeSkep(State,Sk),\n'),
	write(S,'	Sk:saveState(State).\n\n'),

	write(S,'computeSkep(_,_) :- \n'),
	write(S,'	retractall_fact(ans(_,_)),\n'),
%	write(S,'    display(''intSkep: model:''),nl,\n'),
	write(S,'	self(ModuleName),\n'),
	write(S,'	module_concat(ModuleName,model(Q),G),\n'),
	write(S,'	''$meta_call''(G),\n'),
	write(S,'	Q:getTrueAtoms(TAtoms),\n'),
	write(S,'	Q:getFalseAtoms(FAtoms),\n'),
%	write(S,'   display(TAtoms),nl,\n'),
%	write(S,'    display(FAtoms),nl,\n'),
	write(S,'	saveSkep(TAtoms,FAtoms),\n'),
	write(S,'	fail.\n'),
	write(S,'computeSkep(State,Sk) :- \n'),
	write(S,'	ans(TAtoms,FAtoms),\n'),
	write(S,'	Sk new skepclass,\n'),
	write(S,'	stateAtom(State,A),\n'),
	write(S,'	assertz_fact(stateSkep(State,Sk)),\n'),
	write(S,'	Sk:addClasses(A),\n'),
%	write(S,'       display(Sk),nl,\n'),
	write(S,'	(tmpST(ST)->(Sk:data_add(symboltableClass(ST)),\n'),
	write(S,'	ST:incRef);true),\n'),
%	write(S,'  display(''computeSkep:Sk=''),display(Sk),nl,\n'),
%	write(S,'  display(''computeSkep:TAtoms=''),display(TAtoms),nl,\n'),
	write(S,'	Sk:addSkep(TAtoms,1),\n'),
	write(S,'	Sk:addSkep(FAtoms,0).\n'),
%	write(S,'	findSkepJust(Sk).\n\n'),

	write(S,'saveSkep(NewTAtoms,NewFAtoms) :-\n'),
	write(S,'	ans(TAtoms,FAtoms),!,\n'),
%	write(S,'   display(''call intersection''), nl, \n'),
	write(S,'	intersection(TAtoms,NewTAtoms,TIntersect),\n'),
%	write(S,'   display(''call intersection''), nl, \n'),
	write(S,'	intersection(FAtoms,NewFAtoms,FIntersect),\n'),
%	write(S,'   display(''call intersection''), nl, \n'),
	write(S,'	retractall_fact(ans(_,_)),\n'),
%	write(S,'   display(''call retractall_fact ans''), nl, \n'),
	write(S,'	assertz_fact(ans(TIntersect,FIntersect)),!.\n'),
	write(S,'saveSkep(NewTAtoms,NewFAtoms) :-\n'),
%	write(S,'   display(''call assert ans''), nl, \n'),
	write(S,'	assertz_fact(ans(NewTAtoms,NewFAtoms)).\n\n').

%	write(S,':- data tmpj/3.\n\n'),

%	write(S,'findSkepJust(SK) :-\n'),
%	write(S,'	findall(Q,model(Q),L),\n'),
%	write(S,'	SK:just(A,_,_),\n'),
%	write(S,'	retractall_fact(tmpj(_,_,_)),\n'),
%	write(S,'	forEachAtom(SK,A,L),fail.\n'),
%	write(S,'findSkepJust(_).\n\n'),

%	write(S,'forEachAtom(Sk,A,[]):-\n'),
%	write(S,'	tmpj(A,_,R), Sk:replaceReason(A,R).\n'),
%	write(S,'forEachAtom(Sk,A,[Q|T]):-\n'),
%	write(S,'	Q:just(A,V,R),\n'),
%	write(S,'	!,comJust(Sk,A,V,R),\n'),
%	write(S,'	forEachAtom(Sk,A,T).\n\n'),

%	write(S,'comJust(_,A,V,R) :-\n'),
%	write(S,'	tmpj(A,V,R1),\n'),
%	write(S,'	R=R1,!.\n'),
%	write(S,'comJust(Sk,A,V,_R) :-\n'),
%	write(S,'	tmpj(A,V,_),\n'),
%	write(S,'	Sk:replaceReason(A,[true_inall_models]), !, fail.\n'),
%	write(S,'comJust(_,A,V,R) :-\n'),
%	write(S,'	assertz_fact(tmpj(A,V,R)).\n\n').

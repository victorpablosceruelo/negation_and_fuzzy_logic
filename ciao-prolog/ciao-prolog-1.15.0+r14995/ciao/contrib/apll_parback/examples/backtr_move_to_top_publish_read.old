:- module(backtr_move_to_top_publish_read, [main/0,main/2], []).

:- use_module(library(system)).
:- use_module(library(apll_parback)).
:- use_module(library(odd)).


main :-
	main(_,_).

main(X,Y) :-
	set_prolog_flag(gc, off),

	'$metachoice'(M1), display(mc1(M1)), nl,

	publish(p(X,_,_), Hp),

	'$metachoice'(M2), display(mc2(M2)), nl,

	publish(q(Y,_), Hq),

	'$metachoice'(M3), display(mc3(M3)), nl,

	read(Hq),

	'$metachoice'(M4), display(mc4(M4)), nl,

	read(Hp),

	'$metachoice'(M5), display(mc5(M5)), nl.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% &>/2 and <&/1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

publish(Goal,Handler) :-
	push_goal(Goal,nondet,Handler),
	save_control_execution_init(Handler),
	release_some_suspended_thread,
	pause(1),
	continue_publish(Handler),
	save_control_execution_end(Handler).
publish(_,_) :- fail.

continue_publish(_).
continue_publish(Handler) :-
	my_call(Handler).
% 	enter_mutex_self.
% continue_publish(_) :- fail.


read(Handler) :-
	save_goal_execution_init(Handler),
	save_goal_execution_end(Handler),
	enter_mutex_self,
	(
	    goal_not_executed(Handler) ->
	    exit_mutex(Handler),
	    move_control_execution_to_top(Handler),
	    fail
	;
	    exit_mutex(Handler)
	).
read(_) :- fail.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code for backtracking
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

my_call(Handler) :-
	retrieve_goal(Handler,Goal),
	call(Goal), display(Goal), nl,

	enter_mutex(Handler),
	set_goal_finished(Handler),
	exit_mutex(Handler).
my_call(Handler) :-
	enter_mutex(Handler),
	set_goal_failed(Handler),
	exit_mutex(Handler),
	fail.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Facts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

p(a,a,a).
p(b,a,a).
p(c,a,a).
p(d,a,a).

q(1,1).
q(2,1).
q(3,1).
q(4,1).


How to construct the neccesary modules from the normal interpreter
-----------------------------------------------------------------
- Modules to modify: jvm_i.pl, pe_guides.pl, pe_i.pl

1) jvm_i
--------
- Paste 
:- include(library('jvm_in_ciao/instrumented_interpreter/pe_guides')).

- Update execute predicate with
:- pred execute(+P,+Sin,-Sout,+ASin,-ASout) # "Main loop of the abstract
	interpreter. Given a Java bytecode program @var{P}, the initial concrete
        state @var{Sin} and the initial abstract state @var{ASin} it computes 
        the concrete state @var{Sout} and the abstract state @var{ASout} after 
        executing the program".
execute(Program,S1,S3,AS1,AS3):-
	fetch_instruction(S1,Inst),
	step(Inst,_,Program,S1,S2),
	abstract_step(Inst,AS1,AS2),
	execute(Program,S2,S3,AS2,AS3).
execute(P,S1,Sf,AS1,ASf) :-
	S1 = st(H,fr(M,PC,S,L),SF),
	S2 = st(Hb,fr(M,PCb,Sb,L),SF),
	instructionAt(M,PC,invoke_issd(Mid)),
	invoke_issd_evalpart(P,M,Mid,PC,PCb,S,Sb,H,Hb,MN,InArgs,OutArgsHb),
	abstract_step(invoke_issd(Mid),AS1,AS2),
	ResCall =..[MN,[InArgs,H],OutArgsHb,ASout],
	res_invoke(ResCall),
	AS3 is AS2 + ASout, %res
	execute(P,S2,Sf,AS3,ASf).
execute(_Program,S1,Sf,AS1,ASf):-
	S1=st(_H,fr(M,PC,_S,_L),[]),
	instructionAt(M,PC,return),
	abstract_step(return,AS1,ASf),
	state_cleanup(S1,Sf).
execute(_Program,S1,Sf,AS1,ASf):-
	S1=st(_H,fr(M,PC,[num(int(_I))|_S],_L),[]),
	instructionAt(M,PC,ireturn),
	abstract_step(ireturn,AS1,ASf),
	state_cleanup(S1,Sf).
execute(_Program,S1,Sf,AS1,ASf):-
	S1=st(_H,fr(M,PC,[ref(loc(_I))|_S],_L),[]),
	instructionAt(M,PC,areturn),
	abstract_step(areturn,AS1,ASf),
	state_cleanup(S1,Sf).
execute(Program,S1,Sf,AS1,ASf):-
 	S1=stE(H,frE(M,PC,Loc,_),[]),
 	method_body(M,BM),
 	bytecodeMethod_exceptionHandlers(BM,ExL),
 	not_lookup_handlers(Program,ExL,H,PC,Loc,_),
	abstract_step(aborting_end,AS1,ASf),
	state_cleanup(S1,Sf).

- Remove/comment step(invoke_issd(_)...) as it is included explicitly
  as a particular case in execute predicate.

-----------------------------------------
2) pe_guides.pl
----------------
- Update execute declarations with 
:- trust comp execute/5: const * pt_state * const * dyn * const + pe_type.


3) pe_i.pl
----------
- Update the corresponding include's with 'instrumented_interpreter'
instead of 'interpreter'.
- Copy this:
:- include(library('jvm_in_ciao/instrumented_interpreter/traces_domain')).

- Call to 'alpha_initial_state' before calling execute in main.
- Replace the following:
:- trust comp prepare_states_etc/9 + (eval,sideff(free),bind_ins).
prepare_states_etc(InParams,Results,P,InitialSt,FinalSt,Trace,TraceWanted,SMN,AS0) :-
	options(GlobalOpts),
	current_mis(MIS,MethodOpts),
	(member(trace,GlobalOpts) -> append(MethodOpts,[trace],Options)
	                           ; Options = MethodOpts),
	MIS=mis(MSig,Arg,InitialHeap),
	MSig = methodSignature(methodName(_,shortMethodName(SMN)),_,_),
	heap_operations:reset_counter, % Set the heap counter to 0
	heap_operations:infer_counter(Arg), % Takes into account the initial heap
	trace_wanted(Options,TraceWanted),heapin_wanted(Options,HeapInWanted),
	process_options(Options,FinalSt,Trace,Results),
	build_inparams(HeapInWanted,Arg,InitialHeap,InParams),
	source_program(P),
	initial_state_mis(MIS,P,InitialSt),
	alpha_initial_state(AS0).

- Modify the main interface accordingly.



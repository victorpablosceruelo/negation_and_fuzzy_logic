:- module(compile_packages, [
		add_compile_package/2,
		del_compile_package/2,
		cleanup_compile_package_db/0,
		compile_package_db/2], [assertions, define_flag]).

:- doc(author, "Edison Mera").

:- doc(module, "Compilation packages").

:- doc(summary, "This module provides preliminary support for the
	application to a given module or modules of selected packages
	at compile-time without the need for declaring it the source
	code.  This can be useful for tools that perform program
	transformations that do not change the semantics of modules
	but add certain functionality. Examples are dynamic monitors
	(such as the profiler), run-time assertion checkers,
	optimization packages that perform unfolding or
	specialization, etc.").

:- doc(bug, "Note that the current .itf file mechanism cannot
	control the dependencies generated by introducing compile
	packages, in other words, compile packages are not compatible
	yet with incremental compilation. --EMM").

:- data compile_package_db/2.

:- pred add_compile_package(Modules, Packages) ::
	nlist(atm) * nlist(sourcename)
# "For the nested list of modules @var{Modules}, set the nested list
   of packages @var{Packages} for compilation.".

add_compile_package(Module, Package) :-
	var(Module),
	!,
	add_compile_package_m(Package, Module).
add_compile_package([],               _) :- !.
add_compile_package([Module|Modules], Package) :-
	!,
	add_compile_package(Module,  Package),
	add_compile_package(Modules, Package).
add_compile_package(Module, Package) :-
	add_compile_package_m(Package, Module).

add_compile_package_m([],                 _) :- !.
add_compile_package_m([Package|Packages], Module) :-
	!,
	add_compile_package_m(Package,  Module),
	add_compile_package_m(Packages, Module).
add_compile_package_m(P, Module) :-
	add_compile_package_mp(Module, P).

add_compile_package_mp(Module, Package) :-
	compile_package_db(Module, Package),
	!.
add_compile_package_mp(Module, Package) :-
	assertz_fact(compile_package_db(Module, Package)).

:- pred del_compile_package(Modules, Packages) ::
	nlist(atm) * nlist(sourcename)
# "For the nested list of modules @var{Modules}, delete the nested
   list of packages @var{Packages} for compilation.".

del_compile_package(Module, Package) :-
	var(Module),
	!,
	del_compile_package_m(Package, Module).
del_compile_package([],               _) :- !.
del_compile_package([Module|Modules], Package) :-
	!,
	del_compile_package(Module,  Package),
	del_compile_package(Modules, Package).
del_compile_package(Module, Package) :-
	del_compile_package_m(Package, Module).

del_compile_package_m(Package, Module) :-
	var(Package),
	!,
	del_compile_package_mp(Module, Package).
del_compile_package_m([],                 _) :- !.
del_compile_package_m([Package|Packages], Module) :-
	!,
	del_compile_package_m(Package,  Module),
	del_compile_package_m(Packages, Module).
del_compile_package_m(Package, Module) :-
	del_compile_package_mp(Module, Package).

del_compile_package_mp(Module, Package) :-
	retractall_fact(compile_package_db(Module, Package)).

cleanup_compile_package_db :-
	retractall_fact(compile_package_db(_, _)).

:- pred compile_package_db(Module, Package) :: atm * term
# "Gives the @var{Module} where @var{Package} is applied for compilation.".

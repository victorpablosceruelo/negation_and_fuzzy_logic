% ---------------------------------------------------------------------------
% Debugger toplevel interface

consult([]) :- !.
consult([File|Files]) :- !,
        consult(File),
        consult(Files).
consult(File) :-
        set_debug_mode(File),
        ensure_loaded__2(File).

compile([]) :- !.
compile([File|Files]) :- !,
        compile(File),
        compile(Files).
compile(File) :-
        set_nodebug_mode(File),
        ensure_loaded__2(File).

debug_module(M):-
        set_debug_module(M),
        debugger:debug_module(M),
        ( mode_of_module(M, Mode), Mode \== raw ->
            message(['{Consider reloading module ',M,'}'])
        ; true
        ),
	display_debugged.

nodebug_module(M):-
        set_nodebug_module(M),
        debugger:nodebug_module(M),
	display_debugged.

debug_module_source(M):-
        set_debug_module_source(M),
        debugger:debug_module_source(M),
        ( mode_of_module(M, Mode), Mode \== srcdbg ->
            message(['{Consider reloading module ',M,'}'])
        ; true
        ),
	display_debugged.

:- multifile '$mod_srcdbg'/1. % generated by $insert_debug_info declaration
mode_of_module(M, Mode) :-
	current_module(M), !,
	Mode = ( '$mod_srcdbg'(M) ? srcdbg | raw ).

display_debugged :-
        current_debugged(Ms),
 	current_source_debugged(Ss),
	difference(Ms,Ss,M),
        ( M = [] ->
            format(user, '{No module is selected for debugging}~n',[])
        ; format(user, '{Modules selected for debugging: ~w}~n',[M])
        ),
        ( Ss = [] ->
	    format(user, '{No module is selected for source debugging}~n',[])
	; format(user, '{Modules selected for source debugging: ~w}~n',[Ss])
	).

:- use_module(engine(rt_exp), [current_module/1, '$user_module_id'/1]).

:- use_module(compiler(store), [spec_to_key/2]).

% Module options
% TODO: currently only used for debugging
% TODO: create an equivalent predicate in comp (or ciaoc) to pass options
:- include(compiler(options__interface)).
module__options(Spec, Module, Opts) :-
	'$user_module_id'(Module),
	!,
	module__options(Spec, user, Opts).
module__options(Spec, _, Opts) :-
	spec_to_key(Spec, Key),
	interpret_speckey(Key),
	!,
	debug_opts(debug_raw, Opts).
module__options(_, Module, Opts) :-
	interpret_module(Module, Mode),
	!,
	( Mode = srcdbg ->
	    debug_opts(debug_srcdbg, Opts)
	; debug_opts(debug_raw, Opts)
	).

debug_opts(M, [(:- use_package(library(debugger(M))))]).

:- pred interpret_module(Module, Mode). % where Mode is srcdbg or raw
:- data interpret_module/2.
:- pred interpret_speckey(SpecKey). % (mode is always raw)
:- data interpret_speckey/1.

current_source_debugged(Ss) :- 
	findall(S, current_fact(interpret_module(S, srcdbg)), Ss).

% Set or unset debug options

:- export(set_debug_mode/1).
set_debug_mode(Spec) :-
	spec_to_key(Spec, Key),
	retractall_fact(interpret_speckey(Key)),
	assertz_fact(interpret_speckey(Key)).

:- export(set_nodebug_mode/1).
set_nodebug_mode(Spec) :-
	spec_to_key(Spec, Key),
	retractall_fact(interpret_speckey(Key)).

:- export(set_debug_module/1).
set_debug_module(Mod) :-
	retractall_fact(interpret_module(Mod, _)),
	assertz_fact(interpret_module(Mod, raw)).

:- export(set_debug_module_source/1).
set_debug_module_source(Mod) :-
	retractall_fact(interpret_module(Mod, _)),
	assertz_fact(interpret_module(Mod, srcdbg)).

:- export(set_nodebug_module/1).
set_nodebug_module(Mod) :-
	retractall_fact(interpret_module(Mod, _)).

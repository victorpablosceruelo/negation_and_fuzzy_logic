
If a Prolog type has no equivalence with any C type, a 'ciao_term' type
is used. This represents an abstract data type for terms and can be
inspected or created from C using the operations declared in "ciao_prolog.h".

Term construction
-----------------

The basic functions for creating Prolog terms from C are:

    ciao_term ciao_var();

	   Creates a fresh variable

    ciao_term ciao_structure_a(char *name, int arity, ciao_term *args);

	   Creates a structure with name 'name', arity 'arity' and
       args as arguments. The 'args' array is used for providing the
       arguments, but it is not needed after the term creation. An atom
       is represented as a 0-arity structure. In the same way, a list
       constructor is viewed as a '.'/2 structure.
	 
    ciao_term ciao_integer(int i);

	   Creates a term from an integer

    ciao_term ciao_float(double i);

	   Creates a term from a floating point number.

These functions are sufficient for creating any term. Anyway, 
a set of helper functions is provided for matter of efficiency
and/or a more compact notation. 

    ciao_term ciao_structure(char *name, int arity, ...);

           Like ciao_structure_a, but defined as a function with
	a variable number of arguments. 

    ciao_term ciao_list(ciao_term head, ciao_term tail);
           
	   Creates a list. It is equivalent to 
	ciao_structure(".", 2, head, tail) 	   

    ciao_term ciao_atom(char *name);
	      
	   Creates an atom. It is equivalent to 
        ciao_structure(name, 0);

    ciao_term ciao_empty_list();

	   Creates an empty list. It is equivalent to
	ciao_atom("[]")

    ciao_term ciao_listn_a(int len, ciao_term *args);

	   Creates a list with 'len' elements so that the nth element
        is args[n].

    ciao_term ciao_listn(int length, ...); 

           Like ciao_listn_a but with defined as a function with a
        variable number of arguments.
	   	   
    ciao_term ciao_dlist_a(int len, ciao_term *args, ciao_term base);

           Like ciao_listn_a but creates a difference list. The tail
        of the list will be 'base' instead of the empty list atom.

    ciao_term ciao_dlist(int length, ...); 

	   ciao_dlist_a with a variable number of
	arguments.

    ciao_term ciao_copy_term(ciao_term src_term);

	   Copies a term (as copy_term/2).

Term navigation
---------------

These functions can be used for inspecting the value of a 'ciao_term' variable:

    ciao_bool ciao_is_integer(ciao_term term);

	   Returns true if 'term' is an integer.

    int ciao_to_integer(ciao_term term); 

           Converts the term to an integer value (ciao_is_integer(term) must be true).

    ciao_bool ciao_is_number(ciao_term term);

           Returns true if 'term' is an integer or a floating point number.

    double ciao_to_float(ciao_term term);

	   Converts the term to a float value (ciao_is_number(term) must be true).

    ciao_bool ciao_is_atom(ciao_term atom);

           Returns true if 'term' is an atom. 
    
    char *ciao_atom_name(ciao_term atom);

	   Obtains the name of the atom.

    char *ciao_atom_name_dup(ciao_term atom);

	   Obtains a copy of the name of the atom (can be modified and
        should be free'd after being used).

    ciao_bool ciao_is_list(ciao_term term);

           Returns true if 'term' is a list.

    ciao_term ciao_list_head(ciao_term term);

	   Extracts the head of the list. Requires the term to be a list.

    ciao_term ciao_list_tail(ciao_term term);

	   Extracts the tail of the list. Requires the term to be a list.

    ciao_bool ciao_is_empty_list(ciao_term term);

	   Is true if the the term is equal to the empty list atom.
    
    ciao_bool ciao_is_structure(ciao_term term);

	   Returns true if the term is an structure (including atoms and
	lists).

    char *ciao_structure_name(ciao_term term);
    
	   Extracts the name of the term if the term is an structure. 

    int ciao_structure_arity(ciao_term term);

	   Extracts the arity of the term if the term is an structure. 

    ciao_term ciao_structure_arg(ciao_term term, int n);

	   Extracts the nth argument of the term if the term is an structure. 
	It behaves like arg/3, so the first argument has index 1.

Queries
-------

It is also possible to make arbitraty calls to Prolog predicates from C.
There are two basic ways of make a consult. The easiest way is to 
use the 'ciao_commit_call' function, but it only lets to obtain the
first solution. If more than one solution is needed, it is necessary
to use the 'ciao_query' operations. 

A consult begins with a 'ciao_query_begin' which returns the
'ciao_query' object. Whenever a new solution is needed the
'ciao_query_next' function can be called. The query ends by
calling 'ciao_query_end' and all pending solutions are pruned.

On the other hand, if only a solution is needed or the predicate
is know to only generate a solution, it is better to call
'ciao_commit_call' directly.

    ciao_query *ciao_query_begin(char *name, int arity, ...);

            Call the predicate with the given name, arity and
         arguments (ala ciao_structure) and generates a
	 ciao_query object.
    
    ciao_query *ciao_query_begin_term(ciao_term goal);

	    Like ciao_query_begin but uses 'goal' instead.

    ciao_bool ciao_query_ok(ciao_query *query);

	    Returns if the query has pending solutions.

    void ciao_query_next(ciao_query *query);

	    Discards current solution.

    void ciao_query_end(ciao_query *query);

	    Ends the query.

    ciao_bool ciao_commit_call(char *name, int arity, ...);
 
            Makes a call to a predicate and returns true or false
        depending on the success of the query.
	
    ciao_bool ciao_commit_call_term(ciao_term goal);

	    Like ciao_commit_call but uses 'goal' as goal.


In addition to these functions there are some helper functions for
calling usual predicates:
	    
    ciao_bool ciao_unify(ciao_term x, ciao_term y); 

	    Equivalent to ciao_commit_call("=", 2, x, y);

    ciao_bool ciao_equal(ciao_term x, ciao_term y); 

	    Equivalent to ciao_commit_call("==", 2, x, y);


Exception handling
------------------

The following functions offers a way of throwing exceptions from C that can be
caught in Prolog with catch/3. 

    void ciao_raise_exception(ciao_term exception);

	    Raises an exception. The execution of the current function
        is interruted at this point.







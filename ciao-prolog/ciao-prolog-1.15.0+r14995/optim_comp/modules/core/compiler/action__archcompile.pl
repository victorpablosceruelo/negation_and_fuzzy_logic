:- module(action__archcompile, [], [compiler(complang)]).

:- use_module(compiler(errlog)).
:- use_module(compiler(module_bin)).
:- use_module(compiler(module_archbin)).
:- use_module(compiler(memoize)).
:- use_module(compiler(store)).

:- use_module(engine(system_info)).
:- use_module(library(terms), [atom_concat/2]).
:- use_module(library(system), [system/2]).
:- use_module(library(aggregates), [findall/3]).

% ===========================================================================

:- doc(section, "Register action in 'memoize' (for incremental compilation)").

:- include(.(memoize__callback)).

action__input(archcompile(Spec), [compile(Spec)]).
action__do(archcompile(Spec), Ret) :-
	archcompile(Spec, Ret).

:- include(compiler(store__callback)).

% compiled arch code of a module
filetype__ext(archcompile, '.abin').
filetype__kind(archcompile, nonportable_object).
%
filetype__ext(s_object, '.s').
filetype__kind(s_object, nonportable_object).
%
filetype__ext(c_object, '.o').
filetype__kind(c_object, nonportable_object). % TODO: used?

% object for the autogenerated C code 
filetype__ext(archcompile__o, '.native.o').
filetype__kind(archcompile__o, nonportable_object).
% object for the autogenerated assembler code 
filetype__ext(archcompile__s, '.native.s').
filetype__kind(archcompile__s, nonportable_object).
% shared-object for the autogenerated C code 
filetype__ext(archcompile__so, '.native.so').
filetype__kind(archcompile__so, nonportable_object).

% ===========================================================================

{
:- fluid memo :: memoize.

archcompile(Spec, Ret) :-
	% Get compiled module
	Bin = ~module_bin.from_spec(Spec),

	Archbin = ~module_archbin.new,

	% Compiled module has a bytecode part
	( Bin.contains_bytecode,
	  Archbin.add(contains_bytecode),
	  fail
	; true
	),
	% Compiled module has a native part
	( Bin.contains_native ->
	  ( archcompile__2(Bin, Spec) ->
	      % Mark that we have native code
	      Archbin.add(contains_native),
	      Ok = yes
	  ; Ok = no
	  )
	; Ok = yes
	),
	
	'$inst_destroy'(Bin),

	% Set archbin
	( Ok = yes ->
	    Ret = [archcompile(Spec)=Archbin]
	; % compilation failed
	  '$inst_destroy'(Archbin)
	),
	Ok = yes.

% Generate the .so file from the .c native file
archcompile__2(Bin, Spec) :-
	% Get all C elements
        archcompile__c_elements(Bin, Spec, CElements),
	% Compile them
	archcompile__ccs(CElements, ONames),
	% Stop here if errors were found
        Errs = ~memo.errs,
	\+ Errs.get1_module_error, 
	% Link them
	store:addr_new(archcompile__so(Spec), SOName),
%	errlog:trace(['before extraldopts']),
	extra_ld_opts(Bin, ExtraLDOpts),
%	errlog:trace(['after ', ExtraLDOpts]),
        cc_link(ExtraLDOpts, ONames, SOName).
}.

% TODO: missing some options
extra_ld_opts(Bin, ExtraLDOpts) :-
	trust(Bin instance_of module_bin),
	findall(Lib,
		Bin.native_library_use(Lib),
		Libs),
	findall(LibPath,
		Bin.native_library_path(LibPath),
		LibPaths),
        ExtraLDOpts = ~atom_concat([~concat_with_prefix_and_sep(Libs, '-l', ' '), ' ',
                                    ~concat_with_prefix_and_sep(LibPaths, '-L', ' ')]).

archcompile__c_elements(Bin, Spec, CElements) :-
	trust(Bin instance_of module_bin),
	findall(c_source(S),
		Bin.native_include_c_source(S),
		CElements0),
	CElements = [compile__c(Spec)|CElements0].

{
:- fluid memo :: memoize.

% TODO: do not use Type name... try to use memoize to call gcc...
archcompile__ccs([], _).
archcompile__ccs([CElement|CElements], ONames) :-
	functor(CElement, Type, 1),
	arg(1, CElement, Spec),
	store:addr(CElement, CName),
	% get object file name
	c_object_type(Type, OType), % TODO: work with actiongoals... 
	functor(OElement, OType, 1),
	arg(1, OElement, Spec),
	store:addr_new(OElement, OName),
	% 
	s_object_type(Type, SType), % TODO: work with actiongoals... 
	functor(SElement, SType, 1),
	arg(1, SElement, Spec),
	store:addr_new(SElement, SName),
	% get source file name
        ( cc_compile(CName, SName, OName) ->
	    ONames = [OName|ONames0]
	; Errs = ~memo.errs,
	  Errs.compiler_error(cc_failed(CElement)),
	  ONames = ONames0
	),
	archcompile__ccs(CElements, ONames0).
}.

% element type for different types of C source elements
% (needed to avoid name clashes, i.e. including a .c file with the
% same name than the module)
c_object_type(compile__c, archcompile__o).
c_object_type(c_source, c_object).

% obtain the symbolic assembler object type for the given element type
s_object_type(compile__c, archcompile__s).
s_object_type(c_source, s_object).

% ---------------------------------------------------------------------------
% Compile C files and generate shared libraries

cc_compile(CName, SName, OName) :-
	h_path(HPath),
	get_so_cc(CC),
	get_so_cc_opts(CCOpts),
% TODO: make it optional (like with the CIAOGENASM option! (see compile_native.sh))
%	CCCmdS = ~atom_concat([CC, ' -c ', CCOpts, ' ', HPath, ' ', CName, ' -o ', OName]),
	CCCmdS = ~atom_concat([CC, ' -S ', CCOpts, ' ', HPath, ' ', CName, ' -o ', SName]),
	CCCmdO = ~atom_concat([CC, ' -c ', CCOpts, ' ', HPath, ' ', CName, ' -o ', OName]),
%	errlog:trace([CCCmdO]), % TODO: add optional verbose message
	system(CCCmdS, 0),
	system(CCCmdO, 0).

cc_link(ExtraLDOpts, ONames, SOName) :-
	get_so_ld(LD),
	get_so_ld_opts(LDOpts),
	get_so_libs(SOLibs),
	LDCmd = ~atom_concat([LD, ' ', LDOpts, ' -o ', SOName, ' ',
	                      ~concat_with_sep(ONames, ' '), ' ',
			      SOLibs, ' ', ExtraLDOpts]),
%	errlog:trace([LDCmd]), % TODO: add optional verbose message
	system(LDCmd, 0).

% example: ~concat_with_sep([a,b,c],' ') = 'a b c'
concat_with_sep(Xs, Sep) := ~atom_concat(~concat_with_sep__2(Xs, Sep)).

concat_with_sep__2([], _Sep, R) :- !, R = [].
concat_with_sep__2([X], _Sep, R) :- !, R = [X].
concat_with_sep__2([X|Xs], Sep, [X, Sep|Ys]) :-
	concat_with_sep__2(Xs, Sep, Ys).

% example: ~concat_with_prefix_and_sep([a,b,c],'-L',' ') = '-La -Lb -Lc'
concat_with_prefix_and_sep(Xs, Prefix, Sep) := ~atom_concat(~concat_with_prefix_and_sep__2(Xs, Prefix, Sep)).

concat_with_prefix_and_sep__2([], _Prefix, _Sep, R) :- !, R = [].
concat_with_prefix_and_sep__2([L], Prefix, _Sep, R) :- !, R = [Prefix, L].
concat_with_prefix_and_sep__2([L|Ls], Prefix, Sep, [Prefix, L, Sep|Rest]) :-
        concat_with_prefix_and_sep__2(Ls, Prefix, Sep, Rest).

% Obtain the path for .h files (includes the used configuration and the src dirs)
h_path(X) :-
	store:element_custom_dir(used_configuration, Cfg),
	store:element_custom_dir(nativeh, NativeH), % TODO: change name? 
	findall(S, store:element_custom_dir(src, S), Ss),
	h_path__2([NativeH,Cfg|Ss], X).
	
h_path__2(Ss, X) :-
	h_path__3(Ss, Ts0),
	atom_concat(Ts0, X).

h_path__3([], []).
h_path__3([S|Ss], [' -I', S|Ts]) :-
	h_path__3(Ss, Ts).

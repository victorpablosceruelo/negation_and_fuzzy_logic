#+BEGIN_OPTIONS
#+TODO: TODO STARTED FUTURE PROPOSAL POSTPONED | DONE CANCELED
#+END_OPTIONS

ISO: Syntax, number_chars/2. index, timeline, files, Prince-project
Ciao 1.15.0-14831: Mon Jul 30 15:48:51 CEST 2012
* ISO (before Cor. 2)
** DONE 22: wrong error type
   CLOSED: [2012-09-06 Thu 17:45]

    ?- catch(X is 1 // 0, error(E,_), true).
     
    E = evaluation_error(zero_divisor,0) ? ;

    Expected: E = evaluation_error(zero_divisor). 
    
** STARTED 24: no built_in					      :JM:RH:

#+begin_example
    ?- predicate_property(P,built_in).

    no
#+end_example

    Expected: All ISO built-ins. 

    =built_in= means "The predicate implements a ISO built-in (and it
    cannot be redefined or obscured by a user definition -- when the
    'no_iso_redefine' flag is enabled)"

*** STARTED Add missing ISO annotations					 :RH:
**** TODO call/2..8
**** TODO callable/1
**** DONE subsumes_term/2
     CLOSED: [2012-09-11 Tue 10:21]
**** DONE acyclic_term/1
     CLOSED: [2012-09-11 Tue 10:22]
**** DONE term_variables/2
     CLOSED: [2012-09-11 Tue 10:22]
*** TODO Option 3 (even better)						 :JM:
    Collect 'iso' annotations and emit:
#+begin_example
'$is_iso'(F, A, M).
or:
'$pred_annot'(F, A, M, iso).
#+end_example
    (or even at low-level in the future)

*** PROPOSAL Add a special 'no_iso_redefine' flag? 			 :JM:
    User should not redefine ISO predicates.

    Reuse the 'forbid_def' table. In the ISO package, we forbid all iso_builtins.

*** PROPOSAL Collect automatically the iso predicates		      :RH:JM:
    Idea: collect all predicates from all libraries that have the iso
    property. Use than to generate the ISO module (collection of reexports).
*** CANCELED Option 1   
    Equivalent to: the predicate is imported from a new 'iso_builtins'
    module (problem: some predicates imported from several places?),
    or marked as a ISO predicate? (see what is easier).

*** CANCELED Option 2 (if the previous one has problems?)
    Collect 'iso' annotations (e.g., during compilation of libraries, etc.) and
    write a metainfo predicate in a file?
#+begin_example
is_iso(arg/3).
...
#+end_example

** TODO 16: make (**)/2 throw exceptions for nan and inf	      :RH:JM:
   Depending on the operation: check before or after, probably add new
   macros if necessary? (checking during deref is cheap)

    ?- catch(X is-1**1.5,error(E,_),true).
     
    X = 0.Nan ? ;

    Expected: E = evaluation_error(undefined) 

JH: python does it, ocaml not
*** add test in /, **, tan, atan, etc.

** TODO 20: arg/3 (throw exception) 				      :RH:JM:

    ?- arg(0,f(a1,a2),A).

    no
    ?- arg(-1,f(a1,a2),A).

    no

    Expected: domain_error(not_less_than_zero,0).

    History:

        CD1:1992 demanded in 8.5.2.3 e: N is negative, 0, or larger than the arity of Term - Range error.
        CD2:1993 had no corresponding error condition.
        DIS1:1994 had the final domain error. 

** TODO 19: arg/3 (throw exception)				      :RH:JM:

    ?- arg(I,f(a1,a2),A).

    no

    Expected: instantiation_error. 

** TODO 8: f missing error (throw exceptions in functor/3) 	      :RH:JM:
   Verify that each of them does not break Ciao code (or fix it
   otherwise, if it makes sense)

   Note: order matters:
*** TODO a) var(Term), var(Name)
*** TODO b) var(Term), var(Arity)
*** TODO c) var(Term), \+ var(Name), \+ atomic(Name)
    That is, when Name has arguments, throw an exception
*** TODO d) var(Term), \+ var(Arity), \+ integer(Arity)
    That is, when Arity is not an integer.
*** TODO e) var(Term), atomic(Name), \+ atom(Name), integer(Arity), Arity > 0
    That is, when F(a1, ...) where F is a number (integer or float)
*** TODO f) var(Term), integer(Arity), Arity > MAX_ARITY
#+begin_example
    ?- functor(F,f,400).
    no

#+end_example
    Expected: representation error 
*** TODO g) var(Term), integer(Arity), Arity < 0
*** DONE Verify that Remy's code is fully ISO 				 :RH:
    CLOSED: [2012-09-11 Tue 10:40]
*** TODO Check that Remy's code is not slower			      :JM:RH:
*** TODO Have a look at uses of arg/3 throughout the Ciao code		 :JM:
*** TODO Verify what other Prolog do here				 :RH:
** TODO 18: double_quotes ignored					 :JM:

   There are three modes:
     - codes 
     - chars
     - atom
   Using this flag for native string (ciao specific) can be investigate.

#+begin_example
   ulrich@gupu2:~/iso-prolog$ ciao
   Ciao 1.13.0-12829: Fri Nov 19 18:55:53 CET 2010
   ?- set_prolog_flag(double_quotes,chars).

   yes
   ?- L="a".

   L = [97] ? 
#+end_example

    Expected: L = [a].

    Also:

#+begin_example
    ?- set_prolog_flag(double_quotes, codes).

    no
#+end_example

    Expected: Success. 
** TODO 14: number_chars/2						 :RH:

Look first if the second argument is instantiated. 
If 'yes' convert it and unify with the first argument
If 'no' convert from it to 'chars'

    ?- number_chars(0,['0','0']).
     
    no

    Expected: Success. 
** FUTURE Expose the Ciao version of SWI's must_be from the runtime errors implementation
   :PROPERTIES:
   :CUSTOM_ID: must_be
   :END:
   
** TODO 12: atom_chars/2: list check missing (Prolog version)		 :RH:
   The implementation is much simpler with [[#must_be]]
   
   Note that the implementation is also buggy (it lefts a choicepoint
   and produces a first solution).
#+begin_example
    ?- atom_chars(X, [a|_]).
     
    X = a ? ;
    {ERROR: atomic_basic:atom_codes/2, arg 2 - instantiation_error}

    no
#+end_example
** TODO 5: Uncaught overflow					      :RM:JM:

#+begin_example
    ?- catch(length(Xs,100000000),Pat,true).
    {ERROR: Memory allocation failed [in Realloc()]}
    { Execution aborted }
#+end_example

    Expected resource error. Pat = error(...). 

   1) What stacks? (all?)
   2) Heap -> on catch, some memory probably recovered
      If other stack, or not enough memory, what should be
      done if another memory error happens? (panic?)

** TODO 4: Incorrect result						 :JM:
   (incorrectly asssumes that the 2nd arg fits machine word size int)

#+begin_example
    ?- X is 1<<(1<<32).
     
    X = 1 ?
#+end_example

** TODO reader problems							 :JM:
   (parenthesis, priorities, etc. see Ulrich's summary table)
*** POSTPONED 3: Incorrect write syntax (reader problems)

     We say: no parenthesis because it can be read in Ciao (prefix ops
     can be read as atoms)

     assuming dynamic is a prefix operator:

     ?- X = static-(dynamic).
      
     X = static-dynamic ?

     Expected: brackets as in the query above. Sometimes, the brackets are written already:

     ?- X = 1* (+).
      
     X = 1*(+) ?
*** POSTPONED 9: missing strict syntax mode (reader problems)

Investigate the problem.

    ?- X = * .
     
    X = * ? 

    Expected: Within an appropriate mode, a syntax error should be
    signaled.  This is due to 13211-1 5.1 e. With the exception of
    Siemens IF/Prolog, all other systems do not offer such a mode
    which means that Prolog code is brittle, since systems differ
    slightly in the way they do extensions. The standard does not
    specify the exact way how this mode is enabled. It could be one
    flag for everything, but it could be also a separate flag for each
    feature. E.g. iso_operators would be a nice flag name.

** POSTPONED 17: number_chars/2 (hard to do)
   
reader or writer is incorrect.

    ?- length(Xs,I),X is cos(0.9 ** I), number_chars(X,Chrs), number_chars(Y,Chrs), X \== Y.

    Chrs = ['0','.','9','2','5','8','8','6','6','8','1','8','5','4','7','6','6','1'],
    I = 9,
    X = 0.9258866818547661,
    Xs = [_,_,_,_,_,_,_,_,_],
    Y = 0.925886681854766 ? 


* STARTED 27: Cor. 2 not implemented
   Here are the most visible open issues: 
** DONE uninstantiation_error,	
   CLOSED: [2012-09-08 Sat 09:52]
** DONE subsumes_term/2, 
   CLOSED: [2012-09-06 Thu 17:41]
** DONE acyclic_term/1, 
   CLOSED: [2012-09-09 Sun 15:41]
   put in ISO package
** DONE term_variables/2, 
   CLOSED: [2012-09-07 Fri 22:22]
** TODO op/3 errors,						      :JM:RH:
*** TODO (Hard) Read the ISO Part 1 Cor 2 (8.14.3)			 :RH:
*** POSTPONED (Easy) Add this new operator in [[ciao-src:ciao/lib/operators.pl]] (also in optim_comp, etc.): :JM:
#+begin_example
:- op(400, yfx, div).
#+end_example
** TODO callable/1,						      :JM:RH:
*** callable/1 -> clb/2 (a CiaoPP type)
     Define callable/1 (the Prolog type) (think if it makes sense that
     indexing understands it as a guard -- like integer/1, var/1,
     atom/1, etc.)
#+begin_example
callable(X) :- atom(X), !.
callable(X) :- compound(X).
#+end_example
** TODO (ours) constant/1 is not ISO, but it looks like the CiaoPP version of atomic/1
   Names are strange here (they should be related)
*** put it (at least) in ISO package, probably everywhere
** DONE Implement a low-level version of acyclic_term/1 :RH:
   CLOSED: [2012-09-12 Wed 15:34]
   :PROPERTIES:
   :CUSTOM_ID: c_cyclic_term
   :END:
   
   See how other Prolog implement it.
** TODO call/2..8,							 :JM:
** TODO 23: Some as previous						 :JM:

#+begin_example
?- use_module(engine(hiord_rt)).
Note: module hiord_rt already in executable, just made visible

yes
?- call(=(X),Y).

Y = X ? ;

no
?- call(functor(f(X),F),A).

no
#+end_example

** TODO max/2, min/2, (^)/2, asin/1, acos/1, atan2/2, tan/1, pi/0, xor/2. :JM:
** TODO (was 6): catch memory limit in is/2 evaluation

#+begin_example
    ?- X=1+X,Y is X.
    Segmentation fault
#+end_example   

   Expected: memory error (exception).

   For the original bug, see [[#cyclic_rtcheck_is]].

* Not ISO
** DONE 21: No timeline access
   CLOSED: [2012-09-07 Fri 01:15]
    http://www.ciaohome.org/trac/timeline now gives:

        Error: Forbidden

        TIMELINE_VIEW privileges are required to perform this operation 

** TODO 26: bug in Debian package of Ciao			      :JM:RH:

    ulrich@gupu2:~$ ciao
    WARNING: cannot create /usr/lib/ciao/ciao-1.15/lib/dcg/dcg_phrase_rt.itf
    Ciao 1.15.0-14763: Thu Jun 28 14:39:04 CEST 2012
** DONE 25: incorrect toplevel						 :RH:
   CLOSED: [2012-09-10 Tue 18:00]
   In [[ciao-src:ciao/library/toplevel/toplevel.pl]]:
    - pass dictionary to pretty_vars/1
    - add free_name_var/3 (which uses the dict to see if the variable was already there)

#+begin_example
    ?- X = f(_,_), Y = X, _A = _.
     
    X = f(_A,_B),
    Y = f(_A,_B) ?
#+end_example

**** Take into account variable dictionary when creating new variables names


** TODO Provide an updated changelog 
** TODO 10: documentation of hiord?

verify the documentation.

    (Installed via Ubuntu/Debian)


    ulrich@gupu2:~$ ciao-1.13 
    Ciao 1.13.0-11568: Thu Dec 31 18:51:42 CET 2009
    ?- use_module(library(hiord_rt)).
    {ERROR: absolute_file_name/7, arg 1 - existence error: source_sink:library(hiord_rt) does not exist}

      ?- use_module(library(hiord)).
    {Reading /usr/lib/ciao/ciao-1.13/lib/hiord.pl
    WARNING: (lns 1-1) Source used as module without module declaration
    }
    WARNING: cannot create /usr/lib/ciao/ciao-1.13/lib/hiord.itf
    {ERROR: internals:$open/3, arg 1 - existence error: source_sink:/usr/lib/ciao/ciao-1.13/lib/hiord.po does not exist}

    The documentation (ciao-1.13.0.dvi) p.505 Ch 85.1 suggests use_module(library(hiord_rt)). include/1 works. 

* Not from Ulrich 

** TODO Copy the stack dump for xsb exception 
** DONE change ouput in error arithmetic:$//3, ...  -> is/2
   CLOSED: [2012-09-12 Wed 17:03]
** TODO Investigate the dcg_phrase package.
   :- export('\6\call_from_phrase'/1)  is not understood by the
   top_level.


   
** FUTURE Make sure that we have a low-level check list			 :JM:
   :PROPERTIES:
   :CUSTOM_ID: low_list_check
   :END:
   
** FUTURE Low level atom_chars/2
   Requires [[#low_list_check]]

* Cyclic checks							      :JF:RH:
** *IMPORTANT* Why Ciao will may not add (some/most/all) them
   :PROPERTIES:
   :CUSTOM_ID: cyclic_rtcheck
   :END:
   
   It really does not make too much sense adding checks for cyclic
   terms in builtins. This is indeed a runtime check. This is a linear
   check. We are not willing to not make our builtins slower just for
   that.

   In many cases, it does not really help the user, since any Prolog
   code that happens before the builtins will make the whole thing not
   terminate. For example:

   #+begin_example
   % A is the atom with codes Xs in uppercase
   upcodes_atom(Xs, A) :-
       uppcodes_(Xs, Ys), atom_codes(A, Ys).
   
   uppcodes_([], []).
   uppcodes_([X|Xs], [Y|Ys]) :-
       ( X >= 0'a, X =< 0'z -> Y is 0'A + X - 0'a ; Y = X ),
       uppcodes_(Xs, Ys).
   #+end_example

   So, we believe that the real solution for that is using runtime
   checks. Any 'term' means finite term. So, we should add 'acyclic'
   checks wherever it is necessary (and remove them in loops, etc.).

   Users can always add 'acyclic' if they believe that their terms may
   be cyclic. They can chose between raising errors or failing. Of
   course, when using cyclic terms the builtins will just run out of
   memory.

   Note that many other Prolog systems skip those checks.

** POSTPONED 13: atom_chars/2: cyclic check missing
   Requires [[#low_acyclic]]

#+begin_example
    ?- Xs=[a|Xs],atom_chars(A,Xs).
    {ERROR: Memory allocation failed [in Realloc()]}
    { Execution aborted }
#+end_example

   Expected: type_error(list,[a| ...]). 
** POSTPONED 6: missing cyclic check in is/2
   :PROPERTIES:
   :CUSTOM_ID: cyclic_rtcheck_is
   :END:
   Requires [[#low_acyclic]].

   Missing cyclic check when argument of is/2 is non-numeric (make sure that this is done only once in the whole expression)

#+begin_example
    ?- X=1+X,Y is X.
    Segmentation fault
#+end_example

   Expected: type error. 

   We think that checking the domain before evaluation is not a good
   idea (performance-wise, see [[#cyclic_rtcheck]]). However, there is a
   cheap way to implement it:

    - Catch the memory problem *and* then look at the culprit
      expression: it was a cyclic term.
    - In that case, show a domain error.




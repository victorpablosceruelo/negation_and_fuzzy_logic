#!/bin/sh
#
# Ciao System command-line setup tool
#
# Authors: Edison Mera, Jose F. Morales
# ---------------------------------------------------------------------------
# 
# NOTE: Do not add commands here directly. Instead, create a command
#       group and register the commands and help
#
# NOTE: This command is too complicated to be efficiently programmed
#       in 'sh'. It will be eventually ported to Prolog.

# Follow symbolic links
self_exec=`test -L "$0" && readlink "$0" || echo "$0"`
# Obtain the directory where this script is located
old_dir=`pwd`; cd `dirname ${self_exec}`; self=`pwd`; cd ${old_dir}; old_dir=

# Exit immediately if a simple command exits with a non-zero status
set -e

# ===========================================================================

# Import modules for ciaosetup
. "${self}/makedir/terminal_io.sh"
. "${self}/makedir/clean_aux.sh"

# ===========================================================================
# Error messages

exit_on_error() {
    echo "`basename $0`: error: $1"
    exit 1
}

exit_on_error_q() {
    echo "$1"
    exit 1
}

# ===========================================================================
# Initialization of some common global variables

initialize_ciaosetup_vars() {
    CIAODESRC=${self}
    CIAOBUILDDIR=${self}/build
    SRCBINDIR=${CIAOBUILDDIR}/bin
}

# ===========================================================================
# Invoking bootstrapping

MAKE='make -s SHELL=/bin/bash'

GMAKEOPTS="--no-print-directory"
#GMAKEOPTS=""

# Ensure that bootstrap settings have been loaded
ensure_bootstrap_settings() {
    if [ x"${SETLOCALCIAO}" != x"" ]; then
	# Exit, bootstrap settings already loaded
	return
    fi
    if [ ! -f ${CIAOBUILDDIR}/CONFIG_sh ] ; then
	exit_on_error "$0 configure should be executed before build."
    fi
    # TODO: find a better way to load those variable
    SETLOCALCIAO=`. ${CIAOBUILDDIR}/CONFIG_sh; echo "${SETLOCALCIAO}"`
    SETBOOTSTRAPVARS=`. ${CIAOBUILDDIR}/CONFIG_sh; echo "${SETBOOTSTRAPVARS}"`
    eval ${SETBOOTSTRAPVARS}
    BOOTLPMAKE=${SRCBINDIR}/lpmake.sta
}

bootlpmake() {
    eval ${SETLOCALCIAO} ${BOOTLPMAKE} ${LPMAKEOPTS} $*
}

#   Important note: you would prefer the scheme:
#
#   ${LOCALENGINE} [prolog_args] -C -b bootfile
#
#   instead of this:
#
#   ${SETLOCALCIAO} bootfile [prolog_args]
#
#   The reason is that the first one is more portable.  The other
#   will not work well in Win32 unless you add the .cpx extension to 
#   the bootfile.

# ===========================================================================
#
# A Registry of Commands
#
#   A set of operations to define a switch of commands and help
#   message. The switch code and the help message are built
#   automatically from individual definitions grouped together.
#
# OPERATIONS
#
#   register_command <command_name>
#
#     Registers the command <command_name>, associated with the
#     function 'do__<command_name>', which must be provided by the
#     user.
#
#   build_command_case <command_name>
#
#     This builds and loads the 'command_case' function.
#
#   command_case [arguments]
#
#     The command case function (is not available until all the
#     commands are registered and 'build_command_case' is executed).
#     The first argument will be the command, the next arguments will
#     be passed as command arguments. 
#
#     The following user functions must be defined:
#
#     - do__<command_name>: Code for the command <command_name>
#     - do__unknown: Code executed when no command is recognized
#     - do__no_command: Code executed when no command is specified

COMMAND_LIST=""
register_command() {
    COMMAND_LIST="${COMMAND_LIST} $1"
}

build_command_case() {
    build_command_case__2 > ${self}/makedir/auto/command_case
    . ${self}/makedir/auto/command_case
}

# TODO: This is very slow
build_command_case__2() {
#    local cmd
#    local cmd2
    echo "command_case() {"
#    echo "    local act"
    echo "    act="'"$1"'
    echo "    if [ -z "'"$act"'" ]; then"
    echo "        do__no_command"
    echo "        return"
    echo "    fi"
    echo "    shift"
    echo "    case "'"$act"'" in"
    for cmd in ${COMMAND_LIST}; do
	# For compatibility, register two versions of the command name,
	# one with '_' other with '-'. Both do the same thing.
	cmd2="`echo "$cmd" | sed -e 's/_/-/g'`" # replace _ by -
	echo "        ${cmd}) do__${cmd} "'$@'" ;;"
	if [ "${cmd}" != "${cmd2}" ]; then
	    echo "        ${cmd2}) do__${cmd} "'$@'" ;;"
	fi
    done
    echo "        "'*'") do__unknown "'$act'" ;;"
    echo "    esac"
    echo "}"
}

mkdir -p ${self}/makedir/auto

# ===========================================================================

# Shows the help message
show_help() {
    cat <<EOF
Help:

  help         		Display this help and exit

Quick build and installation commands:

  user-install [OPTS]   Configure, compile the system to be executed from
                        the sources, and install it in your user account.
               		Warnings about unused predicates are enabled.
                        (see 'configure' below for valid values for OPTS)

  system-install [OPTS] Like 'user-install', but installs system wide.

  user-compile [OPTS]   [not documented]
  build-and-docs        [not documented]

Configuration (before build):

  configure [OPTS]      Configure the system automatically, using the
                        specified configuration options OPTS
                        (discarding any previous selection).

    The principal configuration options are:

      --help   	        Display full list of configuration options

      --menu   	        Configure the system interactively
      --cc=CC   	Select a custom C compiler
      --ld=LD   	Select a custom C linker (optional, uses
                        custom C compiler if not provided)
      --cflags=FLAGS    Use additional flags for C compiler
      --ldflags=FLAGS   Use additional flags for C linker

  prepare_bootstrap     [not documented]

  bootstrap_settings 	[not documented]
  clean_config       	Clean the configuration files
                        (this must be the last step during cleaning!)

Compiler promotion:

  promote               Promote bootstrap 'ciaoc' compiler

Build:

  build  	        Equivalent to 'build default'

  build ARG             Build the target specified as ARG. 

    Build omits documentation, see 'docs' option below.
    Most targets support incremental generation or compilation.
    The available values for ARG are:

      default           All bundles

      ciao            	Perform 'build' command on 'ciao' bundle
      lpdoc           	Perform 'build' command on 'lpdoc' bundle
      ciaopp          	Perform 'build' command on 'ciaopp' bundle
      chr 		Perform 'build' action on CHR bundle
      extra  		Perform 'build' command on all bundles, except 'ciao'

    For convenience, the following are subtargets of 'ciao' are also
    available:

      engine 	        Build the engine (incremental)
      ciaoc	        Build the compiler
      shell	        Build the shell (toplevel)
      emacs_mode        Build the emacs mode (for Emacs based IDE)

      libraries       	[not documented]
      platdep         	[not documented]
      nolibs       	[not documented]

      profiler          [not documented]

CiaoPP:

  calibrateciaopp       Calibrate CiaoPP (for resource analysis)

Emacs mode:

  etags ARG             Build the TAGS file (emacs) for the
                        given bundle (ciao, ciaopp, or lpdoc)

Maintenance:

  realclean    		Clean all Ciao auto-generated files, and also 
               		configuration choices. 

  braveclean   		Clean Ciao auto-generated files, including documentation,
               		but keep configuration choices.

  distclean    		Clean Ciao auto-generated files, excluding documentation.

  distclean_emacs_mode  [not documented]

  clean        		Clean Ciao auto-generated files, excluding documentation
               		and additional files such as logs, temporary files, etc.

  clean_chr 		[not documented]
  clean_engine 		[not documented]
  clean_etc 		[not documented]
  clean_bin 		[not documented]
  clean_lib 		[not documented]
  clean_ciaopp 		[not documented]
  clean_lpdoc 		[not documented]

  clean_recursive     	[not documented]
  clean_java          	[not documented]
  clean_pbundle     	[not documented]
  clean_ilciao         	[not documented]
  clean_platdep       	[not documented]
  clean_log           	[not documented]
  clean_builddir      	[not documented]
  clean_timingmodel    	[not documented]
  clean_profiler        [not documented]

  clean_dir_recursive [ARG] (clean compilation outputs recursively) 	 

Timingmodel (a simple WAM for time analysis):

  build_timingmodel    	[not documented]

Documentation:

  docs         	      	Generate (or update) all documentation using LPdoc.
               	      	Documentation is included in some distributions,
               	      	but this is needed when compiling fresh out of
               	      	the repository or after changes in the sources.

  docs_readmes          Perform 'docs_readmes' command on the 'wholesystem' bundle
  ciao_docs_readmes     Perform 'docs_readmes' command on the 'ciao' bundle
  emacs_mode_docs       [not documented]

  clean_docs          	[not documented]
  clean_justdocs      	[not documented]
  clean_installeddocs 	[not documented]

Installation:

  install      	      	Install the whole CiaoDE system 
               	      	(neeed to build the system before).

  uninstall             Uninstall the Ciao System

  install_to_destroot 	[not documented]
  install_ciaosetup    	[not documented]
  install_ciao        	[not documented]
  install_extras      	[not documented]

  install_emacs_mode   	Install the Ciao Emacs mode
  uninstall_emacs_mode  Uninstall the Ciao Emacs mode

  register_emacs_mode   Register the Ciao Emacs mode in the system
                        (depending on the installation type, locally
                        or globally)
  unregister_emacs_mode Unregister the Ciao Emacs mode.

  register_all          Register all components in your system (update
                      	shell scripts and emacs configuration
                      	files). If some component was already
                      	registered, this command updates the
                      	registered information.

  uninstall      	[not documented]

Querying Bundles:

  show_bundles          Show all available bundles

  gen_bundle_revision   Generates the REVISION file (from SVN)

Generation of Packaged Bundles (pbundle):

  gen_pbundle TYPE      Generates a packaged bundle of the specified type

  The available types are:
      win32     	[not documented]
      rpm       	[not documented]
      rpm_spec  	[not documented]
      app       	[not documented]
      macport   	[not documented]
      pkg       	[not documented]
      tgz       	[not documented]
      tbz       	[not documented]
      bin       	[not documented]
      bin_tgz   	[not documented]
      bin_tbz   	[not documented]
      noa       	[not documented]
      noa_tgz   	[not documented]
      noa_tbz   	[not documented]
      raw       	[not documented]
      raw_tgz   	[not documented]
      raw_tbz   	[not documented]

  gen_pbundle__descfile Generate the pbundle_meta file

Benchmarking:

  runbenchmarks         Execute all benchmarks available in the system.

Run-time Checks (experimental):

  user-install-rtchecks [OPTS]
                        Like user-install, but enables runtime checks
                        by default (warning: only in modules loaded 
                        from the toplevel)

Testing:

  runtests              Execute all tests (regression, etc.) available
                        in the system.

Interaction with the Ciao Bot (no public access): 

  bot [ARGS]            Invoke Ciao Bot

EOF
}

# ===========================================================================

register_command "promote"
do__promote() {
    ensure_bootstrap_settings
    bold_message "Promoting bootstrap compiler"
    normal_message "The current compiler will become the next bootstrap compiler"
    normal_message "(Warning: do not call it unless you are completely sure)"
    if ask_yesno "Are you sure?" && ask_yesno "Really?"; then
	do_promote_internal
	normal_message "Bootstrap compiler promoted"
    else
	normal_message "Promotion canceled"
    fi
}

# Promote bootstrap compiler, DO NOT CALL DIRECTLY (only from ciaosetup)
# TODO: Create a backup/ directory with a NODISTRIBUTE flag?
# (called from 'ciaosetup')
do_promote_internal() {
    cp ${BOOTSTRAP_CIAOC} "${BOOTSTRAP_CIAOC}-`date +%Y%m%d%H%M%S`"
    cp ${CIAOC} ${BOOTSTRAP_CIAOC}
}

# ===========================================================================

register_command "build"
do__build() {
    ensure_bootstrap_settings
    if [ x"$1" = x ]; then
	do__build_default
	return 0
    fi
    #
    case $1 in
	default)
	    do__build_default ;;
	extra)
	    do__build_extra ;;
	engine)
	    do_engine build ;;
	static_engine)
	    do_engine build_static ;;
	ciao)
	    do__build_ciao ;;
	libraries)
	    do__build_libraries ;;
	platdep)
	    do__build_platdep ;;
#	crossengine)
#	    do__build_crossengine ;;
	nolibs)
	    do__build_nolibs ;;
	lpdoc)
	    do__build_lpdoc ;;
	ciaopp)
	    do__build_ciaopp ;;
	chr)
	    do__build_chr ;;
	ciaoc) # (already included in 'ciao' target)
	    do__build_ciaoc ;;
	emacs_mode) # (already included in 'ciao' target)
	    do__build_emacs_mode ;;
	shell) # (already included in 'ciao' target)
	    do__build_shell ;;
	profiler)
	    do__build_profiler ;;
	*) 
	    echo "Unknown build target '${1}' in ciaosetup" >&2
	    exit 1
	    ;;
    esac
}

do__build_default() {
    bold_message "Building the Ciao System"
    # TODO: or ${CIAOBUILDDIR}/CONFIG_mkf?
    if [ ! -f ${CIAOBUILDDIR}/CONFIG_sh ]; then
	exit_on_error "$0 configure should be executed before build."
    else
	# TODO: Wrong? prepare_bootstrap creates an engine itself...
	#       OK, it may be calling prepare_bootstrap just to build lpmake again with the
        #       final settings... but then the names are wrong...
        do_engine build
	do_prepare_bootstrap # TODO: The bootstrap is prepared twice... why?
        # Kludge because 'bootlpmake build' breaks installer in Windows:
        # TODO: Why?
    	do__build_ciao
    	do__build_chr
	do__build_extra
        # do__build_static_engine
    fi
    bold_message "Ciao System build completed"
}
do__build_ciao() {
    # Kludge because 'bootlpmake build' breaks installer in Windows:
    # TODO: Why?
    ( cd ${CIAODESRC}/ciao; bootlpmake build ) || return 1
}
do__build_extra() {
    bootlpmake build_extra
}
do__build_static_engine() {
    do_build_static_engine
}

do__build_libraries() {
    ( cd ${CIAODESRC}/ciao; bootlpmake build_libraries ) || return 1
    ( cd ${CIAODESRC}/ciao; bootlpmake build_chr ) || return 1
    bootlpmake build_extra_libraries
}
do__build_platdep() {
    # TODO: 'platdep' is an overapproximation, it also includes
    #       binaries that are platform independent!!!
    do_engine build
    do_build_platdep
    bootlpmake build_platdep
#    do__build_static_engine
}

do__build_nolibs() {
    do_engine build
    do_build_nolibs
#    do__build_static_engine
    bootlpmake build_nolibs_extra
}
register_command "clean_engine"
do__clean_engine() {
    # ensure_bootstrap_settings ?
    do_engine clean
}

register_command "clean_etc"
# Clean some files from ciao_etc bundle # TODO: improve
do__clean_etc() {
    rm -rf \
	${CIAODESRC}/ciao/etc/DOTprofile \
	${CIAODESRC}/ciao/etc/DOTcshrc
}

register_command "clean_bin"
# Clean binary files from the build staging area
# (and other automatically generated files related to compilation)
do__clean_bin() {
    # some safety check...
    test x"${CIAOBUILDDIR}" = x"" && return
    # clean
    rm -rf ${CIAOBUILDDIR}/bin \
	${CIAODESRC}/ciao/lib/compiler/header \
	${CIAODESRC}/ciao/lib/compiler/bat_skel \
        ${CIAODESRC}/ciao/Win32/setup_bat.bat
}

register_command "clean_lib"
do__clean_lib() {
    do_clean_dir_rec ${CIAODESRC}
}

register_command "clean_ciaopp"
do__clean_ciaopp() {
    do_clean_dir_rec ${CIAODESRC}/ciaopp
}

register_command "clean_lpdoc"
do__clean_lpdoc() {
    do_clean_dir_rec ${CIAODESRC}/lpdoc
}

do__build_lpdoc() {
    ( cd ${CIAODESRC}/lpdoc; bootlpmake build ) || return 1
}

do__build_ciaopp() {
    ( cd ${CIAODESRC}/ciaopp; bootlpmake build ) || return 1
}
register_command "calibrateciaopp"
do__calibrateciaopp() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciaopp; bootlpmake calibrate ) || return 1
}

do__build_chr() {
    ( cd ${CIAODESRC}/ciao; bootlpmake build_chr ) || return 1 # TODO: It is still not a separated component (and it should be)
}
# TODO: Move inside CHR bundle
register_command "clean_chr"
# Clean automatically generated files for CHR 
do__clean_chr() {
    rm -rf \
	${CIAODESRC}/ciao/library/chr/chr_translate_bootstrap1.pl \
	${CIAODESRC}/ciao/library/chr/chr_translate_bootstrap2.pl \
	${CIAODESRC}/ciao/library/chr/chr_translate.pl.cmp \
	${CIAODESRC}/ciao/library/chr/guard_entailment.pl \
	${CIAODESRC}/ciao/library/chr/chr_translate.pl
}

register_command "clean_java"
do__clean_java() {
    # ensure_bootstrap_settings ?
    gmake_javall distclean
}
# TODO: port to Prolog
gmake_javall() {
    make SHELL=/bin/bash CIAODESRC=${CIAODESRC} ${GMAKEOPTS} -C ciao/library/javall $*
}

do__build_ciaoc() {
    ( cd ${CIAODESRC}/ciao; bootlpmake build_ciaoc ) || return 1
}

do__build_shell() {
    ( cd ${CIAODESRC}/ciao; bootlpmake build_shell ) || return 1
}

do__build_emacs_mode() {
    ( cd ${CIAODESRC}/ciao; bootlpmake build_emacs_mode ) || return 1
}

register_command "distclean_emacs_mode"
do__distclean_emacs_mode() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake distclean_emacs_mode ) || return 1
}

register_command "clean"
do__clean() {
    # TODO: tidy and garnish the output (clean_engine shows a message,
    #       clean_java shows commands, while the rest is just silent)
    do__clean_bin
    do__clean_chr
    do__clean_etc
    do__clean_recursive
    do_engine clean
    do__clean_java
    do__clean_timingmodel
    do__clean_pbundle
    do__clean_ilciao
}
register_command "distclean"
do__distclean() {
    do__distclean_emacs_mode
    do__clean_installeddocs # TODO: sure?
    do__clean_docstmp
    do__clean
    do__clean_config
}
register_command "braveclean"
do__braveclean() {
    do__clean
    do__clean_docs
}
register_command "realclean"
do__realclean() {
    do__braveclean
    do__clean_config
}

register_command "clean_dir_recursive"
# Clean compilation products recursively
# (the optional argument is the base directory for cleaning)
do__clean_dir_recursive() {
    if [ x$1 = x ] ; then
	DIR=`pwd`
    else
	DIR=$1
    fi
    do_clean_dir_rec ${DIR}
}

register_command "clean_recursive"
do__clean_recursive() {
    do_clean_dir_rec ${CIAODESRC}
}

register_command "clean_pbundle"
do__clean_pbundle() {
    rm -rf ${CIAOBUILDDIR}/pbundle
}
register_command "clean_ilciao"
do__clean_ilciao() {
    rm -rf \
        ${CIAODESRC}/ciaopp/ilciao/examples/Resources/examples.*.pl \
	${CIAODESRC}/ciaopp/ilciao/classes
}
register_command "clean_builddir"
do__clean_builddir() {
    rm -rf ${CIAOBUILDDIR}
}
register_command "clean_platdep"
do__clean_platdep() {
    do_engine clean
    do__clean_bin
    do__clean_rpd
}
do__clean_rpd() {
    # TODO: list of suffixes should be given by the system
    # TODO: depends on 'awk', a better solution?
    for i in `cat ciao/makedir/platdep_modules.pl|awk -F ',' \
	'{print substr($3, 2, length($3)-7)}'`
    do
	do_clean_mod "${i}"
    done
}
register_command "clean_log"
do__clean_log() {
    rm ${CIAOBUILDDIR}/install.log
}

register_command "build_timingmodel"
do__build_timingmodel() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake build_timingmodel ) || return 1
}
register_command "clean_timingmodel"
do__clean_timingmodel() {
    # TODO: invoke from Prolog? (for cleaning of secondary parts)
    gmake_timingmodel clean
}
gmake_timingmodel() {
    if [ -d ${CIAODESRC}/ciao/contrib/timingmodel ] ; then
	make SHELL=/bin/bash CIAODESRC=${CIAODESRC} ${GMAKEOPTS} -C ${CIAODESRC}/ciao/contrib/timingmodel $*
    fi
}

register_command "docs"
do__docs() {
    ensure_bootstrap_settings
    bold_message "Building Ciao System documentation"
    bootlpmake docs
    bold_message "Finished building Ciao System documentation"
}

register_command "docs_readmes"
do__docs_readmes() {
    ensure_bootstrap_settings
    mkdir -p ${CIAOBUILDDIR}/doc
    bootlpmake docs_readmes
}

# TODO: generalize for any bundle
register_command "ciao_docs_readmes"
do__ciao_docs_readmes() {
    ensure_bootstrap_settings
    mkdir -p ${CIAOBUILDDIR}/doc
    ( cd ${CIAODESRC}/ciao; bootlpmake docs_readmes ) || return 1
}

# TODO: generalize for any bundle
register_command "emacs_mode_docs"
do__emacs_mode_docs() {
    ensure_bootstrap_settings
    mkdir -p ${CIAOBUILDDIR}/doc
    ( cd ${CIAODESRC}/ciao; bootlpmake emacs_mode_docs ) || return 1
}

register_command "clean_docs"
do__clean_docs() {
    do__clean_installeddocs
    do__clean_justdocs
    do__clean_docstmp
#    do__clean_pbundle_docs
}
# do__clean_pbundle_docs() {
#     # TODO: Are those directories ever created?
#     rm -rf \
# 	${CIAODESRC}/ciao/doc/reference/pbundle \
# 	${CIAODESRC}/ciaopp/doc/internals/pbundle \
# 	${CIAODESRC}/ciaopp/doc/reference/pbundle \
# 	${CIAODESRC}/lpdoc/doc/pbundle
# }
register_command "clean_installeddocs"
do__clean_installeddocs() {
    rm -rf ${CIAOBUILDDIR}/doc
}
register_command "clean_justdocs"
do__clean_justdocs() {
    # TODO: Is this cleaned from makedir_part_ciao.pl too?
    rm -rf \
	${CIAODESRC}/ciao/NewUser \
	${CIAODESRC}/ciao/README \
	${CIAODESRC}/ciao/INSTALLATION \
	${CIAODESRC}/ciao/INSTALLATION_Win32 \
	${CIAODESRC}/lpdoc/README \
	${CIAODESRC}/lpdoc/INSTALLATION \
	${CIAODESRC}/lpdoc/lib/site/index.html \
	${CIAODESRC}/ciaopp/README \
	${CIAODESRC}/ciaopp/INSTALLATION
}
#register_command "clean_docstmp"
# TODO: outdated? Are those directories ever created?
do__clean_docstmp() {
    rm -rf \
	${CIAODESRC}/ciao/doc/reference/tmp \
	${CIAODESRC}/ciaopp/doc/internals/tmp \
	${CIAODESRC}/ciaopp/doc/reference/tmp \
	${CIAODESRC}/lpdoc/doc/tmp
}
#register_command "clean_docspackage"
# TODO: outdated?
# do__clean_docspackage() {
#     rm -rf \
# 	${CIAODESRC}/ciao/doc/reference/package \
# 	${CIAODESRC}/ciaopp/doc/internals/package \
# 	${CIAODESRC}/ciaopp/doc/reference/package \
# 	${CIAODESRC}/lpdoc/doc/package
# }

# ===========================================================================

register_command "install"
do__install() {
    ensure_bootstrap_settings
    get_install_options "$@" 
    bold_message "Installing the Ciao System"
    do__install_ciaosetup
    do__install_ciao
    do__install_extras
    # Note: we don't use bootlpmake install to work around a bug in doc
    # generation that should be solved
    #     bootlpmake install
    bold_message "Ciao System installation completed"
}
register_command "uninstall"
do__uninstall() {
    ensure_bootstrap_settings
    do__uninstall_ciaosetup
    bootlpmake uninstall
}
register_command "install_to_destroot"
# TODO: other code uses ROOTPREFIX directly... why?
#       That is:
#         ciao/library/lpdist/rpm/CiaoDE.spec.skel:282:ROOTPREFIX=%{buildroot} ./ciaosetup install
do__install_to_destroot() {
    ensure_bootstrap_settings
    if echo expr $* : '\(--destdir*=[^=][^=]*\)' >/dev/null  ; then 
	DESTDIR=`expr $* : '--destdir=\([^=][^=]*\)'`
    else
	exit_on_error  "incorrect option \"$ARG\". Should be of the form --destdir=[value]".
    fi
    export ROOTPREFIX=${DESTDIR}
    bold_message "Installing Ciao System into ${DESTDIR}"
    do__install_ciao
    do__install_extras
    bold_message "Ciao System installation completed"
}

register_command "install_ciaosetup"
do__install_ciaosetup() {
    # TODO: at this moment, only for developers
    rm -f ${SRCBINDIR}/ciaosetup
    ln -s ${self}/ciaosetup ${SRCBINDIR}/ciaosetup
}
register_command "uninstall_ciaosetup"
do__uninstall_ciaosetup() {
    # TODO: at this moment, only for developers
    /bin/rm -f ${SRCBINDIR}/ciaosetup
}
register_command "install_ciao"
do__install_ciao() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake install ) || return 1
}
register_command "install_extras"
do__install_extras() {
    ensure_bootstrap_settings
    bootlpmake install_extras
}

# (already included in 'ciao' target)
register_command "install_emacs_mode"
do__install_emacs_mode() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake install_emacs_mode ) || return 1
}

register_command "uninstall_emacs_mode"
do__uninstall_emacs_mode() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake uninstall_emacs_mode ) || return 1
}

register_command "register_emacs_mode"
do__register_emacs_mode() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake register_emacs_mode ) || return 1
}

register_command "unregister_emacs_mode"
do__unregister_emacs_mode() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}/ciao; bootlpmake unregister_emacs_mode ) || return 1
}

register_command "register_all"
do__register_all() {
    ensure_bootstrap_settings
    bootlpmake register_all
}

# TODO: Reuse do_boot_scan_bundles (ciao) to add a command to rescan
#       the bundles under a source tree?

register_command "show_bundles"
do__show_bundles() {
    ensure_bootstrap_settings
    ( cd ${CIAODESRC}; bootlpmake show_bundles ) || return 1
}

# ===========================================================================

register_command "gen_pbundle"
do__gen_pbundle() {
    ensure_bootstrap_settings
    TYPE=${1}
    shift
    case ${TYPE} in
	win32)    bootlpmake gen_pbundle__win32 ;;
	rpm)      get_install_options "$@"; bootlpmake gen_pbundle__rpm ;;
	rpm_spec) bootlpmake gen_pbundle__rpm_spec ;;
	app)      bootlpmake gen_pbundle__app ;;
	macport)  bootlpmake gen_pbundle__macport ;;
	pkg) 	  bootlpmake gen_pbundle__pkg ;;
	src) 	  bootlpmake gen_pbundle__src ;;
	tgz) 	  bootlpmake gen_pbundle__tgz ;;
	tbz) 	  bootlpmake gen_pbundle__tbz ;;
	bin) 	  bootlpmake gen_pbundle__bin ;;
	bin_tgz)  bootlpmake gen_pbundle__bin_tgz ;;
	bin_tbz)  bootlpmake gen_pbundle__bin_tbz ;;
	noa)      bootlpmake gen_pbundle__noa ;;
	noa_tgz)  bootlpmake gen_pbundle__noa_tgz ;;
	noa_tbz)  bootlpmake gen_pbundle__noa_tbz ;;
	raw)      bootlpmake gen_pbundle__raw ;;
	raw_tgz)  bootlpmake gen_pbundle__raw_tgz ;;
	raw_tbz)  bootlpmake gen_pbundle__raw_tbz ;;
	*)
	    echo "Bad type for gen_pbundle" >&2
	    exit 1
	    ;;
    esac
}

register_command "gen_bundle_revision"
do__gen_bundle_revision() {
    ensure_bootstrap_settings
    bootlpmake gen_bundle_revision
}

register_command "gen_pbundle__descfile"
do__gen_pbundle__descfile() {
    ensure_bootstrap_settings
    bootlpmake gen_pbundle__descfile
}

# ===========================================================================

register_command "runbenchmarks"
do__runbenchmarks() {
    ensure_bootstrap_settings
    bootlpmake runbenchmarks
}

do__build_profiler() {
    ( cd ${CIAODESRC}/ciao; bootlpmake build_profiler ) || return 1
}
register_command "clean_profiler"
do__clean_profiler() {
    do_clean_dir_rec ${CIAODESRC}/ciao/contrib/profiler
}

register_command "runtests"
do__runtests() {
    ensure_bootstrap_settings
    bootlpmake runtests
}

# ===========================================================================
# Runtime tests

# TODO: Is this option really necessary? why not just enable the flag?
register_command "user_install_rtchecks"
do__user_install_rtchecks() {
    run_config --instype=local \
	--unused-pred-warnings=yes \
	--ciaosh-commands="\"set_prolog_flag(runtime_checks,yes)\"" \
        $*
    do__build
    do__docs
    do__install
}

# ===========================================================================

register_command "configure"
do__configure() {
    run_config $*
}
register_command "prepare_bootstrap"
do__prepare_bootstrap() {
    do__bootstrap_settings
    do_prepare_bootstrap
}

register_command "bootstrap_settings"
# Create a ${CIAOBUILDDIR}/CONFIG_mkf with default settings (for bootstrap)
do__bootstrap_settings() {
    # Minimal settings file for compiling the engine for the first time
    test -d ${CIAOBUILDDIR} || mkdir ${CIAOBUILDDIR} # TODO: necessary?
    cat > ${CIAOBUILDDIR}/CONFIG_input <<EOF
INSTYPE=local
SILENT=true
USE_THREADS=yes
USE_POSIX_LOCKS=no
AND_PARALLEL_EXECUTION=no
PAR_BACK=no
TABLED_EXECUTION=no
OPTIM_LEVEL=optimized
EXECMODE=775
DATAMODE=664
DEBUG_LEVEL=install
INSTALLGROUP=
# Assume that svnversion is not available
HAVE_SVNVERSION=no
#
CIAODESRC=${CIAODESRC}
REALLIBDIR=${CIAODESRC}/ciao
INSTALL_LOG=${CIAOBUILDDIR}/install.log
RUNTIME_CHECKS=${RUNTIME_CHECKS}
UNUSED_PRED_WARNINGS=${UNUSED_PRED_WARNINGS}
CUSTOM_CC=${CUSTOM_CC}
CUSTOM_LD=${CUSTOM_LD}
CFLAGS=${EXTRA_CFLAGS}
LDFLAGS=${EXTRA_LDFLAGS}
EOF
    # TODO: Duplicated in some makedir_part_ciao.pl (in Prolog)
    ${CIAODESRC}/ciao/config-sysdep/config-and-dump.sh ${CIAOBUILDDIR}/CONFIG_input
    /bin/rm -f ${CIAOBUILDDIR}/CONFIG_input
}

run_config() {
    get_config_options $*
    if [ x$HELP = x1 ] ; then
	config_help
	exit 0
    elif [ x$INVALIDOPT != x ]; then
	exit_on_error "unrecognized configure option: $INVALIDOPT.\nTry \"$0 configure --help\" for usage."
    fi
    bold_message "Configuring the Ciao System"

    # Erase generated configuration files
    # TODO: Add parameters in config-and-dump.sh to retrieve the name
    #       of the configuration files
    /bin/rm -f ${CIAOBUILDDIR}/CONFIG_mkf
    /bin/rm -f ${CIAOBUILDDIR}/CONFIG_sh

    if [ x$MENU = x1 ] ; then
	true
    else
        # Remove saved configuration
	rm -f ${CIAOBUILDDIR}/CONFIG_saved
    fi

    do__bootstrap_settings
    if [ x$MENU = x1 ] ; then
	INTERACTIVE_CONFIG_OPT=
    else
	INTERACTIVE_CONFIG_OPT="-d INTERACTIVE_CONFIG=1"
    fi
    
    # TODO: use a local var? several calls to run_config would add redundant items here
    LPMAKEOPTS="$INTERACTIVE_CONFIG_OPT $LPMAKEOPTS"

    # Prepare the bootstrap system
    do_prepare_bootstrap

    # Configure Ciao (from Prolog)
    ensure_bootstrap_settings
    OLDPWD=`pwd`
    cd ${CIAODESRC}/ciao
    bootlpmake configure
    cd ${OLDPWD}
    # TODO: It is possible that after configure the .po/.itf should be 
    #       erased or invalidated!
}

get_config_options() {
    INVALIDOPT=
    HELP=0
    MENU=0
    if [ ! $# = 0 ] ; then
	for ARG in "$@" ; do
	    if [ x$ARG = x--menu ] ; then
		MENU=1
	    elif [ x$ARG = x--help ] ; then
		HELP=1
	    elif expr $ARG : '\(--[^=][^=]*=..*\)' >/dev/null  ; then 
		OPT=`expr $ARG : '--\([^=][^=]*\)=..*'|sed -e s:_:-:g`
		VAL=`expr $ARG : '--[^=][^=]*=\(..*\)'`
                if [ x$OPT = xcc ] ; then
		    CUSTOM_CC=$VAL
                elif [ x$OPT = xld ] ; then
		    CUSTOM_LD=$VAL
                elif [ x$OPT = xcflags ] ; then
		    EXTRA_CFLAGS=$VAL
		elif [ x$OPT = xldflags ] ; then
		    EXTRA_LDFLAGS=$VAL
		elif [ x$OPT = xunused-pred-warnings ] ; then
		    UNUSED_PRED_WARNINGS=$VAL
		elif [ x$OPT = xruntime-checks ] ; then
		    RUNTIME_CHECKS=$VAL
		fi
		LPMAKEOPTS="${LPMAKEOPTS} -d ${OPT}=${VAL}"
	    else 
		INVALIDOPT=$ARG
	    fi 
	done
    fi
}

get_install_options() {
    for ARG in "$@"
    do
	if expr $ARG : '\(--[^=][^=]*=[^=][^=]*\)' >/dev/null ; then 
	    OPT=`expr $ARG : '--\([^=][^=]*\)=[^=][^=]*'`
	    VAL=`expr $ARG : '--[^=][^=]*=\([^=][^=]*\)'`
	    LPMAKEOPTS="${LPMAKEOPTS} -d ${OPT}=${VAL}"
	else 
	    exit_on_error "incorrect option \"$ARG\". Should be of the form --[option]=[value]".
	fi
    done
}

config_help() {
    # TODO: the configuration options may not be available until the
    #       system bootstraps... Fix it: show basic options and then
    #       custom options for other bundles (or make options be
    #       part of some kind of bundle-boostrap).
    OPTSFILE="${self}/makedir/config_opts.txt"
    if [ -r ${OPTSFILE} ]; then
	cat ${OPTSFILE}
    else
	# TODO: This is quite unpleasant
	echo "Execute 'lpmake makedir/config_opts.txt' to generate the help message for configuration options."
    fi
}

register_command "clean_config"
# Warning! clean_config is the last cleaning step. If you clean all
#          the configuration files then many scripts will not run.
do__clean_config() {
    # TODO: split in a clean_config for each bundle (i.e., engine, etc.)
    # TODO: I am not sure that the bundle_registry enters here.
    rm -rf ${CIAOBUILDDIR}/CONFIG_input \
	   ${CIAOBUILDDIR}/CONFIG_mkf \
	   ${CIAOBUILDDIR}/CONFIG_sh \
	   ${CIAOBUILDDIR}/CONFIG_saved \
	   ${CIAODESRC}/ciao/lib/bundle_registry/bundles \
	   ${CIAOBUILDDIR}/CONFIG_GSL \
	   ${CIAODESRC}/ciao/library/pillow/icon_address.pl
    # TODO: not done before since this cleans configuration files too!
    do__clean_builddir # not sure if it belongs here...
}

# ===========================================================================

register_command "help"
do__help() {
    show_help_banner
    show_help
}
show_help_banner() {
    cat <<EOF
usage: `basename $0` <subcommand>
Ciao System command-line setup tool.

Available subcommands:
EOF
}

# No command
# (this is a hard-wired command for build_command_case)
do__no_command() {
    cat <<EOF
Type '`basename $0` help' for usage.
EOF
}

# Unknown command
# (this is a hard-wired command for build_command_case)
do__unknown() {
    exit_on_error_q "Unknown command: '""$1""'.\nTry '""`basename $0` help""' for usage."
}

# ===========================================================================

# TODO: Proposal for changes of those names 
#       (remember to update the documentation)
#
#   Allow modifiers for global installation options?
#
#   user_install => local_install
#   user_compile => local_install --without-docs
#     (do__install is required for the system
#      and it is cheap for local installation)
#   user_install_rtchecks => local_install --with-rtchecks
#   system_install => global_install

register_command "user_install"
do__user_install() {
    run_config --silent=true --instype=local --unused-pred-warnings=yes $*
    do__build
    do__docs
    do__install
}
register_command "user_compile"
do__user_compile() {
    run_config --silent=true --instype=local --unused-pred-warnings=yes $*
    do__build
}
register_command "system_install"
do__system_install() {
    run_config --silent=true $*
    do__build
    do__docs
    do__install
}
# TODO: deprecate (not used)
register_command "build_and_docs"
do__build_and_docs() {
    do__build
    do__docs
}

# ===========================================================================

register_command "bot"
do__bot() {
    ${self}/ciaobot/ciaobot $*
}

# ===========================================================================

# TODO: hardwired paths, fix and generalize for any bundle
register_command "etags"
do__etags() {
    ensure_bootstrap_settings
    if [ x"$1" = x ]; then
	do__build_default
	return 0
    fi
    #
    case $1 in
	ciao)
	    ( cd ${CIAODESRC}/ciao; bootlpmake tags ) || return 1 ;;
	ciaopp)
	    ( cd ${CIAODESRC}/ciaopp; bootlpmake tags ) || return 1 ;;
	lpdoc)
	    ( cd ${CIAODESRC}/lpdoc; bootlpmake tags ) || return 1 ;;
	*) 
	    echo "Unknown bundle '${1}' for 'ciaosetup etags'" >&2
	    exit 1
	    ;;
    esac
}

# ===========================================================================
# (called from 'ciaosetup')
do_build_nolibs() {
    ensure_bootstrap_settings
    # TODO: really? check again
    # do_boot_scan_bundles # TODO: why repeat that?
    do_build_bootstrap_lpmake
    OLDPWD=`pwd`
    cd ${CIAODESRC}/ciao
    bootlpmake build_ciaoc
    bootlpmake build_shell
    bootlpmake build_nolibs
    cd ${OLDPWD}
}

# called from makedir_part_ciao.pl
do_build_platdep() {
    ensure_bootstrap_settings
    # do_boot_scan_bundles # TODO: why repeat that?
    do_build_bootstrap_lpmake
    OLDPWD=`pwd`
    cd ${CIAODESRC}/ciao
    bootlpmake build_ciaoc
    bootlpmake build_shell
    cd ${OLDPWD}
}

# ===========================================================================

# TODO: This is a static 'lpmake', not a bootstrap. It is static to
#       avoid problems during compilation (specially if compilation
#       options change). The bootstrap binary is just 'ciaoc'.
#       
#       Can this be improved?
#
#        - we need a minimal bootstrap system
#          (including a minimal configuration for the bundle of
#           common libraries -- i.e., the ciao library path)
#
#        - we need a tool that handles bundle compilation
#          (based on lpmake?)
#
do_build_bootstrap_lpmake() {
    ensure_bootstrap_settings
    OLDPWD=`pwd`
    cd ${CIAODESRC}/ciao/etc
    eval ${SETLOCALCIAO} ${BOOTSTRAP_CIAOC} -s -x ${CIAOCOPTS} -o ${BOOTLPMAKE} lpmake
    EXECMODE=775 # TODO: configure before?
    chmod ${EXECMODE} ${BOOTLPMAKE}
    cd ${OLDPWD}
}

# ---------------------------------------------------------------------------

# Scans the bundles under the current source tree (during bootstrapping)
# (This is necessary before any other command can be compiled)
# TODO: Maybe it could be simplified by looking at bundle dependencies...

do_boot_scan_bundles() {
    ensure_bootstrap_settings
    #BOOT_SCAN_BUNDLES="${SRCBINDIR}/boot_scan_bundles${CIAOSUFFIX}"
    BOOT_SCAN_BUNDLES="${SRCBINDIR}/boot_scan_bundles"
    # TODO: it seems to rebuild the binary even if it is not necessary...
    mkdir -p ${SRCBINDIR}
    normal_message "Building bundle scanner"
    eval ${SETLOCALCIAO} ${BOOTSTRAP_CIAOC} ${CIAOCOPTS_NORTCHECKS} -s -x -o ${BOOT_SCAN_BUNDLES} ${CIAODESRC}/makedir/boot_scan_bundles
    normal_message "Scanning bundles in the source tree"
    eval ${SETLOCALCIAO} ${BOOT_SCAN_BUNDLES} ${CIAODESRC}
}

# ---------------------------------------------------------------------------

# (called from 'ciaosetup')
do_prepare_bootstrap() {
    ensure_bootstrap_settings
    if [ -x ${BOOTLPMAKE} ] && do_engine engine_is_ok; then
	# Bootstrap seems to be prepared, just scan bundles
	do_boot_scan_bundles # TODO: why?
    else
        # also defined in prolog 
        # TODO: search INSTALL_LOG
	BUILD_LOG="${CIAOBUILDDIR}/install.log"
        # TODO: There is a previous call to do__engine in do_build. Why?
	normal_message "Building bootstrap engine"
	do_engine build >> ${BUILD_LOG}
	# scan bundles
	do_boot_scan_bundles
	normal_message "Building bootstrap lpmake"
	do_build_bootstrap_lpmake >> ${BUILD_LOG}
    fi
}

# ===========================================================================
# Invoke some engine build operation

do_engine() {
    MAKE="${MAKE}" CIAOBUILDDIR="${CIAOBUILDDIR}" ${CIAODESRC}/ciao/engine/build_engine.sh $*
}

# ===========================================================================

build_command_case

# Setup vars and execute command_case
initialize_ciaosetup_vars
command_case "$@"


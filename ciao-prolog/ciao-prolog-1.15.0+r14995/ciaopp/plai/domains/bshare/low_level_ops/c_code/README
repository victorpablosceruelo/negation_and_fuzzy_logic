negdb: Negative Database, version 0.72
--------------------------------------
by Elena S. Ackley

negdb-v.72 ready to be released May, 2008

CONTENTS:
__News (cumulative change history)
__Overview
__Installation
__Using Negdb (includes examples)
__Contact
__Licensing

[note: easy search for sections using double underscores __ ]


__News

New in this version v.72.8: added mode 3 comparison that expands the
*'s before checking for subsumption (replaces modes 0 and 1); changed
compare units tests to take mode as an argument; updated this readme.

New in this version v.72.7.1: added unit tests that BREAK mode 1
and mode 0 compare (-Z 1 and -Z 0).

New in this version v.72.7: add another compare mode for the fully
specified cdb so that it can be tried on the not fully specified too;
comment out assertions in nsql_setdiff and nsql_relevance, just in
case of future experiments; no guarantees; and this readme.

New in this version v.72.6: name change recset_query_match_all to
recset_query_match_none (since it returns true if none of the records
in recset2 match recset1); added new recset_match_all to return true
if all records in recset1 have a match in recset2; and fixed comments.
Changed compress to use a constant number of maximum iterations
(MAX_COMPRESS_TRIES, default 100) instead of the record length.
Changed negdb script command K to set minbits without setting the
specified flag to stop compressing (mainly used for adds/removes).

New in this version v.72.5: changed minbits at the end of
binaryunionstar (-x S) to smallest k (=1), instead of input k, for
most compression;

New in this version v.72.4: added checks to SetDiff (-x OnlyInFirstDB)
and Relevance (-x R) insuring no *'s appear in the input.

New in this version v.72.3: added SetDiff (-x OnlyInFirstDB)
relational operation for two positive fully specified databases.

New in this version v.72.2: added TernarySetDiffCDB relational
operation for two positive ternary databases. NEVER MIND.

New in this version v.72.1: modified the Makefile to have a library
option (unused).

New in this version v.72: changed Relevance operation back to v.71 for
bSH use; updated relevance unit tests; changed nsql_binaryunion to
return 1 if the number of records in the results is the same as the
second input file to test for 'star closure' in the complement ndb
(monotonically increasing when changing); changed nsql_binaryunionstar
to not use compression while doing the star closure step; changed
recset_equivalence to handle fully specified (no *'s) case more
efficiently; and this readme.


Also includes:

New in this version v.71.2: changed Relevance operation to call neg
union because it needs to do both match and coalesce, and the previous
idea didn't work; added fourth unit test for Relevance.

New in this version v.71.1: fixed rec_relevant to work correctly;
added third unit test for Relevance relational operation (-x R) to
catch the failure.

New in this version v.71: added Relevance relational operation (-x R)
that uses bitwise-and for complemented ndb's to return records from
the first input set that contain at least a single set (=1) bit in
common with a record in second input query set; added two unit tests
for relevance; updated online_compare to use a more efficient
procedure for mode 0 that doesn't require complementing both input
negative databases before testing the first proposition; and updated
this README (see example 27).

New in this version v.70: updated singleton (-i) to handle more than
one hidden solution argument; fixed rstree_query_match; modified
singleton tests to work with new input format; added unit test to
test 2 hidden singletons; and this README (see example 5a).

New in this version v.69.2: updated script commands: D to specify
filename for second input, result, and test directory, K to attempt to
compress the result, N to support new modes 3 and 4; Z to initialize
the iteration count; fixed scripts to work on zero size databases; and
this readme

New in this version v.69.1: Don't restore minbits value in
starnegbinaryunion (leave as 1 after complements are done); Disabled
debug code that saves intermediate bu recset results in
nsql_binaryunion.

New in this version v.69: Modified recset_equivalence to compress its
input before doing the comparison, and changed the comparison to check
for subsumption rather than matching; renamed recset_query_match_all
to recset_query_all; Modified -x S starnegativebinaryunion operation
to reset minbits to 1 before proceeding with the binaryunion step to
reduce the size of the result; and this readme.

New in this version v.68: Modified recset_save_secondary to take a
compress flag argument so that partial queries can compress with the
-k commandline option; refactored compress out of online_complement,
and online_copyproject; compress is not applied to partial queries
with the Project option, nor is it reapplied to optional secondary
output since its already done by then. Added unit test that fails
online_compare (requires RNDB-un_1.test and RNDB-un_2.test).


New in this version v.67: Modified insert (addallbitcombos) to append
directly into the recset without using extra cache so that managed
growth has a chance to work (might be slower than previous version);
modified test_runtime_compare_binary_directly to work without managed
growth; Added compiler option USE_INSERT_NSQL_ALL to use Insert
alternative to default Append for all relational operations that may
add extra bits and records for testing purposes; added compiler option
NPG_USE_NSQL_BU for Binary Union operation only; modified compiler
option NPG_USE_NSQL to be NPG_USE_NSQL_ALL; and this readme.

New in this version v.66.3: Added compiler option USE_INSERT_NSQL_BU
to use Insert, alternative to default Append for relational
operations, that may add extra bits and records to negative
binary union only.

New in this version v.66.2: Complements in NegBinaryUnionStar
compressed if NPG_NONE_UNNEGATE is set along with
RELOP_MIDCLEANUP_OPTION; and this readme.

New in this version v.66.1: Corrected -C command to coalesce matched
results; Corrected -C command to compress result when -k is used to
specify minimum bits; Improved rec_coalesce function efficiency,
supports the -C command, as well as Negative Union; Added new mode 2
to represent the powerset db; Added unit test to compare a positive
compressed db and an unnegated ndb; and this readme.

New in this version v.66: StarNegBinaryUnion now internally repeats
star closure step until there is no change in the result; refactored
recset_equivalence to support change in StarNegBinaryUnion; added
test_runtime_binary_union_star_closure test with 5 bits as Jorge
offered in 12/9/07 email; updated the
test_runtime_binary_union_of_bits4 test to reflect a realistic LHS
with only one variable as Eric suggested; and, updated this readme.

New in this version v.65.2: fixed bug so -P now works with -C, a query
for the complemented ndbs (also useful to expand an ndb using all *'s);
fixed test_runtime_copyproject test; and this readme.

New in this version v.65.1: New command -C that copies subsumed
records, with the -P option the results should be equivalent to -q -P
(without the results may not be a valid negative database, but perhaps
useful for un_negated ndbs); updated partial query test to use new
command; and this readme.

New in this version v.65: Refactored binaryunion to support working
directly on unnegated negative databases; Redefined relop command 'B'
to 'S', to be the complete negative binary union star (as in previous
versions), and changed 'B' to be a basic binary union; Redefined the
Compare command to take a mode argument that allows for comparing two
unnegated negative databases directly; updated binary union tests to
use "S" instead of "B"; added two compare_directly tests; added
NPG_NONE_NDBREMOVE compile option; and, updated this readme.

New in this version v.64.1: fixed typo bug in binary union to do
(rarely used) cleanup option on the final result, BUstar (unreleased);
restored REL_OPS_EFFICIENCY step to Negative Intersection regardless
of MANAGED_GROWTH option; and this readme.

New in this version v.64: Refactored the "managed growth" changes from
recset_addrec, and the redundancy_check into
managed_growth_redudancy_check, so that it is only used where it is
needed (insert and append) without effecting other basic recset
functions (like the recset_split_ variations, recset_copy,
recset_merge, etc); other changes due to this refactoring: compress
works now and uses just the redundancy check with MANAGED_GROWTH
option, check_for_cleanup was restored to pre-v.59.1, test_runtime
hardcoded test sizes were restored to pre v.59 numbers; partial_query
was restored to pre v.59 that used recset_delete_subsumed (left
recset_perm_copy as changed in v.62); fixed another bug in easy_chase
in the same area as addressed in v.62; corrected cleanup counts and
added exit err22 to error.h for when the sizes do not compute; changed
addallbitcombos to return void since the count can be inaccurate
anyway (no impact); fixed online_compare to use full record length
number of minimum bits without MANAGED_GROWTH option; and, updated
this readme.

New in this version v.63: provides finer granularity for NPG_NONE
option for _NDBADD, _NEWNDB0, and _UNNEGATE as described below;
provides new option (NPG_USE_NSQL) to use negative pattern generate
(npg) in relational operations; changes recset_complement default to
use npg; skips compress quietly with MANAGED_GROWTH (broke with
changes to recset_addrec in v.62); restored NPG default to
NPG_REMV_BIAS; and this readme.

New in this version v.62: MANAGED_GROWTH option also eliminates the
subsumed records in the recset for each new record added to the recset
(makes compression obsolete); fixed broken easy_chase in easy.c to use
two recsets; added deleted cache size output message for
offline_add_record; switched -k and -m commandline args so that -k
attempts compression and -m does not; RELOP_MIDCLEANUP_OPTION only
needed without MANAGED_GROWTH; and this readme.

New in this version v.61.4: changed new empty ndb modes 0 and 1 to
eliminate randomness when NPG_NONE or NPG_DETERMINISTIC are used;
added EXPAND_INPUT_NDB compile time option to override MANAGED_GROWTH
for expanding number of specified bits in input ndb; do not expand
input ndb for unnegates; this readme.

New in this version v.61.3: changed online_compare to test for
matching records in the complements rather than equality to improve
performance; added recset_query_match_all to support change to
online_compare; changed the default Makefile options for Negative Set
Sharing application; and this readme.

New in this version v.61.2: updated Makefile to include test.c only
for testmain executable; added -k commandline argument to specify
minbits without compression (unlike -m); -m 0 provides compression to
smallest record size in input ndb; and this readme.

New in this version v.61.1: removed misleading check when backing out
of cleanup; updated compare_binary test to add recs in different order
and set the seed to insure the ndb are different; changed
UNNEGATE_HAMMDIS_ options to maximize the hamming distance; disabled
debug print statements in recset_complement; and, this readme.

New in this version v.61: new compile time UNNEGATE_HAMMDIS_ options
to reduce the hamming distance between negative records for unnegate
processing; changed perm struct to have pointers to allocated memory
to accommodate number of negative records rather than just record
length.

New in this version v.60.1: change SAVE_UNSORTED to SAVE_SORTED_NDB;
added MANAGED_GROWTH compile-time flag that disables expandrecsize on
build, and doesn't add redundant records; no longer call
recset_delete_subsumed efficiency step in negIntersection and Select
when MANAGED_GROWTH is used; added NPG_NONE as the system default
negative pattern generate that does nothing; redefined NSQL_NPG in
nsql.c so the relational algebra functions do not use negative pattern
generate (originally unspecified, seems faster compressing instead);
updated test_runtime to skip compress after the record adds and
removes so that cleanup part of test will have something to do; added
another Binary Union unit test based on RNDB-3673.test, an ndb with
3673 positive solutions; updated this readme.

New in this version v.60: disable expandrecsize at build time; change
random_distinct_bits (called by insert) to not randomize when
NPG_DETERMINISTIC is used; duplicate online_add_record without query
check and other user messages, called offline_add_record in negdb.c;
in recset_complement, remove compression, and call offline_add_record
without npg flag; fixed NPG_VERBOSE_DEBUG to print recs; and, updated
this readme.

New in this version v.59.2: corrected compress to skip when minbits
argument is zero; save negative databases in sorted order; added
compile time option to SAVE_UNSORTED, printing ndb in array order
(like before this release); added another MIDWAY compress option to
negative Binary Union before the last complement, and removed the
double compression on the last complement; set specified bit flag in
tests that set the minimum bit; updated this readme.

New in this version v.59.1: Due to new recset_addrec in v.59: updated
check_for_cleanup to handle case when query for subsumed records
differs from split subsumed due to new addrec; removed initial query
when adding a non-pattern since the the queried deleted cache size
could be greater than the actual size thereby invalidating a high
water mark check (the purpose of the initial query in the first
place); consolidated online_add_pattern and _nonpattern into
online_add_record; verified and updated test_runtime; changed test
filenames to make it easier to cleanup; and, updated this readme.

New in this version v.59: Three main changes: 1. basic recset_addrec
function checks for 'redundant', as well as duplicate, records before
adding them. 2. compiler option (USE_APPEND) to use an alternative
Insert that simply appends the rec with or without NPG (doesn't add
extra bits or records); applies to "adding/removing" records and
cleanups; nsql functions all use append, per spec; ProjOption no
longer special case for thetaselect_ne or recset_partial_query since
recset_addrec does this now. 3. compiler option to always
SKIP_COMPRESS, or just when -m is not specified by user, o.w. compress
tries each record at least once, at most record length times, but
quits as soon as there's no decrease in ndbsize; do midway compression
before optional cleanup for Set Diff and Binary Union; relational
operations, including selects, also compress final results;
recset_complement uses record length to build, and minbits arg for
compression step (allows Compare to skip it); and, updated this
readme.
 
New in this version v.58: compresses online add/remove normal ndb
build operations before returning results.

New in this version v.57: compressed complements; cleanup option (-T)
to immediately follow successful Add, Remove, Complement, and
Relational Operations (uses a minimum of 100 and max of 3000 when
nonzero and percent of ndbsize is outside the range);
RELOP_MIDCLEANUP_OPTION also puts cleanup option (-T) within Negative
Difference (before final complement) and Negative BinaryUnion (before
closure); added min,max,most recset size to stats output (sizes.dat);
added boundary case tests for negative Union, Intersection and
Difference; added compare_binary test case; expand record size no
longer sets the update flag and checks for minbits greater than
length; added flag to detect when minbits were specified (-m) verses
calculated; and this readme.

New in this version v.56: updated Negative Binary Union operation with
closure that uses complements (no 32-bit limitation); efficient
bitwise-or; added fourth new empty mode (-N) that starts with a single
don't care record; added deterministic negative pattern generate with
compile-time option; added command to unnegate a negative database
(-u) and output stats to sizes.dat, and avoid excess display output;
added command to compare 2 ndb complements (-Z); added Negative Set
Difference relational operation that uses complements; eliminated
leaks in relational operations (nsql.c) caused by using insert in
v.53; updated tests, and this readme.

New in this version v.55: updated Negative Binary Union operation
(32-bit limitation); new reversal algorithm; tests, and this readme.

New in this version v.54: lockfiles with input ndb names for parallel
testing; specify directory for testdata (-D); output size data for rel
operations; and updated this readme.

New in this version v.53: instead of returning an error, expand record
size for partial queries with project option when negative records
have insufficient bits specified; updated the relational algegbra
functions to use Insert, and define NPG to determine whether or not to
use Negative Pattern Generate (wo_npg is essentially like appending
directly unless there are insufficient bits present; still use append
for the project option; see ICDE paper for more details); and updated
this README.

New in this version v.52: Bypass incorrect query test before removing
a pattern; cleaned up recursive tree counters; moved unit tests in
runtime.c into new file test.c; moved default names into separate .h;
fixed rec_read so that it handles the last record without a newline;
changed test_clean to return zero for ndb's without any records
instead of an error; allow ascii ndb files to be interpreted in binary
mode (useful for relational algebra operations); and updated this README.

New in this version v.51: Added emptiness test (-e and -E commandline
args) for easy-to-reverse negative databases based on the
Davis-Putnam-Logemann-Loveland SAT solving algorithm; -E includes four
chase modes: all random, all popular, alternating random with popular,
and popular on success, random after backtracking. Other improvements
include: implemented a frequency sort used by the popular chase
method; changed Negative Binary Union operation to use emptiness test
results; added -M to get the max and min record size; check that a
partial query with projection option has at least 2 bits specified per
record in case the result has no solutions; negative Intersection and
negative Union address the universe (no negative records, i.e. all
positive solutions exist) and null boundary cases (all * records,
i.e. no positive solutions); added slow (but sure) implementations of
match and subsume queries to sanity check recursive versions.  Added
new tests, updated old tests to be more efficient about saving query
results, and updated this README.

Note: v.42 to v.50 were intermediate development versions.

New in this version v.41: Added the Negative Binary Union (bitwise
logical-or) relational operation using patterns; added more tests for
recset_split_match; and this README with examples of the Negative
BinaryUnion and using negative databases as powersets; added
 RELOPS_EFFICIENCY_STEP flag in nsql.h to turn off an undocumented
efficiency used by Negative Intersection and partial queries (without
the project option) for flexibility; removed hardcoded partial query
size tests in runtime.c.

FYI: Adding patterns should have worked before now, except that this
humbled programmer assumed them away by using subsumption (rather than
matching) for its default family-of query operations (i.e. query,
query size and split recset functions). For fully specified strings,
normal subsumption and matching are equivalent.  The query family of
functions based on subsumption are required by Negative Pattern
Generate, a reverse subsumption is used by cleanup and the new
Negative Binary Union, and now matching is needed to add patterns. To
avoid future confusion, no massive name changes are planned.

New in this version v.40: Added the ability to add/remove a pattern
(strings with don't care symbols); unit tests, and this README.

New in this version v.36: Added efficiency used for Selects in v.32 to
Intersections; added compiler directives to output count of records
saved with these efficiencies; fixed cnf header to output the density
ratio (r) correctly.

New in this version v.35: Singletons use probability q=.5 by default
to flip the bit (instead of 1 - q, where q=.618); singleton and empty
random SAT methods no longer pass extra bits variable when inserting a
record to avoid adding extra records that reduces the number of
records created by the algorithm (a bug since duplicate check was
added in v.30); output an error message when trying to open files that
do not exist.

New in this version v.34: Projection does not output records with all
don't care symbols in either cnf or ndb format; added projection tests
that test both cnf and ndb output in both ascii and binary; projection
tests for non-equal theta are disabled; corrected error message in
singleton test; fixed leak in recset_deleterec that hadn't been used
before; and finally, this README contains 20 command line examples
(see below).

Note: v.33 was skipped.

New in this version v.32: Theta Select operations are more efficient
in the size of the output than originally specified.

New in this version v.31: Project option (-P) eliminates in the output
the specified bit positions of the partial query input string (it
works only for -Q theta eq in ascii mode, and is available for other
theta for testing purposes); cnfformat does not output records with
all don't care symbols;

New in this version v.30: uses duplicate check in newndb.c for
singleton and random SAT empty ndb's in order to reach required record
count; fixes r default setup without ISCHARDQR compiler directive new
to v.29 for ISC paper; removes unnecessary rstree deletion during
recset expand; and, thanks to a new user, clarified command arguments
required to make a new ndb.

New in this version v.29: changes to support return query exit values
from main to support singleton collective wrapper; error.h defines all
the error values; added compiler directive to skip the length check
for singleton's and random SAT empty ndb's and use smaller r value to
support ISC paper, as well as allow 1000-bit record lengths.

New in this version v.28: changed the ndb file format to include the
binary/ascii mode and record length as the first line; old ndb formats
are read but no longer written.

New in this version v.27: negative relational operations, join,
intersection, cross product, union as specified in "Toward an Algebra
for Negative Databases"; changed record length variable to be in the
recset rather than in the runtime structure to accomodate the new
operations; wrote a list to perm parser for join conditions; new rec
copying functions, to merge bits and do bit_by_bit copies; added
command line options (-x,-j,-J,-y,-Y) to support new functions; script
language changes to support new functions (F,X,Y); tests for all new
functions.

New in this version v.26: negative theta select functions, with
commandline option (-Q), and script support (T).

New in version v.25: perm_random and random functions are more evenly
distributed.  Ran tests to plot singleton ndb size verses minimum
average complexity created with haixia's and fernando's algorithms.

New in version v.21: commandline and script options to create new
singleton negative databases using Haixia Jia's algorithm that she
describes in "Generating Hard Satisfiable Formulas by Hiding Solutions
Deceptively" (AAAI05); unit tests for the singleton.

New in version v.20: commandline and script options to select one of
three empty database algorithms: the default is per specification [2]
(-n or -N 0); a simpler one-bit option used for results in [3] (-N 1);
and a random SAT formula to produce harder starting databases with a
smaller record size (3) for longer length records (96+) and only an
epsilon chance of non-emptiness; unit tests for the random SAT
formula, and this README.


__Overview

The Negdb executable is the engine that processes commands to build
and update the negative database (RNDB.txt) in the current working
directory.  It assumes that friendly user interface features, such as
padding strings to the correct record length, are done beforehand.

Negative Databases is a research project.  Be aware that negative
databases have a tendency to grow rather large rather quickly.  At
this time, negdb operates on an internal representation of the
negative database in memory. This code has only been tested on FC3,
SuSe9.3, and SuSe10.2 Linux distributions.  Note that there is NO
WARRANTY for this software, but so far negdb has been good to us.



__Installation

This gzipped tar file holds a directory that contains: the Makefile,
README, COPYING, RNDB-test.txt (a negative database for regression
testing), RNDB-3673.test, and the following source code files:

rec.c, rec.h: responsible for ndb records
perm.c, perm.h: responsible for permutations of bit indexes
freq.c, freq.h: responsible for tracking bit frequencies
recset.c, recset.h: responsible for a set of ndb records
rstree.c, rstree.h: responsible for a tree of ndb records
negdb.c, negdb.h: responsible for ndb update algorithms
newndb.c, newndb.h: responsible for new ndb algorithms
nsql.c, nsql.h: provides negative SQL functions
easy.c, easy.h: responsible for easy-to-reverse ndb functions
runtime.c, runtime.h: responsible for ndb runtime parameters
test.c, test.h: ndb runtime tests
cleanresults.c, cleanresults.h: responsible for cleanup results
command_args.c, command_args.h: processes command line arguments
error.h : error codes
names.h : default ndb file names
main.c: NDB Main 
testmain.c: NDB Test Main


Default compilation will produce the negdb executable:
% make -k
 or
% make -k negdb

To run regression tests, compile with the following command:
% make -k runtests


The C Compiler Options (CCOPT) available in the Makefile are:

Choose one of the following four NPG variations to add *'s to negative records: 
1. NPG_ADD_RAND : orig negative pattern generate that adds non-essential
        bits back randomly
2. NPG_REMV_RAND : new negative pattern generate that removes
        non-essential bits randomly
3. NPG_REMV_BIAS : negative pattern generate that removes non-essential
        bits biased toward most frequent bits (default).
4. NPG_DETERMINISTIC : negative pattern generate that removes
        non-essential bits deterministically starting with leftmost bit 0.

Optionally, modify the default NPG usage for the following operations (v.63):
5. NPG_NONE_NEWNDB0 : no negative pattern generate in new ndb creation
        (mode 0) (default is with npg)
6. NPG_NONE_NEGADD : no negative pattern generate when "adding"
        positive recs to ndb (default is with npg)
7. NPG_NONE_NEGREMOVE : no negative pattern generate when "removing"
        positive recs from ndb (default is with npg)
8. NPG_NONE_UNNEGATE : no negative pattern generate for unnegate
        operation (default is with npg)
9. NPG_USE_NSQL_ALL : use negative pattern generate for all relational
        operations, except Intersect (default is without npg)
9. NPG_USE_NSQL_BU : use negative pattern generate for Binary Union relational
        operation (default is without npg)


Choose one of the following three UNNEGATE variations to permute
negative records (v.61): 
1. UNNEGATE_HAMMDIS_DETERMINISTIC, permutes unnegate input using
        next-descent hillclimbing, s.t. the hamming distance between negative
        records is reduced.
2. UNNEGATE_HAMMDIS_RANDOMHC, permutes unnegate input using random
        hillclimbing, s.t. the hamming distance between negative
        records is reduced.
3. UNNEGATE_HAMMDIS_NONE (default), unnegate input is not modified.

RECS2ADD randomly determines minimum record sets to insert, default is
        one set of 'all possible bit combinations' for the randomly selected
        extra bits.
USE_APPEND, unlike Insert, Append adds no extra bits or records
        (effects adds, removes, and cleanups).
USE_INSERT_NSQL_BU, Insert, unlike Append (the default for relational
        operations), may add extra bits and records (effects binary union
        only). 
USE_INSERT_NSQL_ALL, Insert, unlike Append (the default for relational
        operations), may add extra bits and records (effects all
        relational operations except Select EQ/NE and Intersect). (v.67)
SKIP_COMPRESS, doesn't try to do any compression.
SAVE_SORTED_NDB, prints ndb in sorted tree order (0,1,*).
MANAGED_GROWTH, disables expanding record size on build, and avoids
        adding redundant records (see also USE_APPEND); removes ndb
        records subsumed by new record (v.62); turns off compress
        option like SKIP_COMPRESS (v.63).
EXPAND_INPUT_NDB, enables expanding record size on build (overrides
        MANAGED_GROWTH for this aspect only).

NPG_VERBOSE_DEBUG for negative pattern generate debugging messages
PERM_VERBOSE_DEBUG for lots of permutation debugging messages
USE_RECSUBSUMED stats to stdout on record UNITS tested in
        rec_subsumed_query ("matching") [one-shot cmd only]
DISPLAY_RECCOUNT_DELETED for summary of select efficiency savings
        (used without MANAGED_GROWTH)
DISPLAY_RECCOUNT_DELETED_ALL for lots of select efficiency savings
        messages (per record) (used without MANAGED_GROWTH)

NORANDSATLENLIMIT skips the check for longer records on singletons and
        random SAT empty negative databases; uses smaller r value that
        can produce superfluous solutions, and even q. Support ISC paper.
ISCHARDQR to use the r and even q for hard singletons and random SAT empty
        as in the ISC paper.


The default for the Negative Set Sharing application is:
CCOPT = -O4 -D NPG_DETERMINISTIC -D SAVE_SORTED_NDB -D MANAGED_GROWTH -D NPG_NONE_NDBADD -D NPG_NONE_NEWNDB0 -D NPG_NONE_UNNEGATE -D NPG_USE_NSQL_BU


otherwise, use:
CCOPT = -O4 -D NPG_REMV_BIAS -D DISPLAY_RECCOUNT_DELETED


__Using Negdb

Negative databases start with an "empty" database of specified fixed
length records in the current working directory to which strings can
be added, removed and queried. Negative databases can also be
'cleaned' and 'morphed'. Negative databases have relational operations
for union, intersection, join, and cartesian product, set difference,
binary union, as well as selection criterion.

There are two modes for using negdb: the command-line one-shot
mode, and the script mode.

I. The command-line arguments are:

./negdb ?
Usage: negdb [-a string][-b  ][-c num][-C string ][-d  ][-D name][-e  ][-E num][-f name][-F format][-g num][-h num][-i string][-j name][-J format][-k num][-l num][-L  ][-m num][-M  ][-n  ][-N mode][-o name][-O format][-p num][-P  ][-q string][-Q theta][-r string][-s seed][-t num][-T num][-u  ][-v  ][-w name][-x op][-y list][-Y list][-z num][-Z mode ][-?  ]
	-a string : add positive record
	-b   : binary mode, default is ascii letters
	-c num : clean up where 0 insures no growth, 1 to morph (use with -t)
	-C string  : copy the records in input file that are matched and coalesced with the input string---a query for complements; the resulting output file is named by -o in -O format, default is partial-ndb.txt (see also -P and -k option) 
	-d   : demo on web
	-D name : test data directory name, defaults to current working dir
	-e   : returns 0 if an "easy" ndb (where -M is at most 2) is "empty"
	-E num : num specifies method to use to determine if an "easy" ndb is "empty" (see -e), where: 0 is all_random, 1 is all_popular, 2 alternates popular and random, 3 uses popular on success and random after backtracking, default is mode 0
	-f name : ndb filename, default ndb formats is RNDB.txt, default cnf is RNDB.cnf
	-F format : ndb file format <ndb|cnf>, default is ndb
	-g num : extra bits to insert, default is 0
	-h num : high water mark for adds, default is unlimited
	-i string : new negative database with deceptively q-hidden solutions (use separate -i for each string); requires record bit length (-l)
	-j name : second read-only ndb filename, default ndb formats is RNDB2.txt, default cnf is RNDB2.cnf
	-J format : second ndb file format <ndb|cnf>, default is ndb
	-k num : minimum specified bits in records, as in k-SAT; attempts to compress result(see also -m)
	-l num : record bit length (1 letter == 8 bits)
	-L   : returns maximum record bit length
	-m num : minimum specified bits in records (recsize); 0 uses smallest recsize in ndb (see also -k)
	-M   : returns maximum and minimum specified bits in records of current ndb (recsize)
	-n   : new empty negative database with absolutely no solutions per spec; requires record bit length (-l)
	-N mode : new empty negative database, 0 for absolutely no solutions per spec, 1 is one-bit simplification, 2 is for powerset solutions, 3 is random SAT formula with epsilon probability of emptiness when used with 96-bit minimum record length, 4 is basic all *'s; requires record bit length (-l)
	-o name : partial query and optional secondary output filename, default partial ndb is partial-ndb.txt, default partial cnf is partial-ndb.cnf
	-O format : partial/secondary output file format <ndb|cnf>, default is ndb
	-p num : set recsize to k when the number of records with <= k specified bits is < p% of NDB (and -m unspecified/zero), default is the smallest record size
	-P   : the Project option eliminates from the output the specified positions found in the partial query -q input string when -Q theta is eq, or -C 
	-q string : query for a string (no -Q and no *'s in the string produces a yes/no membership answer; see -P option for strings with *'s) 
	-Q theta : theta select records for -q query constant, where theta is positive <bool,eq,ne,lt,le,gt,ge>; bool is the default for fully specified -q membership queries; for partially specified -q queries, the default is eq (use the project option -P to eliminate the non-* positions; the resulting ndb is output to file named by -o in -O format
	-r string : remove positive record
	-s seed : seed
	-t num : do cleanup tests this number of times; use with -c
	-T num : do post-cleanup tests as % (no decimal points) of ndb size times, minimum 100, maximum 3000 (use with other commands, -a, -r, -x, -u)
	-u   : un-negate ndb (-f file), to -o file, default is un_NDB.txt
	-v   : version
	-w name : while 1, execute commands in this file
	-x op : relational operation on 2 NDBs (-f and -j) [I<ntersection>|U<nion>|J<oin>|C<rossProduct>|B<inaryUnionCDB>][S<tarNegBinaryUnion>][D<ifference>|R<elevanceDB>][O<nlyInFirstDB>]
	-y list : join condition 1, comma delimited bit indexes/letters, start at 0, dash for inclusive range
	-Y list : join condition 2, comma delimited bit indexes/letters, start at 0, dash for inclusive range
	-z num : size test iteration
	-Z mode  : 3 expands and compares two postive or negative sets  (-f and -j) for equivalence; 2 compares two complemented NDBs for identity match; returns 0 if SAME
	-?   Help is here


EXAMPLES:

1. Create a new empty database for 3 ascii letters per record:

./negdb -n -l 24


2. Create a new empty database with 3 bits per record in binary mode:

./negdb -n -l 3 -b


3. Create a new empty database for 8 ascii letters per record, specify
3 minimum bits and allow 1 extra bit per record (use -k for compressed
result):

./negdb -n -l 64 -m 3 -g 1      # without compressed result
./negdb -n -l 64 -k 3 -g 1      # with compression


4a. Create a new empty database for longer records (12 letters) using
Random SAT method:

./negdb -N 3 -l 96 

4b. Create a new empty database with all *'s:

./negdb -N 4 -l 96 


5. Create a new singleton database for longer records using Haixia's
Formula:

./negdb -i "hello world " -l 96

5a. Create a new database using Haixia's Formula with two hidden
solutions:

./negdb -i "hello world " -i "good-bye all" -l 96


6. Same as example 5, except output the new singleton to a secondary
output file named 'hw.cnf', in cnf format:

./negdb -i "hello world " -l 96 -o hw.cnf -O cnf


7. Simple membership query (on RNDB.txt created in example 5 and 6):

./negdb -q "hello world "


8. Membership query from alternative cnf input file created in example 6:

./negdb -q "hello world " -f hw.cnf -F cnf


9. Add two positive records to a 3 letter negative database (RNDB.txt):

# create a new empty ndb (same as example 1) using seed 123456789 
./negdb -n -l 24 -s 123456789

# add the positive data
./negdb -a "abc"
./negdb -a "xyz"

# and verify

./negdb -q "abc"
./negdb -q "xyz"


10. Remove a positive record from the 3 letter negative database
(RNDB.txt from example 9):

./negdb -r "xyz"

# and verify "xyz" is gone, but "abc" remains:

./negdb -q "xyz"
./negdb -q "abc"


11. Cleanup a negative database (from example 10) 1000 times without
increasing the number of records:

./negdb -c 0 -t 1000

# and verify "abc" is still present:

./negdb -q "abc"

# cleanup immediately after the remove (example 10) 10% of
the size of the resulting ndb (min 100, max 3000) times:
./negdb -r "xyz" -T 10

[note: see example 26 below for another option.]


12. Morph a negative database (from example 10 or 11) 1000 times and
change the record size to 5-bits specified:

./negdb -c 1 -t 1000 -m 5

# and verify "abc" is still present:
./negdb -q "abc"


13. Select, theta equal, from default input (RNDB.txt from above
examples, or repeat example 9) where resulting negative database is
partial-ndb.txt in ndb format with 24-bit record length:

# setup RNDB.txt as in example 9:
./negdb -n -l 24
./negdb -a "abc"
./negdb -a "xyz"

# select all the records where a is the first letter:
./negdb -q "a**" -Q eq

# and verify "abc" is present:
./negdb -q "abc" -f partial-ndb.txt -F ndb

# also, note the "aac" and "aba" are still not present:
./negdb -q "aac" -f partial-ndb.txt -F ndb
./negdb -q "aba" -f partial-ndb.txt -F ndb


14. Projection option is the same as example 13, except the output
record length is only 16 bits (the two * positions)---note, this only
applies to theta equal:

./negdb -q "a**" -Q eq -P -o bc.cnf -O cnf

# and verify results:

./negdb -q "bc" -f bc.cnf -F cnf

# equivalent results using the -C command with -P (v.65.1):
./negdb -C "a**" -P -o bc.cnf -O cnf


15. Select, theta greater-than, from default input (RNDB.txt from
examples above) where resulting negative database (partial-ndb.cnf) is in
cnf format:

./negdb -q "*a*" -Q gt -O cnf

# and verify results:

./negdb -q "abc" -f partial-ndb.cnf -F cnf


16. Join two negative databases using join conditions where bits 2 and
3 in the first rndb (RNDB1.txt with record length 8 bits) correspond
to the first two bits in the second negative database (RNDB2.txt with
record length 4 bits), the output is the default RNDB3.txt, also in
ndb format:

# set up the first ndb (note: "a" equals 01100001 in binary):
./negdb -n -l 8 -m 3
./negdb -a "a" -o RNDB1.txt

# set up the second ndb in binary mode:
./negdb -n -l 4 -b
./negdb -a "1000" -o RNDB2.txt

# join the two negative databases
./negdb -x J -y 2,3 -Y 0-1 -f RNDB1.txt -j RNDB2.txt

# and verify results:
./negdb -q "0110000100" -f RNDB3.txt 


17. Join conditions same as example 16, except the negative databases
are in cnf format and named (note: with input in cnf format, binary
mode must be explicitly specified with -b):

# set up the first ndb (note: "a" equals 01100001 in binary):
./negdb -n -l 8 -m 3
./negdb -a "a" -o first.cnf -O cnf

# set up the second ndb in binary mode:
./negdb -n -l 4 -m 3 -b
./negdb -a "1000" -o second.cnf -O cnf

# join the two negative databases
./negdb -x J -y 2,3 -Y 0-1 -f first.cnf -F cnf -j second.cnf -J cnf -o results.txt -O ndb -b

# and verify results:
./negdb -q "0110000100" -f results.txt 


18. Cartesian Product of the two negative databases (created in example
17):

./negdb -x C -f first.cnf -F cnf -j second.cnf -J cnf -o result.cnf -O cnf

# and verify in binary mode:
./negdb -q 011000011000 -f result.cnf -F cnf -b


19. Intersection of two negative databases with the same record
length, the first in ndb format, the second in cnf format (created in
example 17), and the result in cnf format:

# set up the first ndb in binary mode:
./negdb -n -l 4 -m 3 -b
./negdb -a "1000" -o first.ndb -O ndb
./negdb -a "1001" -f first.ndb -o first.ndb -O ndb

# set up the second ndb in binary mode: (note: same as the second ndb from example 17.)
./negdb -n -l 4 -m 3 -b
./negdb -a "1000" -o second.cnf -O cnf

# intersect the two negative databases:
./negdb -x I -f first.ndb -F ndb -j second.cnf -J cnf -o result.cnf -O cnf

# and verify in binary mode:
./negdb -q "1000" -f result.cnf -F cnf -b


20. Union of two negative databases with the same record
length (from example 19):

./negdb -x U -f first.ndb -F ndb -j second.cnf -J cnf -o result.cnf -O cnf

# and verify in binary mode,
./negdb -q "1000" -f result.cnf -F cnf -b
./negdb -q "1001" -f result.cnf -F cnf -b


21. Difference of two negative databases with the same record
length (from example 19):

./negdb -x D -f first.ndb -F ndb -j second.cnf -J cnf -o result.cnf -O cnf

# and verify, in binary mode, that "1001" is the only member in the
# first not in the second:
./negdb -q "1001" -f result.cnf -F cnf -b


22. The Negative Binary Union with closure (a logical-or of bits of
two negative databases) with the same record length in ndb format:

# set up the first ndb in binary mode, length 3-bits:
./negdb -n -l 3 -m 2 -b
./negdb -a "100" -o first.ndb

# set up the second ndb in binary mode, length 3-bits:
./negdb -n -l 3 -m 2 -b
./negdb -a "001" -o second.ndb

# binary union the two negative databases:
./negdb -x B -f first.ndb -j second.ndb -o result.ndb

# and verify the only solution is the logical-or of the bits:
./negdb -q "101" -f result.ndb


23. Power Set example: Imagine that your DB's were almost fully
populated, and you really don't want to have to "add" every positive
string (because that would take too long) in order to find their
union. Instead, you'd like to "remove" the members that are
missing, from the full powerset NDB (note: a full NDB == empty DB).

let,
DB1 = { 010,100,110,111}
DB2 = { 001,010,101,110}

where the positive union would be:
DB1 U DB2 = {  001,010,100,101,110,111 } 


step 1. make DB1:

# make an new full "binary" NDB 3-bits long:
% ./negdb -n -l 3 -b

# "remove" each of the strings missing from DB1 (note, we still use -a):
% ./negdb -a 001
% ./negdb -a 011
% ./negdb -a 101
% mv RNDB.txt to DB1.txt


step 2. make DB2:

# make another new full "binary" NDB 3-bits long:
% ./negdb -n -l 3 -b

# "remove" each of the strings missing from DB2 (note, we still use -a):
% ./negdb -a 100
% ./negdb -a 011
% ./negdb -a 111
% mv RNDB.txt to DB2.txt


step 3. form DB3, the negative Intersection of DB1 and DB2:

#  DB1 \I DB2 into DB3.txt
% ./negdb -f DB1.txt -j DB2.txt -o DB3.txt -x Intersection

# the result is a "negative" database with more records: {11*, **0,
*01, *10, 00*, 0*0} (we'll ignore the 000's in the next step).

step 4. query the results:

# querying DB3 for each of the strings in DB1 U DB2, we get "not in DB,
# in NDB" results, the EXACT OPPOSITE!!  only the 011 query returns
# "in DB, not in NDB" because it is the only member NOT in the UNION
# of DB1 and DB2.

$ ./negdb -q 011
[returns FALSE]

# [note: alternatively, start with a blank NDB, and "add" each missing
# string by removing it with -r (the missing records are appended
# without *'s), then proceed as normal without reversing query
# results.]


24. Compare example: 0 result means the same; the exit status contains the result.
(Use Mode 3 instead of Modes 0 or 1, v.72.8)
#Mode 0 complements the ndb's before comparing (v.65)
$ ./negdb -Z 0 -f ndb1 -j ndb2
$ echo $?

# compare RNDB.txt with ndb2:
$ ./negdb -Z 0 -j ndb2 

#Mode 1 compares the two ndb's directly (v.65)
$ ./negdb -Z 1 -f un_ndb1 -j un_ndb2
$ echo $?


25. Complement example: (un-negate) a negative database. 
# default input filename, RNDB.txt and default output filename, un_NDB.txt:
$ ./negdb -u 

# change input and output filenames, and format in the last case:
$ ./negdb -u -f ndb -o notndb.txt
$ ./negdb -u -f ndb.cnf -F cnf -o notndb.cnf -O cnf


26. Compress the result examples:
# try to compress all negative records down to 3 specified bits
$ ./negdb -a "101010111110" -k 3

# try to compress result down to the smallest number of specified bits in input ndb
$ ./negdb -a "101010111110" -k 0

# try to compress result as much as possible
$ ./negdb -a "101010111110" -k 1

# try to get all negative records to have at least 3 specified bits (no compression)
$ ./negdb -a "101010111110" -m 3

# try to get all negative records to have at least the smallest number
# of specified bits in input ndb (no compression)
$ ./negdb -a "101010111110" -m 0


27. Use Relevance Relational Operation to extract the records in the
first recset that have bits set to 1 in common with the second recset
[Note: Relevance assumes we are working in a fully specified
un_negated form; if there are *'s in the input use Negative Union
instead (see next example).]:

Step 1: set up DB1:
./negdb -N 2 -l 3 -b
./negdb -r 001
./negdb -r 100
./negdb -r 010
./negdb -r 101
cp RNDB.txt DB1

Step 2: set up DB2:
./negdb -N 2 -l 3 -b
./negdb -r 101
cp RNDB.txt DB2

Step 3: perform Relevance operation
./negdb -x R -f DB1 -j DB2

Step 4: verify results contains {001,100,101) in RNDB3.txt
cat RNDB3.txt

Step 5: perform Relevance operation with the sets in reverse input order:
./negdb -x R -f DB2 -j DB1

Step 6: verify results contains only {101) in RNDB3.txt; note, it's
        DIFFERENT from Step 4.
cat RNDB3.txt


28. Use Negative Union Relational Operation to extract the records in
the first recset that have bits set to 1 in common with the second
recset [Note: assumes we are working in a un_negated (positive)
form.]:

Step 1: set up cDB1:
./negdb -N 2 -l 3 -b
./negdb -r 001
./negdb -r 100
./negdb -r 010
./negdb -r 101 -k 1
cp RNDB.txt cDB1

Step 2: set up cDB2:
./negdb -N 2 -l 3 -b
./negdb -r "1**"
./negdb -r "**1" 
cp RNDB.txt cDB2

Step 3: perform Negative Union operation
./negdb -x U -f cDB1 -j cDB2

Step 4: verify results contains {001,100,101) in RNDB3.txt
cat RNDB3.txt

Step 5: perform Negative Union operation with the sets in reverse input order:
./negdb -x R -f cDB2 -j cDB1

Step 6: verify results are the same as in Step 4.
cat RNDB3.txt

29. Use Relational Operator "OnlyInFirstDB" to perform set difference
on a fully specified positive database.

Step 1: set up DB1:
./negdb -N 2 -l 3 -b -m 3
./negdb -r 001
./negdb -r 101
cp RNDB.txt DB1

Step 2: set up DB2:
./negdb -N 2 -l 3 -b -m 3
./negdb -r 001
./negdb -r 010
cp RNDB.txt DB2

Step 3: perform SetDiff operation
./negdb -x O -f DB1 -j DB2

Step 4: verify results contains {101) in RNDB3.txt
cat RNDB3.txt



II. The script mode reduces the number of I/O operations for
consecutive updates. Here is the single-letter scripting language it
uses.  You'll notice that it has a similar syntax to the command-line
interface, but is a little different, and does not provide the
complete functionality.  The command-line argument (-w) is used to
specify the filename of the script to be parsed as follows:

Astring : add positive record
B[0|1|]: 0 or blank clears binary mode; 1 sets binary mode
Cx : clean x times (Tau is zero --- the number of NDB records will not increase)
D[0|1|2|3]name : database name, where 0 is the name of the test
directory, 1 is file name of RNDB, 2 is file name of RNDB2, and 3 is
file name of output file RNDB3 or partial-ndb; default is RNDBx.txt in
ndb format (F)
Ex : extra bits to add to a record
F[1|2|3][ndb|cnf] : set NDB file format, where 1 is file format of
RNDB, 2 is format of RNDB2, and 3 is format of output file RNDB3 or
partial-ndb\n"); default is ndb text format
Hx : high water mark for record adds is x; designed to (insecurely)
        defer "expensive" add operations when the number of records in the
        deleted cache exceeds x; default is no limit [experimental]
Istring : new negative database with a single record
Kx : minimum bits in record is x (default is a random number between
        1 and log2(L) for new empty databases, or minimum record size read in
        from file unless P is used); does NOT attempt to compress result (v.72.7)
Lx : record length in bits is x
Mx : morph x times (Tau is one).
Nx : new empty negative database: 0 or none (default) according to
        spec [2]; 1 the simpler one-bit version; 2 is for powerset
        solutions, 3 is random SAT formula with epsilon probability of
        emptiness when used with 96-bit minimum record length, 4 is
        basic all *'s; requires record bit length (L) set first
O : open negative database
Px : adaptively sets the minimum record size after the next 'W'rite
        and 'O'pen commands when K is zero; designed to adjust the minimum number of
        specified bits per record based on the greatest record size where the
        accumulated total number of records of that size does not
        exceed x percent of the total database size [experimental]
Qstring : query for positive record that matches string
Rstring : remove positive record
Sx : set seed to x
T[bool|eq|ne|lt|le|gt|ge] : theta select records for Query string; the
        resulting ndb is output to partial-ndb.txt or partial-ndb.cnf
        (see X) 
U : save NDB and check bit frequency
W : write NDB to disk and output the new size 
X[Join|Intersection|Union|CrossProduct|BinaryUnion|Difference] :
        specify relational operator
Y[a|b]list : specify join conditions, where a is join cond 1, b is
        join cond 2, and list is comma-delimited ordered bit
        indexes/letters\n");
Ziteration : specify initial iteration count for sizes.dat

# : comments (nop)


__Contact

This (and the papers) should be enough to get started.  Please email
me at esa@ackleyshack.com or elenas@cs.unm.edu if you have any
problems or questions about this code.  Also, with no obligation, I
would appreciate a copy of any interesting modifications you might
make to this code.

Enjoy!

  --elena s ackley
    esa@ackleyshack.com


__Licensing

This file and the negdb-0.72 distribution Copyright (c) 2008
ackleyshack,LLC and Copyright (c) 2004-2008 Elena S. Ackley and the
Regents of the University of New Mexico. Negdb is licensed under the
GNU General Public License (GPL) (See the enclosed COPYING file for
details).

last updated: 
Fri May  9 09:02:56 2008 

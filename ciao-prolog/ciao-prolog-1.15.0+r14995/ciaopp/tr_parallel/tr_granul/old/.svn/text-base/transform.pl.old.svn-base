:- module(transform, [
                      create_output_ann_program/7,
                      mark_parallel_threads_0/2
		     ],
	             [assertions]).
% NOTE: it is used by input_sizes. 
% :- use_module(transform, [mark_parallel_threads_0/2]).

% ciao library:
:- use_module(library(sort), [sort/2]).
:- use_module(infercost(symtable),[find_symbol_field/3]). % include instead?
:- use_module(library(vndict), [complete_dict/3, create_dict/2]).

% ciaopp library:
:- use_module(infercost(init),[clause_type/2]).

% Own library
:- use_module(trans_dyn, [dyn_create_entry_point/4]).

% Not sure if it is needed.
%:- use_module(dynamic_size,[generate_initial_litnodes/8]).

%% If a predicate is of sequential type then its sequential name is the same
%% as the original. If is of type do_test or supply_sizes then the sequential
%% version has the suffix "s_" (provided that there are no conflicts with 
%% other predicates in the program). 

clas_annotate([],_,_,_,_).
clas_annotate([Comp|SCCG],NT,ST,GT,PE):-
	clas_annotate_comp(Comp,NT,ST,GT),
	clas_annotate(SCCG,NT,ST,GT,PE).

% Warning. clas_annotate_comp_1 is not implemented!
% Currently the predicate is called with PE bound to the atom noname
% so that clas_annotate_comp_2 is always called.  

 %% clas_annotate_comp(Comp,NT,ST,GT,PE):-
 %% 	(member(PE,Comp)->
 %% 	        clas_annotate_comp_1(Comp,Comp,NT,ST,GT,PE);
 %% 	        clas_annotate_comp_2(Comp,Comp,NT,GT, ST)).

clas_annotate_comp(Comp,NT,ST,GT):-
      clas_annotate_comp_2(Comp, Comp, NT, GT, ST).

%%%--------------------------------------------------------------------------
% Annotates a component that no contains the entry point.
% Test if the first predicate of a component is of type sequential. If it is, 
% then all the predicates in the component are sequential and nothing is done.
%%%--------------------------------------------------------------------------

clas_annotate_comp_2([], _, _, _, _).
clas_annotate_comp_2([Pred|_], Com, NT, GT, ST):-
       find_gran_field(GT, Pred, type, Type),
       (Type \== sequential ->
           clas_annotate_comp_2(Com, NT, GT, ST);
           true).

clas_annotate_comp_2([], _, _, _).
clas_annotate_comp_2([Pred|Comp], NT, GT, ST):-
        find_gran_field(GT, Pred, type, Type),
        clas_annotate_pred_2(Type, Pred, NT, GT, ST),
        clas_annotate_comp_2(Comp, NT, GT, ST).

 %% A predicate is of do_test type if it does perform some 
 %% spawning. 
 %% 
 %% A predicate is of supply_sizes type if it does not perform any
 %% spawning test but has to be annotated with extra arguments standing
 %% for the sizes of input arguments that are needed by some literals
 %% in the body. The predicate simply pass the sizes to these literals.

% Warning: curretly only clas_annotate_pred_2(do_test, Pred, NT, GT, ST)
% has been tested with benchmarks.
clas_annotate_pred_2(supply_sizes, Pred, NT, GT, _):-
	clas_annotate_pred_supp_siz(Pred, NT, GT).
clas_annotate_pred_2(do_test, Pred, NT, GT, ST):-
	clas_annotate_pred_do_test(Pred,NT,GT, ST).

clas_annotate_pred_supp_siz(Pred,NT,GT):-
        find_gran_field(GT,Pred,par_clauses,Clauses),
        find_name_field(NT,Pred,actual_sizes,ASizeRel),
   % find_gran_field(GT,Pred,sizes,ASizeRel), % Size relations from CASLOG
        add_sizes_clauses(Clauses,ASizeRel,NT,GT,AClauses),
        insert_gran_field(GT,Pred,ann_clauses,AClauses).

 %% clas_annotate_pred_do_test(+Pred, +NT, ?GT, +ST)
 %% Annotates a predicate of type do_test.
 %% ASizeRel: are actual size relations between argument positions in the predicate.
 %%           Is an open list of lists, one per clause.
clas_annotate_pred_do_test(Pred, NT, GT, ST):-
	find_gran_field(GT, Pred, par_clauses, Clauses),
        find_name_field(NT, Pred, actual_sizes, ASizeRel),
%       find_name_field(NT,Pred,test,TimeFunc),
        find_symbol_field(ST, Pred, time, TimeFunc),
%       find_gran_field(GT, Pred, sizes, ASizeRel), % Size relations from CASLOG
        add_test_sizes_clauses(Clauses, ASizeRel,TimeFunc, ST, NT, GT,
                               AClauses),
        insert_gran_field(GT, Pred, ann_clauses, AClauses).

%
% Annnotates clauses for a predicate with "supply_sizes" type by adding 
% the expresions that compute input argument sizes for literals in the body,
% and renaming these literals.
% 

add_sizes_clauses(Clauses,_,_,_,_):-
	var(Clauses).
add_sizes_clauses(Clauses,[ASizeRel|SList] , NT, GT, [AClause|Alist]):-
	nonvar(Clauses),
	Clauses = [Clause|CList],
	add_sizes_clause(Clause,ASizeRel,NT,GT,AClause),
	add_sizes_clauses(CList,SList,NT,GT,Alist).


add_sizes_clause(Clause,ASizeRel,NT,GT,AClause):- 
	clause_type(Clause,Type),
	add_sizes_clause(Type,Clause,ASizeRel,NT,GT,AClause).
add_sizes_clause(3,Clause,_,NT,_,AClause):- 
	  functor(Clause,F,A), 
          find_name_entry(NT,F/A,st(_,_,GranName/_,InArList,_,_)),
	  transform_head(GranName,InArList,Clause,AClause,_).
%         length(InArList,NumInputArg),
%	  add_sizes_fact(GranName,NumInputArg,Clause,AClause).

add_sizes_clause(2,Clause,ASizeRel,NT,GT,(TranHead :- TranBody)):- 
	arg(1,Clause,Head),
	arg(2,Clause,Body),
	functor(Head,Name,Arity),
	find_name_entry(NT,Name/Arity,st(_,_,GranName/_,InArList,_,_)),
	transform_head(GranName,InArList,Head,TranHead,HeadVars),
	transform_body(Body,NT,GT,HeadVars,ASizeRel,TranBody).

transform_body((GoalA,GoalB),NT,GT,HeadVars,ASizeRel,(TranGoalA,TranGoalB)):-!,
	transform_body(GoalA,NT,GT,HeadVars,ASizeRel,TranGoalA),
	transform_body(GoalB,NT,GT,HeadVars,ASizeRel,TranGoalB).
transform_body(Lit,NT,GT,HeadVars,ASizeRel,AnnLit):-
	annotate_lit(GT,NT,Lit,HeadVars,ASizeRel,AnnLit).

%
% Annnotates clauses for a predicate of "do_test" type by adding a test
% on the time  function for this predicate and the expresions that compute 
% input argument sizes for literals in the body.
% 

add_test_sizes_clauses(Clauses, _, _, _, _, _, _):-
	var(Clauses), 
        !.
add_test_sizes_clauses(Clauses, [ASizeRel|SList], TimeFunc, ST, NT, GT,
                       [AClause|Alist]):-
	nonvar(Clauses),
	Clauses = [Clause|CList],
	add_test_sizes_clause(Clause, ASizeRel, TimeFunc, ST, NT, GT, AClause),
	add_test_sizes_clauses(CList, SList, TimeFunc, ST, NT, GT, Alist).

add_test_sizes_clause(Clause, ASizeRel, TimeFunc, ST, NT, GT, AClause):- 
	clause_type(Clause, Type),
	add_test_sizes_clause(Type, Clause, ASizeRel,TimeFunc, ST, NT,
                              GT,AClause).

% A fact
add_test_sizes_clause(3,Clause,_,_,_ST,NT,_,AClause):- 
	  functor(Clause, F, A), 
          find_name_entry(NT, F/A, st(_,_,GranName/_,InArList,_,_)),
	  transform_head(GranName, InArList, Clause, AClause, _).
%         length(InArList,NumInputArg),
%	  add_sizes_fact(GranName,NumInputArg,Clause,AClause).
% A rule
add_test_sizes_clause(2, (Head:-Body), ASizeRel, TimeFunc, ST, NT, GT,
                      (TranHead:-TranBody)):- 
	functor(Head, Name, Arity),
	find_name_entry(NT, Name/Arity, st(_,_,GranName/_,InArList,_,_)),
	transform_head(GranName, InArList, Head, TranHead, HeadVars),
	transform_test_body(Name/Arity, Body, ST, NT, GT, HeadVars,
                            ASizeRel, TimeFunc, TranBody).

% Warning TranBody is not flattened. PLG

%% Old 13 Oct. PLG
% warning! Check that the transformed literal is before the thread.
transform_test_body(Pred, Body, ST, NT, GT, HeadVars, ASizeRel,
                    TimeFunc, TranBody):-
       mark_parallel_threads_0(Body, Threads),
       transform_threads_0(Threads, Pred, NT, GT, HeadVars, ASizeRel,
                            TimeFunc, ArgPosDict, TranBody1),
       get_input_arglist_from_st(ST, Pred, InSizes),  
       % was
       % get_insizes_from_head_vars(HeadVars, ArgPosDict, InSizes),
       get_needed_body_sizes(ArgPosDict, NeededBodySizes),
       seq(Body,SeqBody),
       flat_seq_body(SeqBody,FlatBody),
       % Check whether ASizeRel is in the right format.
       generate_initial_litnodes(NeededBodySizes, ASizeRel, InSizes, 
                                 FlatBody, GT, ST, LitNodes, IrTrans),
       
       transform_dyn_literals_0(LitNodes, FlatBody, TranBody1,
                                TranBody, ArgPosDict),
       transform_dyn_predicate(IrTrans, GT).




get_insizes_from_ArgPosDict_0(ArgPosDict, SNeededHeadSizes):-
  get_insizes_from_ArgPosDict(ArgPosDict, NeededHeadSizes),
  sort(NeededHeadSizes, SNeededHeadSizes).

get_insizes_from_ArgPosDict(ArgPosDict, []):-
   var(ArgPosDict),
   !.
get_insizes_from_ArgPosDict(ArgPosDict, NeededHeadSizes):-
   nonvar(ArgPosDict),
   ArgPosDict = [($(LitNum, _ArgNum), _Var)|Rest],
   LitNum =\= 0, 
   !,
   get_insizes_from_ArgPosDict(Rest, NeededHeadSizes).
get_insizes_from_ArgPosDict(ArgPosDict, [ArgNum|NeededHeadSizes]):-
   nonvar(ArgPosDict),
   ArgPosDict = [($(LitNum, ArgNum), _Var)|Rest],
   LitNum =:= 0,
   get_insizes_from_ArgPosDict(Rest, NeededHeadSizes).

 %% get_insizes_from_head_vars(+HeadVars, ?ArgPosDict, -InSizes)
 %% HeadVars: Head variables.
 %% ArgPosDict: argument position dictionary. 
 %% InSizes: list with the input argument numbers (ordered).
 %% Description: creates Insizes and actualize ArgPosDict with the input
 %%              head positions.

get_insizes_from_head_vars(HeadVars, ArgPosDict, InSizes):-
   get_insizes_from_head_vars_0(HeadVars, ArgPosDict, InSizes1),
   sort(InSizes1, InSizes). 

get_insizes_from_head_vars_0([], _ArgPosDict, []).
get_insizes_from_head_vars_0([(ArgNum, HeadVar)|Rest], ArgPosDict, [ArgNum|InSizes]):-
     insert_dyn_size_info($(0, ArgNum), ArgPosDict, HeadVar),
     get_insizes_from_head_vars_0(Rest, ArgPosDict, InSizes).


 
% create_dynsize_predicate(+OutSizes, +Pred, -Label, +ST, ?GT)
create_dynsize_predicate(OutSizes,Pred,Label,ST,GT):-
      find_irreducible_transformation((Pred, OutSizes),GT,ST,
                                      it(Label,IrTrans)),
      transform_dyn_predicate(IrTrans,GT).



create_string(L,S):-
  create_code_list(L, CL),
  name(S, CL).



    


% Not used at moment.
% transform_dyn_head(CompSizes, TrPred, Label, Head, TrHead,
%                   CompSizeExp, Last, ArgPosDict):-
%    % create_litnum_arg_pos_dictionary(Label, 0, ArgPosDict),
%    transform_dyn_atom(Label, 0, Head, TrPred, TrHead, ArgPosDict), 
%    create_required_size_comp_expressions(CompSizes,CompSizeExp,
%                                          Last, ArgPosDict).

% Not neccessary at moment.
% create_litnum_arg_pos_dictionary(Label, LitNum, ArgPosDict):-
%    Label = label(_Pred, InSizes, OutSizes), 
%    create_arg_pos_dictionary(InSizes, LitNum, ArgPosDict), 
%    create_arg_pos_dictionary(OutSizes, LitNum, ArgPosDict).

      
create_arg_pos_dictionary([], _LitNum, _ArgPosDict).
create_arg_pos_dictionary([ArgNum|RArgNums], LitNum, ArgPosDict):-
   insert_dyn_size_info($(LitNum,ArgNum), ArgPosDict, _Var),
   create_arg_pos_dictionary(RArgNums, LitNum, ArgPosDict).




create_dynsize_literal(DynLiteral, ArgPosDict, TrDynLiteral,DynPred/A,TrDynPred/NumArgs):-
       number_of_items(ArgPosDict, NumExtraArgs),
       functor(DynLiteral,DynPred,A),
       NumArgs is A + NumExtraArgs,
       name(DynPred,NF),
       append("tr_",NF,NewName),
       name(TrDynPred, NewName),
       functor(TrDynLiteral,TrDynPred,NumArgs),      
       put_Normal_Arguments(TrDynLiteral,DynLiteral,A),
       A1 is A + 1,
       put_output_dynsize_vars(A1, ArgPosDict, TrDynLiteral).


get_set_of_output_args(ArgPosDict, Args):-
     get_set_of_output_args_1(ArgPosDict, Args1),
     sort(Args1, Args).

get_set_of_output_args_1(ArgPosDict, []):-
     var(ArgPosDict),
     !.
get_set_of_output_args_1(ArgPosDict, [ArgNum|RArgs]):-
     nonvar(ArgPosDict),      
     ArgPosDict = [($(_,ArgNum),_Var)|Rest],
     get_set_of_output_args_1(Rest, RArgs).

 %% put_output_dynsize_vars(+ArgNum, +ArgPosDict, ?TrDynLiteral)
 %% ArgNum: 
 %% ArgPosDict: argument position dictionary. Is an open list with the format:
 %% [($(LitNum1, ArgNum1), Var1), ..., ($(LitNumN, ArgNumN), VarN)|_] 
 %% $(LitNum1, ArgNum1) is an argument position in a clause.
 %% the argument position dictionary is an open list with the format:
 %% [($(LitNum1, ArgNum1), Var1), ..., ($(LitNumN, ArgNumN), VarN)|_] 
 %% TrDynLiteral:
 %% Put the variables denoting the computed size of the argument in
 %% the transformed literal.

put_output_dynsize_vars(_ArgNum, ArgPosDict, _TrDynLiteral):-   
     var(ArgPosDict),
     !.
put_output_dynsize_vars(ArgNum, ArgPosDict, TrDynLiteral):-   
     nonvar(ArgPosDict),      
     ArgPosDict = [(_,Var)|Rest],
     arg(ArgNum,TrDynLiteral,Var), 
     NewArgNum is ArgNum + 1,
     put_output_dynsize_vars(NewArgNum,Rest,TrDynLiteral).

get_literal_number_to_tramsform_dynsize(ArgPosDict, Number):-
     nonvar(ArgPosDict),      
     ArgPosDict = [($(Number,_),_Var)|_].



 %% transform_threads([Thread],Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,OuThread):-
 %%      !,
 %%      transform_one_thread(Thread,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,OuThread).
 %% transform_threads([Thread|ResThreads],Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,
 %%         (OuThread1,OuThread2)):-
 %%      transform_one_thread(Thread,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,OuThread1),
 %%      transform_threads(ResThreads,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,OuThread2).

% transform_one_thread(thread(seq,Literals),_Pred,_NT,_GT,_HeadVars,_ASizeRel,_TimeFunc,Literals):-!.

 %% Old 13 Oct. PLG
 %% transform_one_thread([Lit|Litrs], Pred, NT,GT,HeadVars,ASizeRel,TimeFunc,TranBody):-
 %%       !,
 %%       obtain_test(Pred,TimeFunc,HeadVars,Test),
 %%       reverse_and_par_rewrite([Lit|Litrs], Literals),
 %%       transform_body_2(Literals,NT,GT,HeadVars,ASizeRel,TranLiterals),
 %%       sequentialize_goals(Literals, GT, SeqLiterals),
 %%       TranBody = ( Test -> (TranLiterals);(SeqLiterals)).

transform_threads_0([Lit|Litrs], Pred, NT,GT,HeadVars,ASizeRel,TimeFunc,
        ArgPosDict,TranBody):-
      !,
      % warning, check whether we can reverse this before.
      reverse([Lit|Litrs], RLiterals),
      decide_type_of_annotation(RLiterals, NT, GT, HeadVars, ASizeRel,
                                TimeFunc, TypeAnn, AnnLiterals, ArgPosDict),
      (TypeAnn == simple ->
           simple_transform_one_thread([Lit|Litrs], Pred, NT, GT,
                                       HeadVars, ASizeRel, TimeFunc, TranBody)
           ;
           dynsize_transform_one_thread(RLiterals,AnnLiterals,Pred,GT,HeadVars,
                                        TimeFunc,TranBody)).
transform_threads_0((Lit1,Literals),Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,(Lit2,Literals2)):-!,
      transform_threads_0(Lit1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Lit2),
      transform_threads_0(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Literals2).
transform_threads_0((Lit1;Literals),Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,(Lit2;Literals2)):-!,
      transform_threads_0(Lit1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Lit2),
      transform_threads_0(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Literals2).
transform_threads_0((Lit1 -> Literals),Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,(Lit2 -> Literals2)):-!,
      transform_threads_0(Lit1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Lit2),
      transform_threads_0(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Literals2).
transform_threads_0((Lit1 => Literals),Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,(Lit2 => Literals2)):-!,
      transform_threads_0(Lit1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Lit2),
      transform_threads_0(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,ArgPosDict,Literals2).
transform_threads_0(Literals,_Pred,_NT,_GT,_HeadVars,_ASizeRel,_TimeFunc,_ArgPosDict,Literals):-!.

reverse_and_par_rewrite(Literals0, Literals):-
     reverse(Literals0, RLiterals),
     rewrite_par(RLiterals, Literals).

rewrite_par([Lit], Lit):-!.
rewrite_par([Lit|Lits], (Lit & RLits)):-
    rewrite_par(Lits, RLits).

decide_type_of_annotation([Lit1, Lit2],NT,GT,HeadVars,ASizeRel,
                           _TimeFunc,TypeAnn,[AnnLit1,AnnLit2],ArgPosDict):-
      decide_type_annot_lit(GT,NT,Lit1,HeadVars,ASizeRel,AnnLit1,ArgPosDict),
      decide_type_annot_lit(GT,NT,Lit2,HeadVars,ASizeRel,AnnLit2,ArgPosDict),
      (var(ArgPosDict) -> TypeAnn = simple ; TypeAnn = dyn_size_comp).

simple_transform_one_thread([Lit|Litrs], _Pred, NT, GT, HeadVars, ASizeRel, TimeFunc, TranBody):-
      obtain_test(TimeFunc, HeadVars, Test),
      reverse_and_par_rewrite([Lit|Litrs], Literals),
      transform_body_2(Literals, NT, GT, HeadVars, ASizeRel, TranLiterals),
      sequentialize_goals(Literals, GT, SeqLiterals),
      TranBody = ( Test -> (TranLiterals) ; (SeqLiterals)).

% Annotation with dynamic term size computation.

dynsize_transform_one_thread(Literals, AnnLiterals, _Pred, GT,
                             HeadVars, TimeFunc, TranBody):-
      obtain_test(TimeFunc, HeadVars, Test),
      rewrite_par(Literals, ParLiterals),
      rewrite_par(AnnLiterals, ParAnnLiterals),
      sequentialize_goals(ParLiterals, GT, SeqLiterals),
      TranBody = ( Test -> (ParAnnLiterals) ; (SeqLiterals)).

decide_type_annot_lit(GT,NT,Lit,HeadVars,ASizeRel,AnnLit,ArgPosDict):-
    functor(Lit,Name,Arity),
    find_gran_field(GT,Name/Arity,type,Type),
      ( ((Type == do_test);(Type == supply_sizes)) ->
         decide_type_annot_lit_st(GT,NT,Lit,HeadVars,ASizeRel,AnnLit,ArgPosDict)
        ;AnnLit = Lit,
         ArgPosDict = _).

decide_type_annot_lit_st(_,NT,Lit,HeadVars,ASizeRel,AnnLit,ArgPosDict):-
     find_name_entry(NT,Name/Arity,st(_,_,_,InArList,_,_)),
     input_args_number(InArList, ExArList, _, 0, ExArgNum),
   % find_name_entry(NT,Name/Arity,st(_,_,GCName/Ari,InArList,_,_)),
     Ari is Arity + ExArgNum,
     concat("g_", Name, GCName),
     functor(NewLit, GCName, Ari),
     put_Normal_Arguments(NewLit, Lit, Arity),
     (ExArgNum > 0 ->
        (InputArgNum is Arity + 1, 
         decide_type_transform_lit(Lit, InputArgNum, ExArList, ASizeRel, HeadVars,
		                   NewLit, AnnLit, ArgPosDict))
        ; AnnLit = NewLit,
          ArgPosDict = _).

decide_type_transform_lit(_,_,[],_,_,NewLit,NewLit,_ArgPosDict).
decide_type_transform_lit(Lit,InputArgNum,[ArgNum|ANumList],ASizeRel,HeadVars,
		              NewLit,SizeExp,ArgPosDict):-
       find_size(ASizeRel,Lit/ArgNum,Size),
       decide_type_gen_eval_expresion(Size, Exp, SizeArg, ArgPosDict),
       (var(Exp)->
	      SizeExp = NewSizeExp ;
              SizeExp = (Exp,NewSizeExp) ),
       arg(InputArgNum,NewLit,SizeArg),
       NewInArgNum is InputArgNum + 1,
       decide_type_transform_lit(Lit,NewInArgNum,ANumList,ASizeRel,HeadVars,
		              NewLit,NewSizeExp,ArgPosDict).

 %% transform_test_body(Pred, Body,NT,GT,HeadVars,ASizeRel,TimeFunc,TranBody):-
 %%       mark_parallel_threads_0(Body, Threads),
 %%       decide_type_of_annotation(Threads,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,
 %%       TypeAnn,ArgPosDict),
 %%       (TypeAnn == simple -> 
 %%          % Simple annotation: test at the begining of each thread.
 %%          transform_one_thread(Threads,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,TranBody)
 %%          ;
 %%          % Replace literal by the versions that perform dynamic size computation. 
 %%          replace_size_comp_lit(Body,ArgPosDict, NewBody), 
 %%          mark_parallel_threads_0(NewBody, NewThreads),
 %%          transform_all_threads(NewThreads,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,TranBody)
 %%       ).
 %% 
 %% decide_type_of_annotation(Threads,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,
 %%                           TypeAnn,ArgPosDict),
 %% 


 %% transform_one_thread(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Literals2):-
 %%       functor(Literals,F,A),
 %%       is_body_conective(F),
 %%       !,
 %%       functor(Literals2,F,A),
 %%       transform_one_thread_arg(A,Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Literals2).
 %% transform_one_thread(Literals,_Pred,_NT,_GT,_HeadVars,_ASizeRel,_TimeFunc,Literals):-!.
 %% 
 %% transform_one_thread_arg(0,_Literals,_Pred,_NT,_GT,_HeadVars,_ASizeRel,_TimeFunc,_):-!.
 %% transform_one_thread_arg(A,Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Literals2):-
 %%       A > 0,
 %%       arg(A,Literals,Arg1),
 %%       transform_one_thread(Arg1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Arg2),
 %%       arg(A,Literals2,Arg2),
 %%       A1 is A - 1,
 %%       transform_one_thread_arg(A1,Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Literals2).
 %% 
 %% is_body_conective(F/A):- (F/A == (;/2)) ; (F/A == (->/2)) ; (F/A == (=>/2)). 


 %% transform_one_thread((Lit1,Literals),Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,(Lit2,Literals2)):-
 %%       transform_one_thread(Lit1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Lit2),
 %%       transform_one_thread(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Literals2).
 %% 
 %% transform_one_thread((Lit1,Literals),Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,(Lit2,Literals2)):-
 %%       transform_one_thread(Lit1,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Lit2),
 %%       transform_one_thread(Literals,Pred,NT,GT,HeadVars,ASizeRel,TimeFunc,Literals2).

 %% transform_test_body(Pred, Body,NT,GT,HeadVars,ASizeRel,TimeFunc,TranBody):-
 %% 	find_seq_goals(Body,SeqGoals,RestOfBody),
 %% 	obtain_test(Pred, TimeFunc,HeadVars,Test),
 %%         transform_body_2(RestOfBody,NT,GT,HeadVars,ASizeRel,TranParBody),
 %% 	sequentialize_goals(RestOfBody, GT, SeqRestOfBody),
 %% 	(var(SeqGoals)->
 %% 	     TranBody = ( Test -> (TranParBody);(SeqRestOfBody)) ;
 %%              TranBody = (SeqGoals,( Test -> (TranParBody);(SeqRestOfBody)))
 %%         ).



transform_body_2((GoalA,GoalB),NT,GT,HeadVars,ASizeRel,
                 (TranGoalA,TranGoalB)):-!,
	transform_body_2(GoalA,NT,GT,HeadVars,ASizeRel,TranGoalA),
	transform_body_2(GoalB,NT,GT,HeadVars,ASizeRel,TranGoalB).
transform_body_2((GoalA & GoalB),NT,GT,HeadVars,ASizeRel,
                 (TranGoalA & TranGoalB)):-!,
	transform_body_2(GoalA,NT,GT,HeadVars,ASizeRel,TranGoalA),
	transform_body_2(GoalB,NT,GT,HeadVars,ASizeRel,TranGoalB).
transform_body_2(( Cond => SubGoal ),NT,GT,HeadVars,ASizeRel,
                 ( Cond => TranSubGoal )):-!,
	transform_body_2(SubGoal,NT,GT,HeadVars,ASizeRel,TranSubGoal).
transform_body_2(( Cond -> ThenGoal ; ElseGoal ),NT,GT,HeadVars,ASizeRel,
                 ( Cond -> TranThenGoal ; TranElseGoal )):-!,
	transform_body_2(ThenGoal,NT,GT,HeadVars,ASizeRel,TranThenGoal),
	transform_body_2(ElseGoal,NT,GT,HeadVars,ASizeRel,TranElseGoal).
transform_body_2(Lit,NT,GT,HeadVars,ASizeRel,AnnLit):-
	annotate_lit(GT,NT,Lit,HeadVars,ASizeRel,AnnLit).

%
% Annotates a Body Literal that is of type "do_test" or "supply_sizes", by 
% adding expresions that compute Input Argument Sizes , renaming the Literal 
% Predicate and adding Sizes Arguments.
%
  

annotate_lit(GT,NT,Lit,HeadVars,ASizeRel,AnnLit):-
    functor(Lit,Name,Arity),
    find_gran_field(GT,Name/Arity,type,Type),
      ( ((Type == do_test);(Type == supply_sizes)) ->
         annotate_lit_st(GT,NT,Lit,HeadVars,ASizeRel,AnnLit)
        ;AnnLit = Lit ).

annotate_lit_st(_,NT,Lit,HeadVars,ASizeRel,AnnLit):-
     find_name_entry(NT,Name/Arity,st(_,_,_,InArList,_,_)),
     input_args_number(InArList, ExArList, _, 0, ExArgNum),
   % find_name_entry(NT,Name/Arity,st(_,_,GCName/Ari,InArList,_,_)),
     Ari is Arity + ExArgNum,
     concat("g_", Name, GCName),
     functor(NewLit,GCName,Ari),
     put_Normal_Arguments(NewLit, Lit, Arity),
     (ExArgNum > 0 ->
        (InputArgNum is Arity + 1, 
         transform_lit(Lit,InputArgNum,ExArList, ASizeRel, HeadVars,
		              NewLit,AnnLit))
        ; AnnLit = NewLit).
 

transform_lit(_,_,[],_,_,NewLit,NewLit).

transform_lit(Lit,InputArgNum,[ArgNum|ANumList],ASizeRel,HeadVars,
		              NewLit,SizeExp):-
       find_size(ASizeRel,Lit/ArgNum,Size),
       gen_eval_expresion(Size,HeadVars,Exp,SizeArg),
       (var(Exp)->
	      SizeExp = NewSizeExp ;
              SizeExp = (Exp,NewSizeExp) ),
       arg(InputArgNum,NewLit,SizeArg),
       NewInArgNum is InputArgNum + 1,
       transform_lit(Lit,NewInArgNum,ANumList,ASizeRel,HeadVars,
		              NewLit,NewSizeExp).

%% transform_lit(Lit,InputArgNum,[ArgNum|ANumList],ASizeRel,HeadVars,
%% 		              NewLit,SizeExp):-
%%        find_size(ASizeRel,Lit/ArgNum,Size),
%%        gen_eval_expresion(Size,HeadVars,Exp,SizeArg),
%%        (var(Exp)->
%% 	      NewSizeExp = SizeExp ;
%%               SizeExp = (Exp,NewSizeExp) ),
%%        arg(InputArgNum,NewLit,SizeArg),
%%        NewInArgNum is InputArgNum + 1,
%%        transform_lit(Lit,NewInArgNum,ANumList,ASizeRel,HeadVars,
%% 		              NewLit,NewSizeExp).
%% 

transform_head(Name,InArList,Head,TranHead,Varlist):-
	functor(Head,_,Ari),
	input_args_number(InArList, ExArList, NArgList, 0, ExArgNum),
     %  length(InArList,ExArgNum),
	NewAri is Ari + ExArgNum,
	ArgNum is Ari + 1,
	functor(TranHead, Name, NewAri),
        put_Normal_Arguments(TranHead, Head, Ari),
        normal_arguments_vars(Head, NArgList, NorVars),
        collect_size_vars(TranHead, ArgNum, NewAri, ExArList, ExVars),
        append(NorVars, ExVars, Varlist). 
      % collect_size_vars(TranHead,ArgNum,NewAri,InArList,Varlist),
      %  put_args_collect_vars(TranHead,ArgNum,Ari,InArList,Varlist).
      % put_Normal_Arguments(TranHead,Head,Ari).





%% 
%% put_args_collect_vars(_,_, _, _,[],[]).
%% 
%% put_args_collect_vars(TranHead, ExArgNum,[(AType,InArNum)|InArList],
%%                   [(InArNum,SizeVar)|Varlist]):- 
%%         (AType == h -> arg(InArNum, Head, SizeVar) 
%%                     ;  VarNum is InArNum + ExArgNum,
%%                        arg(VarNum, TranHead, SizeVar))
%%         NewArgNum is ArgNum + 1,
%% 	put_args_collect_vars(TranHead, Head, NewArgNum,  
%%                               Ari,InArList,Varlist).
%% 

 %% collect_size_vars(+TranHead, +ArgNum, +NewAri, +ExArList, -ExVars)
 %% TranHead: annotated head.
 %% ArgNum: argument number being processed of annotated head.
 %% +NewAri: arity oa annotated head.
 %% +ExArList: list with the input argument numbers of the initial head.
 %% -ExVars: HeadVars list.
 %% 
 %% Collects from the annotated head the variables representing the size
 %% of input arguments and put them in the HeadVars (closed) list. 
 %% 
 %% Example:
 %% Call: collect_size_vars(g_qsort([],[],_425569),3,3,[1],_423642)
 %% Exit: gracos:collect_size_vars(g_qsort([],[],_425569),3,3,[1],[(1,_425569)])  

collect_size_vars(_, ArgNum,  Ari, [], []):- ArgNum > Ari.
collect_size_vars(TranHead, ArgNum, Ari, [InArNum|InArList],
                   [(InArNum, SizeVar)|Varlist]):- 
 	ArgNum =< Ari,
        arg(ArgNum, TranHead, SizeVar),
        NewArgNum is ArgNum + 1,
 	collect_size_vars(TranHead, NewArgNum, Ari, InArList, Varlist).


%%  collect_size_vars(_,ArgNum,Ari,[],[]):- ArgNum > Ari.
%%  
%%  collect_size_vars(TranHead,ArgNum,Ari,[InArNum|InArList],
%%                    [(InArNum,SizeVar)|Varlist]):- 
%%  	ArgNum =< Ari,
%%         arg(ArgNum,TranHead,SizeVar),
%%         NewArgNum is ArgNum + 1,
%%  	collect_size_vars(TranHead,NewArgNum,Ari,InArList,Varlist).



normal_arguments_vars(_,[],[]).
normal_arguments_vars(Head, [InArNum|InArList],
                   [(InArNum, SizeVar)|Varlist]):- 
        arg(InArNum, Head, SizeVar),
   	normal_arguments_vars(Head, InArList, Varlist).


    

add_sizes_fact(Name,NumInputArg,Head,TranHead):-
	functor(Head,_,Ari),
	NewAri is Ari + NumInputArg,
	ArgNum is Ari + 1,
	functor(TranHead,Name,NewAri),
        put_an_vars(TranHead,ArgNum,NewAri),
        put_Normal_Arguments(TranHead,Head,Ari).

put_an_vars(_,ArgNum,Ari):- ArgNum > Ari.
put_an_vars(TranHead,ArgNum,Ari):- 
	ArgNum =< Ari,
        arg(ArgNum,TranHead,_),
        NewArgNum is ArgNum + 1,
	put_an_vars(TranHead,NewArgNum,Ari).

% Warning!, only works if the TimeFunc is on one variable. 
obtain_test([TimeFunc], HeadVars, Test):-
       set_of_vars(TimeFunc, VarList),
       VarList = [Var],!, 
       obtain_size_threshold(Var, TimeFunc, HeadVars, Test).
obtain_test(_, _, '_7634 < 10').

obtain_size_threshold(Var, TimeFunc, HeadVars, (SizeVar > SizeThreshold)):-
  integer(Var), !,
  granul_threshold(Thres),
  find_size_threshold(TimeFunc, [ ($(0, Var), 1)], Thres, SizeThreshold),
  find_var(HeadVars, Var, SizeVar).
obtain_size_threshold($(Var), TimeFunc, HeadVars, (SizeVar > SizeThreshold)):-
  granul_threshold(Thres),
  find_size_threshold(TimeFunc, [ ($(0, Var), 1) ], Thres, SizeThreshold),
  find_var(HeadVars, $(Var), SizeVar).




exponen(X1,Y1, Z):-
  exponen(Y1, X1, 1, Z).

exponen(Y1, _, Z, Z):- Y1 =< 0.

exponen(Y1, X1, I, Z):-
        Y1 > 0,
        Y is Y1 -1,
        NI is I * X1,
        exponen(Y, X1, NI, Z).
        









%% To evaluate C function 14-10-94
%% obtain_test(_, TimeFunc, HeadVars, Test):-
%%         obtain_test_in_C(TimeFunc, HeadVars, Test).



obtain_test_in_C(TimeFunc, HeadVars, Test):-
	gen_eval_expresion(TimeFunc,HeadVars,Exp,TimeArg),
        /* Exp can be unbound, if the time complexity is the size of an 
           head's variable.
           TimeFunc can't be a number */
           
        (var(Exp)->
	      Test = (TimeArg > 20 )  ;
              Test = (Exp,(TimeArg > 20 )) ).


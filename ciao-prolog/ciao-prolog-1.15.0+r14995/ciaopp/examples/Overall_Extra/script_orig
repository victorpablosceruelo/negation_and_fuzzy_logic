%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SCRIPT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Analysis %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Basic analysis
1.- qs1.pl user file -> top entries for all predicates
2.- qs2.pl we say we only export qsort/2 -> better info on calls (but
for qsort)
3.- qsort.pl (has entry and [assertions]) 
                  types and shfr analysis -> show output (improved info on
		  calls for qsort)
7.- dump_ai(yes). pptypes -> show output (types at program point)
8.- dump_ai(pred). 

Modular analisys
1.- Analysis/qsort_no_part.pl no use_module no trust shfr -> ground
2.- Analysis/qsort_no_part.pl no use_module no trust typesfd -> strange type
3.- no types shfr Uncomment use_module modes -> bad_info.
4.- uncomment trust modes -> good info.
5.- partition.pl builtins -> show engine/arithmetic.pl
6.- C^c tab -> info for is
11.- **shfr off** typesfd qsort_altfunc.pl, comment out use_module(mytypes), analyze, then put in, analyze.

%%%%%%%%%%%%%%%%%%%%%%%%% Complex properties %%%%%%%%%%%%%%%
A) Non-failure: qsort, types, shfr, nf
B) Determinacy: qsort, types, shfr, det
C) Cost: qsort, types, shfr, upper (partition)
D) Cost: qsort, types, shfr, lower (partition) BAD => combine with non-failure analysis => good

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Debugging %%%%%%%%%%%%%%%%%%
*Turn all the analysis off*
???? A) qsort1.pl preprocess with no analysis -> Syntax warnings (no analysis, no assertions)
WARNING: (lns 12-13) clauses of partition/4 are discontiguous
WARNING: (lns 14-15) [X] - singleton variables in append/2
WARNING: (lns 16-16) predicate append/3 is already defined with arity 2
!!!!==> This can be done by the low level compiler...

C) qsort2.pl no more low level
   ====> But analyzer detects TWO errors. (SHOW OUTPUT)

D) qsort3.pl same as qsort2.pl but with an entry added. -> 3 messages
	      this shows the importance of an accurate entry. 
{WARNING (preproc_errors): Literal partition(A,B,C,D) at qsort/2/1/1 does not succeed!}
{WARNING (ctchecks_messages): The head of clause 'partition/4/2' is incompatible with its call type
         Head:      partition([e|R],C,[E|Left1],Right)
         Call Type: partition(list(num),var,num,var)}
{ERROR (ctchecks_messages): Builtin predicate A>=B at partition/4/3/1 is not called as expected:
         Called:   num>=var
         Expected: intexpr>=intexpr}

F) qsort4.pl after correcting wrong call to partition (swapped
   args) and e, we get no more messages

G) qsort5.pl we add assertions with partial specification including 
	      sorted_num_list which is not native -> we detect one
	      error
ERROR (ctchecks_messages): (lns 22-23) false calls assertion
   :- calls append(A,B,C) : list(A,num),list(B,num)
      Called append(list(^x),[^x|list(^x)],var)

*** Show output: checked assertions, etc.

H) qsort6.pl three out of the four assertions are validated. The one
	      with non-native is simplified but remains -> select
	      run-time checking.

using again the same program we precompile it and load the output in
ciao. A calls to such as qsort([2,1],L). raises a run-time error.

%%%%%%%%%%%%%%% Parallelization %%%%%%%%%%%%%%%%%%%%%%%%%%%
1.- qsort.pl (**no entry**), mel, pre,  no analysis -> plenty of tests
(one is always false)
2.- qsort.pl (**no entry**), mel, pre,  local -> only one test
3.- qsort.pl (**no entry**), mel, pre,  shfr -> no tests
4.- mmatrix.pl (with the entry!!!).  with shfr no tests
5.- mmatrix.pl (without the entry!!!).  with shfr -> plenty of tests
6.- mmatrix.pl (without entry!!!).  shfr. Multiplespc -> show results
%%%%%%%%%%%%%%%%%%%%% Granularity %%%%%%%%%%%%%%%%%%
A) qsort.pl, mel, pre, *types*, shfr, gr, upper,
B) qsort.pl, mel, pre, *types*, shfr, gr, nf, lower
----

%% B) (Regular) Type analysis
%%    types.pl (with typesfd)
%%     - without the regtype package:
%%       types inferred appear in the output
%%     - with the regtype package:
%%       types inferred are "collapsed" to the user properties





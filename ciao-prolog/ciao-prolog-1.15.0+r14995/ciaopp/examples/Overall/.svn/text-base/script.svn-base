%%%%%%%%%%%%%%%%%%%%%%%%%%%%% New      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sometypes.pl
sometypes_func.pl

fact.pl (pptypesfd, shfr, etc. upper)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Analysis %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Basic analysis

1.- qs1.pl user file typesfd -> top entries for all predicates. As a result,
we do not even know that output of qsort is a list! (since output of
append is term!)

2.- qs2.pl we say we only export qsort/2 , typesfd -> better info on calls (but
for qsort). Now output of qsort is a list of terms.

3.- in qs2.pl we add a number test in basic case -> qsort returns a
    numlist.

4.- qsort.pl (has entry and [assertions]) typesfd analysis -> show
		  output (improved info on calls and exit for qsort).

5.- dump_ai(yes). pptypesfd -> show output (typesfd at program point)
6.- dump_ai(pred). qsort.pl shfr. Explain about mode analysis.
7.- dump_ai(yes). Show also mode info at program points.

%%%%%%%%%%%%%%% Parallelization %%%%%%%%%%%%%%%%%%%%%%%%%%%
** dump_ai(no) **
1.- qsort.pl (**no entry**), mel, pre,  no analysis -> plenty of tests
(ground(R1) ground(R2) are always false!) slower program
2.- qsort.pl (**no entry**), mel, pre,  local -> only one test
3.- qsort.pl (**no entry**), mel, pre,  shfr -> no tests, runs in parallel
4.- mmatrix.pl (with the entry!!!).  with shfr no tests
5.- mmatrix.pl (without the entry!!!).  with shfr -> plenty of tests
6.- mmatrix.pl (without entry!!!).  shfr. Multiplespc -> show results
7.- mmatrix.pl (without the entry!!!).  with shfr -> show output
8.- preprocess output of previous step and spec -> more analysis time!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Modular analysis
** dump_ai(pred) **
1.- Analysis/qsort_no_part.pl no use_module no trust shfr -> ground
2.- Analysis/qsort_no_part.pl no use_module no trust typesfd -> strange type
3.- no types shfr Uncomment use_module modes -> bad_info.
4.- uncomment trust modes -> good info.
5.- partition.pl builtins -> show engine/arithmetic.pl
6.- C^c tab -> info for is
11.- **shfr off** typesfd qsort_altfunc.pl, comment out use_module(mytypes), analyze, then put in, analyze.

%%%%%%%%%%%%%%%%%%%%%%%%% Complex properties %%%%%%%%%%%%%%%
A) Non-failure: qsort, typesfd, shfr, nf
C) Cost: qsort, typesfd, shfr, upper (partition)
D) Cost: qsort, typesfd, shfr, lower (partition) BAD => combine with non-failure analysis => good
E) Determinism: qsort, typesfd, shfr, det. All preds are det.

%%%%%%%%%%%%%%%%%%%%% Granularity %%%%%%%%%%%%%%%%%%
A) qsort.pl, mel, pre, *typesfd*, shfr, gr, upper,
B) qsort.pl, mel, pre, *typesfd*, shfr, gr, nf, lower

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Debugging %%%%%%%%%%%%%%%%%%
*Turn all the analysis off*
???? A) qsort1.pl preprocess with no analysis -> Syntax warnings (no analysis, no assertions)
WARNING: (lns 12-13) clauses of partition/4 are discontiguous
WARNING: (lns 14-15) [X] - singleton variables in append/2
WARNING: (lns 16-16) predicate append/3 is already defined with arity 2
!!!!==> This can be done by the low level compiler...

*Analysis with pptypesfd*
C) qsort2.pl no more low level
   ====> But analyzer detects TWO errors. (SHOW OUTPUT)

D) qsort3.pl same as qsort2.pl but with an entry added. -> 3 messages
	      this shows the importance of an accurate entry. 
{WARNING (preproc_errors): Literal partition(A,B,C,D) at qsort/2/1/1 does not succeed!}
{WARNING (ctchecks_messages): The head of clause 'partition/4/2' is incompatible with its call type
         Head:      partition([e|R],C,[E|Left1],Right)
         Call Type: partition(list(num),var,num,var)}
{ERROR (ctchecks_messages): Builtin predicate A>=B at partition/4/3/1 is not called as expected:
         Called:   num>=var
         Expected: intexpr>=intexpr}

F) qsort4.pl after correcting wrong call to partition (swapped
   args) and e, we get no more messages

G) qsort5.pl we add assertions with partial specification including 
	      sorted_num_list which is not native -> we detect one
	      error
ERROR (ctchecks_messages): (lns 22-23) false calls assertion
   :- calls append(A,B,C) : list(A,num),list(B,num)
      Called append(list(^x),[^x|list(^x)],var)

*** Show output: checked assertions, etc.

*with shfr!!*
H) qsort6.pl three out of the four assertions are validated. The one
	      with non-native is simplified but remains -> select
	      run-time checking.

using again the same program we precompile it and load the output in
ciao. 

*start a new Ciao/Prolog before loading the transformed program!!*

A call such as qsort([2,1],L). raises a run-time error.





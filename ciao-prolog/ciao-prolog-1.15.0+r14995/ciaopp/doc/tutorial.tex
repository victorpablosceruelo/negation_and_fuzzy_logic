% ---------------------------------------
% ICLP tutorial (December 1999) based on SICS Visit: Tutorial / Demo
% Being adapted as course slides
% Adapted now as a tutorial
% ---------------------------------------
\documentclass{article}

\usepackage{graphics}
%% \usepackage{psfig}
\usepackage{epsfig}
% \usepackage{denot}
\usepackage{html}
\usepackage{colordvi}

%% ????
\def\dis{\vee}
\renewcommand{\_}{\char'137}

\newcommand{\p}{{\sem{P}}}
\newcommand{\sem}[1]{\lsem #1 \rsem}
\newcommand{\lsem}{\mbox{$\lbrack\hspace{-0.3ex}\lbrack$}}
\newcommand{\rsem}{\mbox{$\rbrack\hspace{-0.3ex}\rbrack$}}
\newcommand{\I}{\mbox{$\cal I$}}

\makeindex

\begin{document}

\title{Program Analysis, Debugging, and Optimization\\
\huge{\Blue{A Tour of {\tt ciaopp}:\\ 
     The Ciao Prolog Preprocessor}}
}

\author{
Manuel Hermenegildo, 
Francisco Bueno, 
Manuel Carro, \\
Claudio Ochoa,
Germ\'{a}n Puebla, 
Pedro L\'{o}pez
}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Ciao Program Development System}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Ciao is a next-generation (C)LP programming environment which features
  \cite{ciao-manual-1.10-short}:
  \begin{itemize}
  \item Public domain (GNU license).
  \item Pure kernel: \emph{no ``built-ins''}; all libraries.
  \item ISO-Prolog (transparently subsumed) via \emph{library}. 
  \item Design to be \texttt{extensible} and \texttt{analyzable}.
%%         operators and expansions are local to
%%         modules, etc. 
%%    $\rightarrow$ many libraries:
  \item Support for programming \emph{in the large}:
    \begin{itemize}
    \item robust module/object system, separate/incremental
      compilation, \ldots
    \item ``industry standard'' performance.
    \item (semi-automatic) interfaces to other languages, databases, etc.
    \item assertion language, automatic static inference and
      checking, autodoc, \ldots
    \end{itemize}
  \item Support for programming \emph{in the small}:
    \begin{itemize}
    \item scripts, small (static/dynamic/lazy-load) executables, \ldots
    \end{itemize}
  \item Support for several paradigms:
        \begin{itemize}
        \item functions, higher-order, objects, constraint
          domains, \ldots
        \item concurrency, parallelism, distributed execution, \ldots
        \end{itemize}
  \item Advanced Emacs environment (with e.g., automatic access to
    documentation). 
%%  \item Auto-documenter.
%%  \item Small, standalone executables. Scripts. Compilation to C.
%%  \item ``Industry standard'' performance (SICStus-derived engine).
%%  \item Concurrency (and parallelism). Concurrent database for communication.
%%  \item Libraries:
  \end{itemize}

\item Components of the environment (independent):

  \begin{tabular}{ll}
  \texttt{ciaosh}:  & Standard top-level shell.\\
  \texttt{ciaoc}:   & Standalone compiler.\\
  \texttt{ciaosi}:  & Script interpreter.\\
  \texttt{lpdoc}:   & Documentation Generator (info, ps, pdf,
    html, \ldots).\\
  \fbox{\texttt{ciaopp}:}  & \fbox{Preprocessor.}\\
  \end{tabular}

\item[+] Many libraries:
  \begin{itemize}
  \item Functional syntax.
  \item Records (argument names).
  \item Objects.
  \item Persistent predicates.
  \item Transparent interface to databases.
  \item Interfaces to C, Java, tcl-tk, etc.
  \item Distributed execution.
  \item Internet (PiLLoW: HTML, VRML, forms, http protocol, etc.), \ldots
  \end{itemize}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Ciao Preprocessor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item A standalone preprocessor to the standard clause-level compiler.
\item Performs source-to-source transformations:
  \begin{itemize}
  \item Input: logic program (optionally w/assertions \& syntactic extensions).
  \item Output: \emph{error/warning messages} + \emph{transformed
      logic program}, with
    \begin{itemize}
    \item Results of analysis (as assertions).
    \item Results of static checking of assertions.
    \item Assertion run-time checking code.
    \item Optimizations (specialization, parallelization, etc.)
    \end{itemize}
  \end{itemize}

\item By design, a generic tool -- can be applied to other systems:

\begin{center}
%% \psfig{figure=chiprewhere.eps,width=0.99\textwidth}}
\psfig{figure=figs/framework_all_nmsu.eps,width=0.85\textwidth}
\end{center}

\begin{itemize}
%% \item Implemented tool is a {\em generic} Ciao application -- can be
%%   customized: 
\item \texttt{ciaopp} is {\em generic}, i.e., it can be customized:
  \begin{itemize}
  \item For a new language: giving assertions for its
    built-ins and libraries (+ syntax).
  \item For new properties: adding a new {\em domain} to the analyzer.
  \end{itemize}
\item \underline{Example:} \texttt{chipre}, preprocessor for CHIP.
\end{itemize}

\item Underlying technology:
  \begin{itemize}
  \item Modular polyvariant abstract interpretation.
  \item Modular abstract multiple specialization.
  \end{itemize}

%% \item Global analysis based on abstract interpretation relatively mature:
%% \begin{itemize}
%% \item Frameworks / analyzers available for LP and CLP (PLAI, GAIA, \ldots).
%% \item Safely approximate  non-trivial information:\\
%%       types, modes, sharing, cost, termination, non-failure\ldots
%% \item Sensible analysis of full ISO Prolog \\
%%       and module structure \\
%%       now well understood.
%% %% (see, e.g., \cite{full-prolog-esop96, ciao-modules-analspec-entcs}).
%% \end{itemize}
%% \item Traditionally used for transformation/optimization\\
%%       (parallelism, native compilation, (abstract) partial evaluation, \ldots).
%% \item But {\em many applications in program development}.
%% %%       (see, e.g., 
%% %%       \cite{full-prolog-esop96,aadebug97-informal-html,prog-glob-an,assrt-framework-lopstr99-informal}). %% [AADEBUG'97,The LP Pa'99]

\end{itemize}

\subsection{Overview of the tutorial}

\begin{itemize}
\item We demonstrate Ciaopp in use:
  \begin{itemize}
  \item Inference of complex properties of programs.
  \item Program debugging.
  \item Program validation.
  \item Program optimization (e.g., specialization, parallelization).
  \item Program documentation. 
  \end{itemize}

\item We discuss some practical issues:
  \begin{itemize}
  \item The \emph{assertion} language.
  \item Dealing with built-ins and complex language features.
  \item Modular analysis (including libraries).
  \item Efficiency and incremental analysis (only reanalyze what is needed).
  \end{itemize}

\end{itemize}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Properties and Assertions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item Assertion language \cite{assert-lang-ws} suitable for {\em
    multiple purposes} (see later). 
%%  -- a tool may use a subset.  
\item Assertions are typically {\em optional}. 
%% \item System should deal {\em safely} with general, undecidable
%%     properties, and incomplete information $\rightarrow$ {\em safe
%%     approximations} ({\em abstract interpretation}).

\item \underline{Properties} (include {\em types} as a special case): 
   \begin{itemize}
   \item Arbitrary predicates, (generally) {\em written in the source language}.
%% \item They perform no instantiation (they only ``test'').
   \item Some predefined in system, some of them ``native'' to an analyzer.
   \item Others user-defined.
   \item Should  be ``runnable'' (but property may be an
         approximation itself). 
%%   \item Will be used also as run-time tests!
   \end{itemize}

   Examples:
   \begin{itemize}
   \item The type of lists:
\begin{verbatim}
:- regtype list/1.
list([]).
list([_|Y]) :- list(Y).
\end{verbatim}

   \item The type of integers:
\begin{verbatim}
:- regtype int/1 + impl_defined.
\end{verbatim}

   \item The type of Peano numbers:
\begin{verbatim}
:- regtype peano_nat/1.
peano_nat(0).
peano_nat(s(X)) :- peano_nat(X).
\end{verbatim}

   \item The ``type'' of sorted lists:
\begin{verbatim}
:- prop sorted/1.
sorted([]).
sorted([_]).
sorted([X,Y|Z]) :- X>Y, sorted([Y|Z]).
\end{verbatim}
\end{itemize}

\item Many properties already defined in libraries:
\begin{itemize}
\item \verb+engine(basic_props)+ for classical things like
  \verb+num/1+, \verb+list/1+, \ldots
\item \verb+library('assertions/native_props')+ for properties
  natively understood by {\tt ciaopp}, like \verb+linear/1+,
  \verb+is_det+, \ldots
\item in their ``original'' library; e.g., \verb+numexpr/1+ in
  \verb+engine(arithmetic)+. 
\end{itemize}

\item Basic assertions:

\begin{tabular}{|lllll|}
\hline
{\tt :- success} & $PredDesc$ & $[$ & {\tt :} $PreC$ $]$  & {\tt =>} $PostC$ {\tt .}\\
{\tt :- calls}   & $PredDesc$ &     & {\tt :} $PreC$ {\tt .} & \\

{\tt :- comp}    & $PredDesc$ & $[$ & {\tt :} $PreC$ $]$  & {\tt +} $CompProps$ {\tt .}\\ [2mm]
\hline
\end{tabular} \\

%% Also: declarative assrt., program point assrt., {\tt entry} assrt.,
%%       documentation, \ldots 

Examples:
\begin{itemize}
  \item On success (if any) of calls to \verb+qsort(A,B)+ with \verb+A+ a
  list, \verb+B+ is ground:
\begin{verbatim}
  :- success qsort(A,B) : list(A) => ground(B).
\end{verbatim}
  \item Calls to \verb+qsort(A,B)+ are such that \verb+A+ a is a list
  and \verb+B+ is a free variable:
\begin{verbatim}
  :- calls qsort(A,B) : ( list(A), var(B) ).
\end{verbatim}
  \item Calls to \verb+qsort(A,B)+ in which \verb+A+ a is a list of
  integers and \verb+B+ a free variable are deterministic and succeed:
\begin{verbatim}
  :- comp qsort(A,B) : ( list(A,int), var(B) )
                     + ( is_det, succeeds ).
\end{verbatim}
\end{itemize}

\item Compound assertion (syntactic sugar):

\begin{tabular}{|lllll|}
\hline
{\tt :- pred}    & $PredDesc$ & $[$ & {\tt :} $PreC$ $]$ & $[$ {\tt =>} $PostC$ $]$ $[$ {\tt +} $Comp$ $]$ {\tt .}\\ [2mm]
%% {\tt :- pred}    & $PredDesc$ & $[$ & {\tt ::} $Props$ $]$ & $[$ {\tt :}
%% $PreC$ $]$ $[$ {\tt =>} $PostC$ $]$ $[$ {\tt +} $Comp$ $]$ {\tt .}\\ [2mm]
\hline
\end{tabular} \\

Examples:
\begin{itemize}
  \item Calls to \verb+qsort(A,B)+ in which \verb+A+ a is a list of
  integers and \verb+B+ a free variable are deterministic and succeed
  with \verb+B+ a sorted list:
 \begin{verbatim}
  :- pred qsort(A,B) : ( list(A,int), var(B) )
                    => sorted(B) 
                     + ( is_det, succeeds ).
\end{verbatim}
  \item Calls to \verb+qsort(A,B)+ in which \verb+A+ a is a free variable
  and \verb+B+ a list of integers succeed with \verb+A+ a ground term:
 \begin{verbatim}
  :- pred qsort(A,B) : ( var(A), list(B,int) )
                    => ground(A) 
                     + succeeds. 
\end{verbatim}
\end{itemize}

\item Assertion {\em status}: 
\begin{itemize}
\item {\tt check} (default) -- intended semantics, to be checked.
\item {\tt true}, {\tt false} -- actual semantics, output from compiler.
\item {\tt trust} -- actual semantics, input from user (guiding compiler).
\item {\tt checked} -- validation: a {\tt check} that has been proved
  (same as a {\tt true}).
\end{itemize}

Example:
\begin{itemize}
\item Use the information that on successes of \verb+is(X,Y)+ it is
  guaranteed that \verb+X+ is a number and \verb+Y+ a numerical expression:
\begin{verbatim}
  :- trust pred is(X,Y) => ( num(X), numexpr(Y) ).
\end{verbatim}
\end{itemize}

\item Program point assertions: 
\begin{itemize}
\item Same as status, with the property as argument.
\item {\tt check} is used for run-time checking if package
  \verb+rtchecks+ is included in the program.
\end{itemize}

Example:
\begin{itemize}
\item Trust that all inputs at this point are integers:
\begin{verbatim}
  main :- read(X), trust(int(X)), ...
\end{verbatim}
\end{itemize}

\item The {\tt entry} assertion:
\begin{itemize}
\item Equivalent to ``{\tt trust calls}''.
\item But only describes calls {\em external} to a module.
\end{itemize}

Example:
\begin{itemize}
\item All invocations of the program will have integer parameters:
\begin{verbatim}
  :- entry main(X) : list(X,int).
\end{verbatim}
\end{itemize}

\item Some goodies:
\begin{itemize}
\item syntactic sugar,
\begin{verbatim}
  :- pred length/2 : list(int) * var => list(int) * int.
\end{verbatim}
\item mode macros, 
\begin{verbatim}
  :- modedef +X : nonvar(X).
\end{verbatim}
so that
\begin{verbatim}
  :- pred qsort(+A,B).
\end{verbatim}
is equivalent to
\begin{verbatim}
  :- pred qsort(A,B) : nonvar(A).
\end{verbatim}
\item ``compatibility''  properties, fields for automatic
  documentation \cite{ciaodoc-tr}, \ldots 
\begin{verbatim}
  :- pred sortints(+L,-SL) :: list(int) * list(int) 
                            + sorted(SL)
        # "@var{SL} has same elements as @var{L}.".
\end{verbatim}
\end{itemize}

\end{itemize}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PART I: Analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item \texttt{ciaopp} includes two basic analyzers:
  \begin{itemize}
  \item The PLAI generic, top-down analysis framework.
    \begin{itemize}
    \item Several domains: modes (ground, free), independence,
      patterns, \emph{parametric types} (\texttt{list(int)}), etc. 
    \item Incremental analysis, analysis of programs with delay, \ldots
    \end{itemize}
  \item Advanced analyzers (GraCos/CASLOG) for complex properties:\\
    non-failure, coverage, determinism, sizes, cost, \ldots 
  \end{itemize}
\item Issues:
  \begin{itemize}
  \item Reporting the results $\rightarrow$ ``true'' assertions.
  \item Helping the analyzer $\rightarrow$ ``entry/trust'' assertions.
  \item Dealing with builtins $\rightarrow$ ``trust'' assertions.
  \item Incomplete programs $\rightarrow$ ``trust'' assertions.
  \item Modular programs $\rightarrow$ ``trust'' assertions, interface
    (\texttt{.itf}, \texttt{.asr}) files.
  \item Multivariance, incrementality, \ldots
  %% \cite{incanal-iclp95}, \ldots
  \end{itemize}
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inference of Complex Properties: \\ Non-failure (Intuition)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Based on the intuitively simple notion of a set of tests
      ``covering'' the type  of the input variables.

%% \item We assume that programs are {\em moded}: for each
%%       unification operation, we know whether the
%%       operation acts as a test or creates an output binding.

\item Clause: set of primitive tests followed by various
unifications and body goals.

\item The tests at the beginning determine whether the clause
should be executed or not (may involve pattern
matching, arithmetic tests, type tests, etc.)

\item Consider the predicate:
\begin{verbatim}
abs(X, Y) :- X >= 0, Y is X.
abs(X, Y) :- X < 0, Y is -X.
\end{verbatim} 
%
%% \begin{verbatim}
%% p(X, Y):- X  > 0, Y is X + 1.
%% p(X, Y):- X =< 0, Y is -X.
%% \end{verbatim}
%
\begin{itemize}
\item and a call to \verb+abs/2+ with \verb+X+ bound to an integer
      and \verb+Y+ free.

\item The test of \verb+abs/2+, $X \geq 0 \dis X < 0$, will
      succeed for this call.

%% \item Assume that the type of the input argument {\tt X} is {\bf integer}.
%% (denoted {\tt X}:{\em integer}).

\item ``The test of the predicate \verb+abs/2+ covers the type of
      \verb+X+.''
      % (i.e. its input type)

\item Since the rest of the body literals of \verb+abs/2+ are
      guaranteed not to fail, at least one of the clauses will not
      fail, and thus the call will also not fail:

\begin{verbatim}
  :- true pred abs(X, Y) : ( int(X), var(Y) ) + not_fails.
\end{verbatim} 

%% \item 
%% For any given clause, we refer to the conjunction of its primitive
%% tests as ``the test of the clause''.
%% 
%% \item The disjunction of all the tests of the clauses that define a
%% particular predicate is referred to as ``the test of that
%% predicate''.

\end{itemize}

\end{itemize}

%% %\section{Applications}
%% % \section{Motivations}
%% \begin{itemize}
%% \item programming error detection: 
%%       in logic programs the usual expectation is that a
%%       predicate will succeed and produce one or more solutions.
%%  
%% \item program transformations and optimizations: 
%%      we may want to execute possibly-failing goals ahead of
%%      non-failing goals where possible.
%% \item parallel execution optimization:
%%   \begin{itemize}
%%     \item avoiding speculative parallelism, and 
%%     \item estimating lower bounds on the computational costs of goals 
%%          (which can be used for granularity control). 
%%   \end{itemize}
%% 
%% \end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inference of Complex Properties: \\ 
Lower-Bounds on Cost (Intuition)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
%%\item Based on the notion of a set of tests ``covering'' a type.

\item Consider:
\begin{verbatim}
:- module(lists,[append/3,...],[assertions]).

:- entry append(A,B,C): glist * glist * var.

append([], L, L).
append([H|L], L1, [H|R]) :- append(L, L1, R).
\end{verbatim}

\item Assuming:
\begin{itemize}
\item Cost metric: number of resolution steps.
\item Argument size metric: list length. 
\item Types, modes, covering, and non-failure info available.
\end{itemize}

\item Let 
  ${\tt Cost_{append}}(n, m)$: cost of a call to {\tt append}/3 with
  input lists of lengths $n$ and $m$. 

\item A difference equation can be set up for {\tt append}/3:
 \begin{tabbing}
 12\=45678\=\kill
 \> ${\tt Cost_{append}}(0, m) = 1$ (boundary condition from first clause),\\
 \> ${\tt Cost_{append}}(n, m) = 1 + {\tt Cost_{append}}(n-1, m)$.
 \end{tabbing}

\item Solution obtained: ${\tt Cost_{append}}(n, m) = n+1$.

\begin{verbatim}
:- true pred append(A,B,C)
         : ( glist(A), glist(B), var(C) )
        => ( glist(A), glist(B), glist(C), 
             size_lb(A,length(A)), 
             size_lb(B,length(B)),
             size_lb(C,length(B)+length(A))
           )
         + steps_lb(length(A)+1).
\end{verbatim}

\item Based on also inferring argument size relationships (relative sizes).
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{``Resource awareness'' example \\ (Upper-Bounds Cost Analysis)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Given:
\begin{verbatim}
:- entry inc_all/2 : list(int) * var.

inc_all([],[]).
inc_all([H|T],[NH|NT]) :- NH is H+1, inc_all(T,NT).
\end{verbatim}

\item After running through \texttt{ciaopp} (cost analysis) we get:
\begin{verbatim}
:- entry inc_all/2 : ground * var.

:- true pred inc_all(A,B) : ( list(A,int), var(B) )
                         => ( list(A,int), list(B,int) )
                          + steps_ub(2*length(A)+1).

inc_all([],[]).
inc_all([H|T],[NH|NT]) :- NH is H+1, inc_all(T,NT).
\end{verbatim}
which is a program with a certificate of needed resources!
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Modular analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Single module analysis (for edit-compile-test cycle):

  \begin{itemize}
  \item CiaoPP allows the analysis of a module taking into
    consideration assertions in modules imported from it

  \item After the analysis of a module, CiaoPP stores the results in
    order to be used when analysing the modules that import it

  \item Also stores the calls to imported modules to improve the
    results for this module when imported modules are analyzed

  \item Example: given the following two modules:

\begin{verbatim}

:- module(rev,[rev/2],[assertions]).
:- use_module(app).
   rev([],[]).
   rev([A|X1],Y):- rev(X1,Y1), app(Y1,[A],Y).

:- module(app,[app/3],[assertions]).
   app([],Y,Y).
   app([A|X1],Y,[A|Z1]):- app(X1,Y,Z1).

\end{verbatim}

  \item When analyzing \verb+rev+ the first time, nothing can be
    assumed for the call to \verb+app/3+, but Ciaopp stores the
    calling pattern for \verb+app/3+.

    If $Def$ domain is used, the analysis result is  \verb+rev(X,Y)+$:true$ $\mapsto true$ \\
  (Not very informative)

  \item When analyzing module \verb+app+, calling patterns from other
    modules are considered.
    
    In the $Def$ domain, with calling pattern
    \verb+app(X,Y,Z)+$:true$, the resulting answer pattern is
    \verb+app(X,Y,Z)+$:true$ {\tt
      $\mapsto$(X$\wedge$Y)$\leftrightarrow$Z}

  \item If \verb+rev+ is analyzed again, it uses new information, and
    produces a more precise result.

    In the $Def$ domain,  \verb+rev(X,Y)+$:true$
    {\tt $\mapsto$ X$\leftrightarrow$Y}
  \end{itemize}


\item Automatic analysis of multi-module programs
  \begin{itemize}
  \item Objective: get results as accurate as possible for large
    programs and libraries

  \item Two approaches: 
    \begin{itemize}
    \item Load all modules into memory and analyze them
      as if they were a single module (when the analyzer does not run
      out of memory)

    \item Analyze modules one by one, iterating through the
      inter-module dependency graph until a fixed point is reached. 
    \end{itemize}
  \end{itemize}

\item Specialization of multi-module programs
  \begin{itemize}
  \item The same framework can be applied for propagating specialized
    names generated for each program module.

  \item Libraries can be specialized for a given program.
  \end{itemize}
\end{itemize}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PART II: Program Validation and Diagnosis (Debugging)}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item We compare actual semantics $\p$ vs.~intended semantics $\I$ for $P$:
  \begin{itemize}
  \item $P$ is {\em partially  correct} w.r.t.\ $\I$ iff \hspace*{.8cm}
    $\p \subseteq \I$. 
  \item $P$ is {\em complete} w.r.t.\ $\I$ iff \hspace*{2cm}
    $\I\ \subseteq\  \p$.
  \item $P$ is {\em incorrect} w.r.t.\ $\I$ iff \hspace*{2cm}
    $\p \not\subseteq \I$.
  \item $P$ is {\em incomplete} w.r.t.\ $\I$ iff \hspace*{1.8cm}
    $\I\ \not\subseteq \p$.
  \end{itemize}
%% \item $\I$ may not be unique.
\item $\I$ described via (check) assertions.
\item Incorrectness and incompleteness indicate that diagnosis should be
  performed. 
\item {\em Problems:} difficulty in computing $\p$ (+ $\I$ incomplete,
i.e., {\em approximate}).
%% \item {\em Possible solutions / alternatives:} 
\item {\em Approach:} 
  \begin{itemize}
%%  \item Proving sufficient conditions (as in {\em diagnosis by proof}).
%%   \item Testing, run-time checking, manual tracing, etc. 
%%   (incomplete/expensive).
%%   \item {\em Approximating} $\p$ directly (safely) 
%%   ({\em abstract validation} [Bour93], [ESOP'96],\ldots).
  \item Use the abstract interpreter to infer properties of $P$.
  \item Compare them to the assertions.
  \item Generate run-time tests if anything remains to be tested.
  \end{itemize}
%% \item Objective: combine static/dynamic checking, automate process.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validation Using Abstract Interpretation}
%% [AADEBUG'97]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
\item Specification given as an abstract semantic value $\I_\alpha\in
  D_\alpha$ and compared with computed abstract semantics $\p_\alpha$.
%% \item $\p_\alpha$ will be compared with $\I_\alpha$. 

%% \item Validation problems using approximations:\\[2mm]

\begin{tabular}{||l|c|c||}\hline\hline
     {\bf Property}& {\bf Definition}&{\bf Sufficient condition}
\\ \hline\hline
     P is partially  correct w.r.t.\ $\I_\alpha$& $ \alpha(\p) \subseteq 
     \I_\alpha$ &$ \p_{\alpha^+}
     \subseteq \I_\alpha$ \\
\hline
     P is complete w.r.t.\ $\I_\alpha$ & $\I_\alpha \subseteq 
\alpha(\p)$& $
\I_\alpha \subseteq \p_{\alpha^-}$ \\
\hline
     P is incorrect w.r.t.\ $\I_\alpha$ & $\alpha(\p) \not\subseteq \I_\alpha$
& $\p_{\alpha^-}
     \not\subseteq \I_\alpha$, or\ \\
 & & $\p_{\alpha^+}\ \cap\ \I_\alpha\ =\ \O \wedge \p_\alpha\neq\O$
\\ \hline
     P is incomplete w.r.t.\ $\I_\alpha$& $\I_\alpha \not\subseteq 
\alpha(\p)$
&$\I_\alpha
     \not\subseteq \p_{\alpha^+}$\\
 \hline\hline
\end{tabular}

$\sem{P}_{\alpha^+}$ represents that $\sem{P}_\alpha\supseteq
\alpha(\sem{P})$ (an over-approximation)\ and \\
$\sem{P}_{\alpha^-}$ indicates that $\sem{P}_\alpha\subseteq
\alpha(\sem{P})$ (an under-approximation)

\item Conclusions w.r.t.\ direct Galois insertions (i.e., over-approximation):
  \begin{itemize}
  \item Suited for proving partial correctness and incompleteness w.r.tn.\
    $\I$. 
  \item It is also possible to prove incorrectness.
  \item Completeness can only be proved if the abstraction is ``precise.''
  \end{itemize}
\item Conclusion w.r.t.\ reversed Galois insertions (i.e., under-approximation):  \begin{itemize}
  \item Suited for proving completeness and incorrectness.
  \item Partial correctness and incompleteness only if the abstraction is
    ``precise.''
  \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A Program validation example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Given:
\begin{verbatim}
:- check comp : list(int) * var + not_fails.

inc_all([],[]).
inc_all([H|T],[NH|NT]) :- NH is H+1, inc_all(T,NT).
\end{verbatim}

\item After running through \texttt{ciaopp} (non-failure analysis) we get:
\begin{verbatim}
:- checked comp : list(int) * var + not_fails.

inc_all([],[]).
inc_all([H|T],[NH|NT]) :- NH is H+1, inc_all(T,NT).
\end{verbatim}
which is a validated (certified) program.

\begin{verbatim}
ciaopp ?- auto_check_assert(program_validation).
{Loading current module from program_validation.pl
{loaded in 2161.671 msec.}
}
{Analyzing program_validation.pl
{preprocessed for plai in 5.999 msec.}
{analyzed by plai using eterms in 24.996 msec.}
}
{Analyzing program_validation.pl
{preprocessed for plai in 3.999 msec.}
{analyzed by plai using shfr in 7.999 msec.}
}
{Analyzing program_validation.pl
{preprocessed for nfg in 1.0 msec.}
{analyzed by nfg in 1.0 msec.}
{analysis information stored in 0.0 msec.}
}
{Checking assertions of program_validation.pl
{NOTE (ctchecks_pred): Assertion:
:- check comp inc_all(_1,_2)
         : ( basic_props:list(_1,basic_props:int), term_typing:var(_2) )
         + native_props:not_fails.

has changed to
:- checked comp inc_all(_1,_2)
         : ( basic_props:list(_1,basic_props:int), term_typing:var(_2) )
         + native_props:not_fails.

}
{assertions checked in 51.992 msec.}
}
\end{verbatim}


\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Debugging with Global Analysis} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Simple bugs:
  \begin{itemize}
  \item Undefined predicates, discontiguous, multiple arity, \ldots
  \item Cannot be done without global analysis \& a robust module system.
  \end{itemize}
\item Checking programs against library interfaces:
  \begin{itemize}
  \item System predicates (builtin and library predicates):
    \begin{itemize}
    \item Intended behavior known in advance / usually assumed to be correct. 
%%     \item Their intended behavior is known in advance.
%%     \item They are usually assumed to be correct. 
%%     When debugging a
%%     program is usually a good idea to concentrate first on user
%%     predicates. 
    \end{itemize}
  
\item If interfaces of these predicates are available as \emph{assertions}, 
%% \vspace*{-1mm}
%%   \begin{itemize}
%% %%   \item E.g., for CHIPRE, the CHIP libraries have been annotated with
%% %%     assertions.
%%   \end{itemize}
%% 
%% \item As a result we can:
we can:
  \begin{itemize}
  \item automatically compare analysis results against these specs,
  \item (+ avoid analyzing the libraries over and over again). 
  \end{itemize}

\item Detects many bugs with no user burden (no need to use
  assert.\ language).
\item Can also be done with user-defined libraries!
\end{itemize}

\item We may be interested also in checking properties of our program.
  \begin{itemize}
  \item Price: adding {\em assertions} describing what we want checked
    (can be partial).

  \item Advantage: more errors detected and automatic documentation! 
%% assertions can be {\em partial},
\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Finding Bugs with Global Analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Checking the calls to built-ins and libraries:
\begin{verbatim}
main([X,Y]) :- q(X,N), Y is X+N.

q(1,_).
\end{verbatim}
%
with, e.g.,  mode analysis an error is flagged: \verb+N+ is not ground.

\begin{verbatim}
ciaopp ?- auto_check_assert(finding_bugs).
{Loading current module from finding_bugs.pl
}
{Analyzing finding_bugs.pl
{preprocessed for plai in 2.999 msec.}
{analyzed by plai using shfr in 4.999 msec.}
}
{Checking assertions of finding_bugs.pl
{In finding_bugs.pl
WARNING (preproc_errors): (lns 3-4) goal arithmetic:is(Y,X+N) at literal 2 
 does not succeed!
}
{assertions checked in 34.994 msec.}
}
{written file finding_bugs_eterms_shfr_co.pl}
\end{verbatim}

\item Checking program assertions:
\begin{verbatim}
:- pred p(X,Y) : list(num) * var 
              => list(num) * list(num)
               + not_fails.

p([],[]).
p([H|T],[NH|NT]) :- q(H,NH), p(T,NT).

q(H,NH) :- H > 0, NH = H+1.
q(H,NH) :- H < 0, NH = H-1.
\end{verbatim}
%
with, e.g., type analysis an error is flagged: \verb+Y+ is not a list
of numbers\\ 
({\tt is/2} should be used instead of {\tt =/2});\\ [2mm]
with, e.g., non-failure analysis an error is flagged: {\tt =</2}
should be used.
\end{itemize}

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Some Details on the Customization of the Preprocessor}
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%% \vspace*{-4mm}
%% \begin{itemize}
%% \item The preprocessor can be customized by adding:
%%   \begin{itemize}
%%   \item Syntactic extensions (e.g., {\em operator} declarations, expansions).
%%   \item Descriptions builtin and library predicates (assertions). 
%%   \item Domains for analysis of new properties.
%%   \end{itemize}
%%   
%% \item For efficiency the preprocessor can be specialized w.r.t. each
%%   particular dialect.
%% 
%% \item We use the {\em Generating Extension} Approach from partial evaluation:
%% \end{itemize}
%% 
%% \centerline{
%% \psfig{figure=/home/clip/Projects/esprit/DISCIPL/meetings/99_05_final_review/Assertions/btables.eps,width=0.80\textwidth}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion: Comparison with ``Classical'' Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Global analysis 
%% based on 
w/approximations:
%% has an 
important role 
%% to play, 
%% not only in optimization, but 
also in 
%% the 
program development.
%% cycle.

\item Allows going beyond straight-jacket of classical 
type systems (G\"{o}del, Mercury,\ldots):\\[3mm]
\begin{tabular}{||l|l||}
\hline
\hline
{\bf ``Traditional'' Types}               & {\bf Properties} \\
\hline
\hline
Compulsory (do not allow ``any'')  & Optional  (allow ``any'') \\
\hline
Expressed in a Special Language & Expressed in the Source Language \\
\hline
Limited Property Language       & Much More General Property Language \\
\hline
Limit Programming Language      & Do not Limit Programming Language \\
\hline
Untypable Programs Rejected     & Run-time Checks Introduced  \\
\hline
(Almost) Decidable              & Approximated \\
\hline
``check''                       & ``check'' or ``trust''  \\
\hline
\hline
\end{tabular}
\\[3mm]
\ldots without giving up much (types are included as just another kind of property).

\item Key issues:
\end{itemize}
\begin{tabular}{||l||l||}
\hline
\hline
Approximation            & Suitable assertion language \\
\hline
Abstract Interpretation  & Relating aproximations of actual and intended semantics\\
\hline
\hline
\end{tabular}

%% \item See pointers in ``{\tt http://www.clip.dia.fi.upm.es/}'' (also,
%%  paper(s) in env.\ WS).
%% \item Slides and pointers to several related papers form different 
%% authors available from {\tt http://www.clip.dia.fi.upm.es/} (see also
%% paper in environments workshop).

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PART III: Using Analysis Results in Program Optimization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Eliminating run-time work at compile-time.
  \begin{itemize}
  \item Low-level optimization.
  \item Abstract specialization/partial evaluation.\\
        Evaluating parts of the program based on abstract information.
  \item Abstract multiple specialization.\\
        Ditto on (possibly) multiple versions of each predicate.
  \end{itemize}
\item Automatic program parallelization: \\
      strict and non-strict Independent And-Parallelism.
%% \\
%%      (See tutorial on Parallel Logic Programming.)
\item Automatic task granularity control.
\item Optimization of other control rules / languages (e.g., Andorra).
\item Just for fun: generating documentation!
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{(Multiple) Specialization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Given the analysis output:
\begin{verbatim}
main :-
     ...,
     true(int(X)),
     ( ground(X) -> write(a) ; write(b) ),
     ...
\end{verbatim}
the \texttt{ground(X)} can be \emph{abstractly executed}
\nocite{abs-exec-lopstr} to \texttt{true}\\
and the whole conditional to \texttt{write(A)}.

\item Specializer is customizable, controlled by a table of ``abstract
  executability''. 

\item Can subsume traditional ``partial evaluation'':\\
      Given \texttt{true(X=list(a))}, then, e.g., \texttt{X=[a|Y]}
      $\rightarrow$ 
      \texttt{X=[\_|Y]}\\
      (no need to test that first element is an \texttt{a}).

\item Multiple specialization: creating multiple versions of
  predicates for different uses.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Slicing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Extracts predicates related to a given goal
\item Very useful when debugging or specializing programs
\item For example, take a look to the following program which defines
  an interpreter for a simple language

\begin{verbatim}
int(cst(X),_,_,X).
int(var(X),Vars,Vals,R) :- lookup(X,Vars,Vals,R).
int(plus(X,Y),Vars,Vals,Res) :- 
    int(X,Vars,Vals,RX), 
    int(Y,Vars,Vals,RY), 
    Res is RX-RY.
int(minus(X,Y),Vars,Vals,Res) :- 
    int(X,Vars,Vals,RX), 
    int(Y,Vars,Vals,RY), 
    Res is RX-RY.
int(fun(X),Vars,Vals,Res) :- 
    def0(X,Def), 
    int(Def,Vars,Vals,Res).
int(fun(X,Arg),Vars,Vals,Res) :- 
    def1(X,Var,Def), 
    int(Arg,Vars,Vals,ResArg),
    int(Def,[Var|Vars],[ResArg|Vals],Res).

def0(one,cst(1)).
def0(rec,fun(rec)).

def1(inc,xx,plus(var(xx),cst(1))).
def1(rec,xx,fun(rec,var(xx))).

lookup(X,[X|_],[Val|_],Val).
lookup(X,[Y|T],[_|ValT],Res) :-
    X \== Y, 
    lookup(X,T,ValT,Res).
\end{verbatim}
  
\item The following main entry point should return \verb+X = 3+ (the
  addition of constants 1 and 2), but returns \verb+X = -1+ instead:

\begin{verbatim}
main([X]):- int(plus(cst(1),cst(2)),[x],[1],X).
\end{verbatim}

\item We can compute a forward slice w.r.t.\ \verb+main/1+, getting the
  following program:

\begin{verbatim}
int(cst(X),_1,_2,X).
int(plus(X,Y),Vars,Vals,Res) :- 
    int(X,Vars,Vals,RX),
    int(Y,Vars,Vals,RY), 
    Res is RX-RY.
\end{verbatim}

\item This slice is much smaller than the original program, and allows
  us to easily detect that the definition for plus is wrong. 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Automatic Program Parallelization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Parallelization process \cite{effofai-toplas} starts with
  dependency graph:  
\begin{itemize}
%% \item vertices are goals,
\item edges exist if there can be a dependency,
\item conditions label edges if the dependency can be removed.
\end{itemize}

\item Global analysis:
reduce number of checks in conditions (also to true and false).

\item Annotation: encoding of parallelism in the target parallel
  language:\\[3mm] 
      {\tt g$_1$(\ldots), g$_2$(\ldots), g$_3$(\ldots)}\\

\centerline{\psfig{figure=figs/par_process_wide.ps,height=0.3\textwidth}}

\item {\em Example:}
\begin{verbatim}
qs([X|L],R) :- part(L,X,L1,L2), 
               qs(L2,R2), qs(L1,R1), 
               app(R1,[X|R2],R).
\end{verbatim}
Might be annotated in \&-Prolog (or Ciao Prolog), using local analysis, as:
\begin{verbatim}
qs([X|L],R) :- 
         part(L,X,L1,L2), 
         ( indep(L1,L2) -> 
              qs(L2,R2) & qs(L1,R1)
         ;    qs(L2,R2) , qs(L1,R1) ), 
         app(R1,[X|R2],R). 
\end{verbatim}
Global analysis would eliminate the \texttt{indep(L1,L2)} check.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\&-Prolog/Ciao parallelizer overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\centerline{
\psfig{figure=figs/apcompiler.ps,width=0.7\textwidth}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Granularity Control}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
\item Do not schedule tasks for parallel execution if they are too small.
\item Cannot be done well completely at compile-time:
work done by a call often depends on the size
of its input:
%% (difficult to approximate at compile time, 
%% even using abstract interpretation):
\vspace{-3mm}
 \begin{verbatim}  
q([],[]).
q([X|RX],[X1|RX1]) :- X1 is X +1,  q(RX,RX1).
\end{verbatim}

\item \underline{Approach} \cite{granularity-jsc}: 
       %% [DLH PLDI89, DLHL / LH TR94]:
\begin{itemize}
\item generate at compile-time {\em functions} (to be evaluated
at run-time) that efficiently approximate task size (upper and lower
bounds), 
\item transform programs to carry out run-time granularity control.
\item Note: size computations can be done on-the-fly
  \cite{termsize-iclp95}. %%  [ICLP 95]. 
\end{itemize}

\item Example (with {\tt q} above):
\vspace{-3mm}
\begin{verbatim}
..., q(X,Y) & r(X), ...
\end{verbatim}
\vspace{-1mm}
Cost = $2*length(X)+1$ (cost function $2*n+1$).  Assuming
\emph{threshold} is 4 units:
\vspace{-1mm}
\begin{verbatim}
..., length(X,LX), Cost is LX*2+1, 
     ( Cost > 4 -> q(X,Y) & r(Z)
                 ; q(X,Y),  r(X) ), ...
\end{verbatim}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Granularity Control System Output}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}

\item Term sizes can be computed ``on the fly'' for many programs:
\begin{verbatim}
g_qsort([], []).
g_qsort([First|L1], L2) :-
  partition3o4o(First, L1, Ls, Lg, Size_Ls, Size_Lg),
  ( Size_Ls > 20 -> 
    ( Size_Lg >  20 
     ->  g_qsort(Ls, Ls2) & g_qsort(Lg, Lg2)
      ;  g_qsort(Ls, Ls2),  s_qsort(Lg, Lg2)
    )
  ; ( Size_Lg > 20 
     ->  s_qsort(Ls, Ls2), g_qsort(Lg, Lg2)
      ;  s_qsort(Ls, Ls2), s_qsort(Lg, Lg2)
    )
  ),
  append(Ls2, [First|Lg2], L2).

partition3o4o(F, [], [], [], 0, 0).
partition3o4o(F, [X|Y], [X|Y1], Y2, SL, SG) :- 
    X =< F, 
    partition3o4o(F, Y, Y1, Y2, SL1, SG), 
    SL is SL1 + 1.
partition3o4o(F, [X|Y], Y1, [X|Y2], SL, SG) :- 
    X > F,  
    partition3o4o(F, Y, Y1, Y2, SL, SG1), 
    SG is SG1 + 1.
\end{verbatim}

\item Note: when term sizes are compared directly with a
       threshold:  not necessary to traverse all the terms involved,
       only to the point at which threshold is reached.
\end{itemize}

\newpage
\section*{Acknowledgements}

\begin{itemize}
\item Ciao/\texttt{ciaopp} is a collaborative effort:

     UPM, Melbourne/Monash (incremental analysis, \ldots), Arizona
     (cost  analyses, \ldots), SICS (engine) \\
     + Bristol, Link\"{o}ping, NMSU, Leuven, Beer-Sheva, \ldots 

\item Downloading \texttt{ciao}, \texttt{ciaopp},
  \texttt{ciaodoc/pl2texi}, and other CLIP software:
\begin{itemize}
  \item Standard distributions:\\  
     \htmladdnormallink{\texttt{http://www.clip.dia.fi.upm.es/Software}}
                       {http://www.clip.dia.fi.upm.es/Software}

  \item Betas (in testing or completing documentation --
    ask {\tt webmaster} for info): \\ 
    \htmladdnormallink{\texttt{http://www.clip.dia.fi.upm.es/Software/Beta}}
                       {http://www.clip.dia.fi.upm.es/Software/Beta}
%%     \begin{tabbing}
%%     \Underline{Username:} \ \ \ \= \texttt{clipsoft} \\
%%     \Underline{Password:}       \> \texttt{clipfriends}
%%     \end{tabbing}
  \item US Mirror: 
     \htmladdnormallink{\texttt{http://www.cs.nmsu.edu/\~{}clip/}\ldots}
                       {http://www.cs.nmsu.es/\~{}clip/}
     (in construction).

  \item User's mailing list: \\
     \htmladdnormallink{\texttt{ciao-users@clip.dia.fi.upm.es}}
                       {mailto:ciao-users@clip.dia.fi.upm.es} \\
        Subscribe by sending a message with only \texttt{subscribe} in
        the body to \\
     \htmladdnormallink{\texttt{ciao-users-request@clip.dia.fi.upm.es}}
                       {mailto:ciao-users-request@clip.dia.fi.upm.es} 
\end{itemize}

\end{itemize}


\newpage
%% \renewcommand{\biblstart}{}
\renewcommand{\refname}{Recent Bibliography on the ciaopp System Components}
{\normalsize
\bibliographystyle{plain}
\bibliography{/home/clip/bibtex/clip/clip,/home/clip/bibtex/clip/others}
}

\end{document}


:- module(parser_utils, _, [dcg, hiord]).

:- use_module(library(lists), [append/3]).

:- use_module(cafelito(java_lexer)).


% this is neccessary for not changing the order of the parameters 
% in a call of type 'zero_or_one(identifier("pepe"))' 
% which otherwise is transformed to identifier(S0,"pepe",SF) 
% 
% The AST generated by "element" is stored only in the case of 
% non-terminals and operator (to change, use flag 'ignore'). 
% For separators and keywords the behaviour can be modified 
% using flag 'store'. 
%  
% Rules are sorted according to their frequency 
match_el(X, ignore, S0, SF) :-
	functor(X, separator, 1), !,
	arg(1, X, P1),
	call(separator, P1, S0, SF).
match_el(X, ignore, S0, SF) :-
	functor(X, keyword, 1), !,
	arg(1, X, P1),
	call(keyword, P1, S0, SF).
match_el(X, Tree, S0, SF) :-
	functor(X, operator, 1), !,
	arg(1, X, P1),
	call(operator, P1, S0, SF),
	Tree = P1.
match_el(X, Tree, S0, SF) :-
	functor(X, Pred, 1), !,
	arg(1, X, P1),
	call(Pred, P1, S0, SF),
	Tree = P1.
match_el(X, Tree, S0, SF) :-
	functor(X, 'or', 2), !,
	X = 'or'(Opt1, Opt2),
	( match_el(Opt1, Tree, S0, SF) ->
	    true;
	    match_el(Opt2, Tree, S0, SF)
	).
match_el(X, ignore, S0, SF) :-
	functor(X, operator, 2), !,
	arg(1, X, P1),
	arg(2, X, ignore),
	call(operator, P1, S0, SF).

match([],    [],   SF, SF).
match([X|R], Tree, S0, SF) :-
	match_el(X, Tree_El, S0, S1),
	match(R, Rest_Tree, S1, SF),
	( Tree_El = ignore ->
	    Tree = Rest_Tree;

	    list(Tree_El) ->
	    append(Tree_El, Rest_Tree, Tree) ;
	    Tree = [Tree_El|Rest_Tree]
	).

% if we do not make a copy of the term  nasty unifications take place 
% eg: java.io.IOException against pattern zero_or_more(".",id(_X)) 
% in the first success _X is unified against "io" 
% thus now the pattern is really (".",id("io")) 
% next time match is invoked unification fails 
zero_or_more(Pattern, Tree, S0, SF) :-
	copy_term(Pattern, Pattern_Copy),
	match(Pattern, Tree_El, S0, S1), !,
	zero_or_more(Pattern_Copy, Rest_Tree, S1, SF),
	( Tree_El = [ignore] ->
	    Tree = Rest_Tree;
	    append(Tree_El, Rest_Tree, Tree)
	).
zero_or_more(_Pattern, [], SF, SF).

one_or_more(Pattern, Tree, S0, SF) :-
	copy_term(Pattern, Pattern_Copy),
	match(Pattern, Tree_El, S0, S1), !,
	zero_or_more(Pattern_Copy, Rest_Tree, S1, SF),
	( Tree_El = [ignore] ->
	    Tree = Rest_Tree;
	    append(Tree_El, Rest_Tree, Tree)
	).

zero_or_one(Pattern, Tree, S0, SF) :-
	match(Pattern, Tree, S0, SF), !.
zero_or_one(_Pattern, [], SF, SF).

% Actual line, called as any other DCG rule 
line(L, (S, L), (S, L)).

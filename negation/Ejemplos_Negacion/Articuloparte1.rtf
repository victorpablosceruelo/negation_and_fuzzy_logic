{\rtf1\ansi\ansicpg1252\deff0\deflang1034{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset0 Times New Roman;}{\f2\fmodern\fprq1\fcharset0 Courier New;}{\f3\fswiss\fprq2\fcharset0 Arial Narrow;}}
\viewkind4\uc1\pard\f0\fs12\par
\pard\sl-120\slmult0\f1\par
\pard\sl-220\slmult0\ul\f0\fs18 ---,- \ulnone -\par
\pard\fi504\sb62\sl-681\slmult0\fs64 /\par
\pard\fi6048\sb710\sl-278\slmult0\b\f1\fs24 Examples\par
\pard\fi-288\li1944\sb230\sl-196\slmult0\b0\fs18 l. The following program shows that constructive negation can finitely fails whereas the "delay technique" produces infinite computation\par
\pard\fi1944\sb240\sl-196\slmult0\f2\fs20 p(a). % File delay.pnt in programs:zip\par
\pard\fi1944\sb43\sl-196\slmult0\f1\fs18 p(f(X)):- p(X).\par
\pard\fi2016\sb33\sl-196\slmult0 r (X) : -! s (X) .\par
\pard\fi1944\sb28\sl-196\slmult0\f2\fs20 s(g(X)) .\par
\pard\li1944\sb216\sl-230\slmult0\f1\fs18 Both questions: ! r (X) , P (X). and p (X) , ! r (X). produce an immediate fail in the BCN prototype. However. the "the delay technique" checks if each answer for p (X) is a finite failure of r (X) (which, indeed, is the case), producing an infinite number of checks.\par
\pard\fi1584\sb211\sl-230\slmult0 2. The following program is a typical example of recursion through negation:\par
\pard\fi1944\sb216\sl-230\slmult0\f2\fs20 even(O). % File even.pnt in programs.zip\par
\pard\fi1944\sl-211\slmult0\f1\fs18 even(s(X) ).:- ! even(X).\par
\pard\fi2808\sb124\sl-211\slmult0\fs12 .'\par
\pard\li1944\sl-235\slmult0\fs18 Both questlons ! even ( Z) .and ! even (Z) , even (s (Z) ) ., conducted by the BCN prototype, produce the answers:\par
\pard\fi3168\sb19\sl-235\slmult0\f2\fs20 .Z = s(O);\par
\pard\fi3168\sb124\sl-235\slmult0 .Z = s(s(s(O)));\par
\pard\fi3168\sb120\sl-235\slmult0 .Z = s(s(s(s(s(O)))));\par
\pard\fi288\sb100\sl-235\slmult0\f1\fs18 j and so on\par
\pard\fi72\li2088\sb350\sl-220\slmult0 However, the question ! even (Z) , ! even (s (Z)). produces infinite computation (without answers). This is the expected behaviour if we consider the declarative semantics given by the three-valued logical consequences of program completion.\par
\pard\fi1584\sb225\sl-220\slmult0 3. A similar behaviour is shown by the following definite program:\par
\pard\fi1944\sb216\sl-220\slmult0\f2\fs20 less(O,s(Y\}). %File less.pnt in programJ.zip\par
\pard\fi1944\sb14\sl-220\slmult0\f1\fs18 less(s(X),s(Y)):- less(X,Y).\par
\pard\fi1944\sb211\sl-220\slmult0 The BCN-answers for the question ! less (X, Y) are:\par
\pard\fi3168\sb76\sl-220\slmult0 .X=O,Y=_A,_A~s(*B);\par
\pard\li3168\sl-283\slmult0 .X = s (_A), Y = _B, _B ~ s (*-C) ; .X=s(s(_A)),Y=s(_B),_B~s(*C);\par
\pard\fi3168\sl-216\slmult0 .X = s(O), Y = s(_A), _A ~ s(*B);\par
\pard\fi3168\sb43\sl-216\slmult0 .X = s(s(s(_A))), y = s(s(_B))-, _B ~ s(*C);\par
\pard\fi3168\sb28\sl-216\slmult0 .X = s (s (O)), y = s (s (~)), _A ~ s (*B);\par
\pard\fi3168\sb38\sl-216\slmult0 .X = s(s(s(s(_A)))), y = s(s(s(_B))), _B ~ s(*C);\par
\pard\fi3744\sb19\sl-216\slmult0 and so on\par
\pard\fi2088\sb230\sl-216\slmult0 whereas the question ! less (X, s (X) ) produces (as expected) infinite computation (without answers).\par
\pard\fi7560\sb2112\sl-216\slmult0\f3\fs36 .\par
\pard\f0\fs12\par
\pard\sl-120\slmult0\f1\par
\pard\sl-259\slmult0\ul\f0\fs22 -\par
\pard\fi1440\sb1632\sl-220\slmult0\ulnone\f1\fs18 4. The following is a definite program to compute even (and odd) numbers in a different way:\par
\pard\li1800\ri1008\sb177\sl-220\slmult0\qj\f2 sum(O,X,X). % File evenbysum.pnt in programs.~ip\par
\pard\fi-1800\li1800\ri5976\sb76\sl-206\slmult0\qj\f1 sum(s(X),Y,s(Z)):- sum(X,Y,Z). \f2 even_by_sum(X):- ' sum(Y,Y,X).\par
\pard\fi1800\sb206\sl-206\slmult0\f1 Thequestion !sum\{Zl,Z2,Z3) gives:\par
\pard\li3024\sl-403\slmult0\f2 .Zl = O, Z2 = _A, Z3 = _B, _B ;!: _A; \f1 .Zl=s(~),Z3=_B,_B;!:S(*C);\par
\pard\fi3024\sl-336\slmult0 .Zl = s\{s(_A)), Z3 = s(_8), _B;!: s(*C);\par
\pard\fi3024\sb28\sl-336\slmult0 .Zl = s(O), Z2 = _A, Z3 = s\{_B), _B ;!: _A;\par
\pard\fi504\sb33\sl-336\slmult0 -.Zl = s\{s\{s\{_A))), Z3 = s\{s\{_B)), _B ~ s(*C);\par
\pard\fi3096\sb33\sl-336\slmult0 .Zl = s\{s\{O)), Z2 = _A, Z3 = s\{s\{_B)), _8;!: _A;\par
\pard\fi3096\sb38\sl-336\slmult0 .Zl";' s\{s(s\{s\{_A)))), Z3 = s(s\{s(_B))), _B;!: s(*C);\par
\pard\fi3024\sb33\sl-336\slmult0 ..,. and so on\par
\pard\fi1800\sb235\sl-336\slmult0 and the question ! even_by _sum ( Z ) gives:\par
\pard\fi3096\sb33\sl-336\slmult0 .Z = _A, _A;!: s(s(*B)), _A;!: O; (equivalentto Z=s\{O\};)\par
\pard\fi-576\li3672\sb4\sl-364\slmult0 .Z = s\{s(_A)), _A;!: O, _A;!: s\{s\{*B)); (equivalentto Z=s\{s\{s(O)));) and so on\par
\pard\fi1512\sb196\sl-364\slmult0 5. The following program produces very big computation trees:\par
\pard\fi-72\li1872\sb100\sl-283\slmult0\f2 evennumf(a) % File evennumf.pnt in programs.zip evennumf(f(X,Y)):- evennumf\{X),\par
\pard\fi4104\sl-201\slmult0 ! evennumf(Y).\par
\pard\fi1872\sb19\sl-201\slmult0 evennumf(f(X,Y)):- ! evennumf\{X),\par
\pard\fi4104\sb9\sl-201\slmult0 evennumf(Y) .\par
\pard\fi1872\sb235\sl-201\slmult0\f1 The question ! evennumf ( Z) has infinitely many answers. The BCN prototype produces them as tollows:\par
\pard\fi3096\sb192\sl-201\slmult0\f2\fs20 .Z = f(a,a);\par
\pard\fi3096\sb153\sl-201\slmult0\f1\fs18 .Z = f(f(a,a),f(a,a));\par
.Z = f(f(a,a),f(f(a,a),f\{a,a)));\par
\pard\fi3096\sb158\sl-201\slmult0 .Z = f\{f\{a,f\{a,a)),a);\par
\f2 .Z = f(f\{f\{a,a),a),a);\par
\f1 .Z = f(a,f\{f\{a,a),a));\par
\pard\fi3096\sb163\sl-201\slmult0 .Z = f(a,f(a,f(a,a));\par
.Z = f(f(f(a,a),f\{a,a)),f\{a,a));\par
\pard\fi3096\sb158\sl-201\slmult0 .Z = f(f\{f\{a,a),f\{a,a)),f\{f\{a,a),f\{a,a)));\par
.Z = f(f(f\{a,a),a),f(f(a,a),a));\par
\pard\sb177\sl-201\slmult0 I and so on\par
\pard\sb484\sl-201\slmult0\f0\fs34\'a1\par
\pard\sb216\sl-201\slmult0\fs22 j ~\par
\pard\sb297\sl-201\slmult0\fs14 I\par
\pard\sb48\sl-201\slmult0\f3\fs20 I\par
\pard\sl-115\slmult0\f1\fs8\'a1\par
\pard\sb9\sl-86\slmult0\f0\fs10 I\par
\pard\sb297\sl-86\slmult0\f3\fs14 1-\par
\pard\f0\fs12\par
\pard\sl-120\slmult0\f1\par
\pard\fi1512\sl-220\slmult0\fs18 6. The following program was introduced in\par
\pard\fi2736\sl-220\slmult0 W. Drabent., \i What is,failure?An approach to constructive negation,\par
\i0 Acta lnformatica, 32:27-59,1995.\par
\pard\fi1872\sb206\sl-220\slmult0\f2 r:- ! p(X),! q(X). % File Drabent.pnt in programs.zip\par
\pard\fi1872\sl-220\slmult0\f0 p (X) : -p (X) .\par
\f2 p(a) ,\par
\f0 q (a) : -q(a).\par
\f1 q(X):- !s\{X).\par
\pard\fi1872\sb9\sl-240\slmult0\f2\fs20 s (a),\par
\pard\fi1872\sl-220\slmult0\fs18 w(f(X)) " % We have added this clause to extend the signature with f/l, because\par
\pard\fi2952\sl-220\slmult0 % the BCN prototype infers the signature from the program and the goal,\par
\pard\fi1872\sb230\sl-220\slmult0\f1 It can be checked that:\par
\pard\fi3096\sb19\sl-220\slmult0 .! r. One answer : True;\par
\pard\fi3096\sb134\sl-220\slmult0 .r. fails\par
\pard\fi1512\sb340\sl-220\slmult0 7. The following program was introduced in\par
\pard\fi2736\sl-220\slmult0 R.Bart\'e1k, Constructive Negation in CLP(H) , Technical Report No 98/6,\par
Dept. ofTheoretical Computer Science, Charles Univ., Prague, July 1998.\par
\pard\fi2808\sb28\sl-220\slmult0 (http://kti. ms.mff.cuni.czJ ~bartak/html/negation.html)\par
\pard\fi1872\sl-220\slmult0 where you can find a prototype for constructive negation restricted to the case of finite computation trees:\par
\pard\li1872\sb168\sl-244\slmult0\f2 p(a,f(Z)):- t(Z). % File Bartak.pnt in prograrns,zip p(f(Z),b):- t(Z).\par
\pard\fi1872\sl-230\slmult0\fs16 t (c) ,\par
\pard\fi1872\sb216\sl-230\slmult0\f1\fs18 The question ! p (X, Y), in the BCN prototype produces the following five answers:\par
\pard\fi3096\sb148\sl-230\slmult0 .X = a, Y = _A, _A * f(*B);\par
\pard\fi3096\sb144\sl-230\slmult0\f2 .X = f(_A), y = _B, _B * b;\par
.X = _A, _A * f'(*B), _A * a;\par
\pard\fi3096\sb129\sl-230\slmult0 .X = a, Y = f(_A), _A * c;\par
\pard\fi3096\sb139\sl-230\slmult0 .X = f(_A), Y = b, _A * c;\par
\pard\fi1872\sb105\sl-230\slmult0\f1 whose disjunction is equivalent to the disjunction ofthe four answers produced by Bart\'e1k's prototype.\par
\pard\li1872\sl-225\slmult0 Our answers are more general than Bart\'e1k's ones. This is a consequence ofthe fact that our procedural method works tor intinite computation trees, as well as for finite ones.\par
\pard\fi288\sb446\sl-225\slmult0 , 8. The following program was introduced in\par
\pard\li2736\sl-225\slmult0 A. Bossi, M. Fabris and M.C. Meo, \i A bottom-up semanticsforconstructive negation, \i0 In P."V. Hentenryck, editor, \i Proceedings ofthe 11th 1nternational Conference on Logic Programming (ICLP \i0 '94), pages 520-534, MIT Press, 1994.\par
\pard\li2016\sb158\sl-249\slmult0\f2 p(f(V), Y):- q(V). % File in Bossietal.pnt in prograrns.zip \f1 p(X,g(W)):- !r(W).\par
\pard\fi2016\sl-225\slmult0\fs14 cq.(a) ,\par
\pard\li2016\ri6840\sb38\sl-216\slmult0\qj\fs18 r(b):- r(b). r(c):- r(c). \f2 r(c) .\par
\pard\fi2088\sb201\sl-216\slmult0\f1 It can be checked that the BCN prototype behaves as foIlows:\par
\pard\fi3096\sb28\sl-216\slmult0 .!p(f(a),Y). fails\par
\pard\sl-216\slmult0\f0\fs14 I\par
\pard\sb24\sl-110\slmult0\f1\fs18 , .!p(a,c). Oneanswer:True\par
\pard\fi3096\sb273\sl-110\slmult0 .! r (c). fails '\par
\pard\sb1886\sl-110\slmult0\ul\f0\fs26 -\par
}
 
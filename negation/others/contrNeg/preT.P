% Preprocessor for abduction interpreter
%
% 24/9/98
%


/*
 Syntax:
 
 Rules are of the form:
        Head <- Body.
 where Head is an atom and Body a conjunction of literals separated by ,
 A literal is either an atom A, or a default literal not A.

Integrity constraints are of the form:
	<- Body.
 or rules where the head is the special (reserved) atom 'false'.

Abducibles are declared by facts:
	abds(ListOfAbds)
where ListOfAbds is the list of predicateName/arity which are abducible. Abducible predicates CANNOT appear in the head of rules.

If several declarations exists in the same file, their union is considered.
*/
 
/*
 Usage:

 generateP(FileName) -> preproprocesses FileName.ab into the file FileName.P.
				FileName is a string.
 
 abdSol(G,Ab) -> returns in Ab an abductive solutions for G.
*/


:- import ground/1, append/3, member/2, length/2 from basics.
:- import variant/2 from subsumes.

:- dynamic hasRules/1, rule/2, abds/1, inBody/1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Operators definition                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- op(950,fy , not ).           % Negation as failure
:- op(1110,xfy, '<-' ).         % Rule symbol
:- op(1110,yf , '<-' ).         % Rule symbol
:- op(1110,fy , '<-' ).         % Rule symbol

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Erasing all consulted rules            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clean :- 
	retractall(rule(_,_)), retractall(hasRules(_)),retractall(inBody(_)),
	retractall(abds(_)), 
	assert(inBody(false)). % false appears in the body of topgoal rules

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Consulting a file                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

generateP(FileName) :-
        clean,
        seeAbFile(FileName),
        tellPFile(FileName),
        loadClauses,
        seen,
        processProgram,
	  told.

seeAbFile(FileName) :-
	append(FileName,".ab",FExt),
	name(F,FExt),
	see(F).

tellPFile(FileName) :-
	append(FileName,".P",FExt),
	name(F,FExt),
	tell(F), writeHeader.

writeHeader :-
%	write(':- [metaNew].'), nl,
	write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'),nl,
	write('%  This program was generated by the preprocessor       %'),nl,
	write('% for       abduction.                                  %'),nl,
	write('%                                                       %'),nl,
	write('% Jose Alferes, 24/09/98                                %'),nl,
	write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'),nl,nl,
	write('/* The original program was:'),nl,nl.

loadClauses :-
    read(C),
    ( C = end_of_file -> writeBegin;
      ( loadClause(C), write(C), write('.'), nl, loadClauses ) ).
        
writeBegin :-
	write('*/'),nl,nl,
	write(':- op(1100,xfy,''<-'').'), nl,
	write(':- reconsult(metaAb).'),nl, nl,
	write('abducible(_) :- fail.'),nl,nl.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                 Loading one clause                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Declarations
loadClause(abds(L)) :- !,
        get_Decl(abds(L1),L1),
        append(L,L1,NewL),
        my_assert(abds(NewL)).

% ICs

loadClause(( <- B)) :- !,
	loadClause((false <- B)).

% Rules
loadClause((H <- B)) :- !,
	assertHasRules(H), loadBody(B),
	my_assert(rule(H,B)).

% Facts
loadClause(H) :- !,
	assertHasRules(H),
	my_assert(rule(H,true)).

loadBody(((not A),B)) :- !,
	assertInBody(A), loadBody(B).
loadBody((A,B)) :- !,
	assertInBody(A), loadBody(B).
loadBody((not A)) :- !,
	assertInBody(A).
loadBody(A) :-
	assertInBody(A).


assertHasRules(H) :-
	one_template(H,HH),
	assertIfNot(hasRules(HH)).

assertInBody(H) :-
	one_template(H,HH),
	assertIfNot(inBody(HH)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Adding failure rules from predicates with none  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

write_FailRules :-
	retract(inBody(L)), 
	hasNoRules(L),
	processLit(not(L),I,I,NPL),
	write(NPL), write('<- true.'), nl,
	writeLastVars(L),
	fail.
write_FailRules.

hasNoRules(L) :-
	\+ hasRules(L),
	\+ is_abducible(L).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Processing and asserting the program          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

processProgram :-
	write_FailRules,
	write_abds,
	write_coherence_axioms,
	write_rules.

write_coherence_axioms:-
	hasRules(-H),hasRules(H),
	processAtom(H,_I,_O,ProH),
	writeL([not ProH,' <- ',-ProH,'.']),
	writeL([not -ProH,' <- ',ProH,'.']),
	fail.
write_coherence_axioms.

get_rule_heads(H):-
	rule(H,_),
	\+ (H = -(_)).


write_abds :-
	nl,
	get_sol(abds(LAb),LAb),
	write_abd_rules(LAb).

write_abd_rules([]).
write_abd_rules([N/A|L]) :-
	functor(Ab,N,A), processLit(Ab,I,O,AbH),
	writeL(['abducible(',Ab,').']),
	writeL(['(',AbH,' <- true) :- insert(',Ab,',',I,',',O,').']),
	writeL(['(',not(AbH),' <- true) :- insert(',not(Ab),',',I,',',O,').']),
	writeLastVars(Ab),
	write_abd_rules(L).

write_rules :-
	retract(hasRules(H)), !,
	writeLastVars(H),
	find_rules(H,R),
	write_pos_rules(R),
	write_neg_rules(H,R),
	write_rules.


write_rules.

find_rules(H,R) :-
	findall(rule(H,B),clause(rule(H,B),true),R).

write_pos_rules([]).
write_pos_rules([rule(H,B)|Rs]) :- write_pos_rule(H,B,true), write_pos_rules(Rs).

write_pos_rule(H,true,Code) :- !,
	processLit(H,I,I,ProH),
	(Code = true -> writeL([ProH,' <- true.']);
                      writeL(['(',ProH,' <- true) :- ',Code,'.'])).

write_pos_rule(H,BB, Code) :-
	flattenConj(BB,B),
	processBody(B,ProB,I,O),
	processLit(H,I,O,ProH),
	(Code = true -> writeL([ProH, ' <- ', ProB,'.']);
			    writeL(['(',ProH, ' <- ', ProB,') :- ', Code,'.'])).

processBody((A,B),(ProA,ProB),I,O) :-
	!, processLit(A,I,OA,ProA),
	processBody(B,ProB,OA,O).
processBody(A,ProA,I,O) :-
	processLit(A,I,O,ProA).


processLit(true,I,I,true) :- !.
processLit(not(H),I,O,not(ProH)) :- !,
	processAtom(H,I,O,ProH).
processLit(H,I,O,ProH) :-
	processAtom(H,I,O,ProH).


processAtom(Term,I,O,-ProH) :- 
	nonvar(Term),Term = -H,!,
	H =.. [Name|Vars], append(Vars,[I,O],NVars),
	ProH =.. [Name|NVars].
processAtom(H,I,O,ProH) :-
	H =.. [Name|Vars], append(Vars,[I,O],NVars),
	ProH =.. [Name|NVars].



write_neg_rules(H,Rs) :-
	write_top_neg(H,Rs,RLits),
	write_n_rules(H,Rs,RLits).

% write_top_neg(+HeadLiteral,+SetofRules,-GeneratedRuleNameAtoms)

write_top_neg(H,Rs,RLits) :-
	create_top_neg_body(Rs,H,Body,RLits,1,[],RefList,0,Cont),
	(Cont=0 -> write_pos_rule(not(H),Body,true);
			     write_pos_rule(not(H),Body,genNumbers(Cont,RefList))).

create_top_neg_body([rule(RH,RB)],H,NLitF,[NLit],N,RL,NewRL,Cont,NewCont) :- !, 
	create_rule_lit(RH,RB,H,NLit,F,N),
      getLitF(NLit,F,NLitF,RL,NewRL,Cont,NewCont).
create_top_neg_body([rule(RH,RB)|Rules],H,(NLitF,NLits),[NLit|Lits],N,RL,NRL,C,NC) :-
	create_rule_lit(RH,RB,H,NLit,F,N),
      getLitF(NLit,F,NLitF,RL,RLL,C,CC),
	N1 is N + 1, create_top_neg_body(Rules,H,NLits,Lits,N1,RLL,NRL,CC,NC).

getLitF(NLit,sys_free([],_),NLit,RL,RL,C,C) :- !.
getLitF(NLit,sys_free(F,H),(NLit,sys_free(R,F,H-F)),RL,[R|RL],C,NewC) :- 
	NewC is C + 1.

create_rule_lit(RH,RB,H,not(NLit),sys_free(F,H),N) :-
	create_name_rule(H,N,Vars,NewName),
	RH =.. [_|VH], 
	getTermVars(RB,VB), getTermVars(VH,VarsH),
	getFreeVars(VB,VarsH,F), append(Vars,F,NewVars),
	NLit =.. [NewName|NewVars],
	writeLastVars(NLit), writeIsRulePred(NLit).

create_name_rule(H,N,Vars,NewName) :- 
	H \= -(_), !,
	H =.. [Name|Vars],
	name(Name,S), name(N,SN),
	append(S,SN,NumS),
	name(NewName,[114,117,108,101,95|NumS]).    % [114,117,108,101,95] = "rule_"

create_name_rule(H,N,Vars,NewName) :- 
	H = -HH,
	HH =.. [Name|Vars],
	name(Name,S), name(N,SN),
	append(S,SN,NumS),
	name(NewName,[114,117,108,101,95,110,101,103,95|NumS]).
		   % [114,117,108,101,95,110,101,103,95] = "rule_neg_"



getFreeVars([],_,[]).
getFreeVars([VB|VBs],VHs,[VB|F]) :-
	\+ in_var(VB,VHs), !, getFreeVars(VBs,VHs,F).
getFreeVars([_|VBs],VHs,F) :-
	getFreeVars(VBs,VHs,F).


write_n_rules(_,[],[]).
write_n_rules(H,[rule(HR,Body)|Rules],[NHead|NHeads]) :-
	write_ineq_rule(HR,H,NHead),
	\+ \+ write_not_rule(NHead,HR,H,Body),
	write_n_rules(H,Rules,NHeads).

write_ineq_rule(HR,H,_) :-
	variant(H,HR), !.
write_ineq_rule(HR,H,NHead) :-
	processLit(NHead,I,O,ProNH),
	generateDifCl(HR,H,I,O,DL), !,
	writeL(['(',ProNH,' <- true ) :- ',DL,'.']).
write_ineq_rule(_,_,_). 

generateDifCl(Head,Call,I,O,DL) :-
	all_desunify(Call,Head,Des),
	processDesList(Des,I,O,Call,DL).

processDesList([LConj],I,O,Head,Conj) :- !,
	processDesConj(LConj,I,O,Head,Conj).
processDesList([LConj|L],I,O,Head,(Conj;Disj)) :-
	processDesConj(LConj,I,O,Head,Conj),
	processDesList(L,I,O,Head,Disj) .

processDesConj([],I,I,_,true).
processDesConj([A=B],I,I,_,(A=B)) :- !.
processDesConj([A\=B],I,O,H,dif(A,B,H,I,O)) :- !.
processDesConj([A=B|L],I,O,H,(A=B,C)) :- processDesConj(L,I,O,H,C).
processDesConj([A\=B|L],I,O,H,(dif(A,B,H,I,I1),C)) :- processDesConj(L,I1,O,H,C).


/*
generateDifCl(HR,H,I,O,DL) :-
	findall(Ineq-HR-H,oneDisj(HR,H,Ineq),IList),
	includeEqual(IList,HR,H,true,I,O,DL).

oneDisj(H1,H2,Ineq) :-
	nonvar(H1), nonvar(H2), H1 =.. [F|Args1], H2 =.. [F|Args2], !,
	member(A1,A2,Args1,Args2), \+ (A1 == A2),
	oneDisj(A1,A2,Ineq).
oneDisj(H1,H2,(H1\=H2)).

includeEqual([(T1\=T2)-HR-H],HR,H,Prev,I,O,(Prev,dif(T1,T2,I,O))) :- !.
includeEqual([(T1\=T2)-HR-H|Ineq],HR,H,Prev,I,O,(Prev,dif(T1,T2,I,O);DIneq)) :-
	includeEqual(Ineq,HR,H,(T1=T2,Prev),I,O,DIneq).
*/

member(X,Y,[X|_],[Y|_]).
member(X,Y,[_|TX],[_|TY]) :- member(X,Y,TX,TY).

/********************** DOES NOT UNIFY ***********************/

all_desunify(Call,Head,Des) :-
	retractall('$prevDesun'(_,_,_)), 	assert('$prevDesun'(Call,Head,[])), 
	all_desAux(Call,Head,Des).

all_desAux(Call,Head,_) :-
	desunify(Call,Head,Des), sort(Des,DesS),
	updatePrevDesun(Call,Head,DesS),
	fail.
all_desAux(Call,Head,Prev) :-
	retract('$prevDesun'(Call,Head,Prev)).

updatePrevDesun(Call,Head,DesS) :-
	retract('$prevDesun'(Call,Head,Prev)),
	( \+ \+ cons_in_list(Call,DesS,Prev) ->
		assert('$prevDesun'(Call,Head,Prev));
		assert('$prevDesun'(Call,Head,[DesS|Prev]))).

:- import numbervars/3 from num_vars.

cons_in_list(Call,Des,Prev) :-
	numbervars(Call,0,_),
	countVars(Des,N),
	member(Des,Prev),
	countVars(Des,N).

:- import desunify/3 from desunify.



/*************************************************************/

write_not_rule(_,_,_,true) :- !.
write_not_rule(NHead,H,H,Body) :-
	processLit(NHead,I,O,ProNH),
	processNegBody(Body,ProNB,I,O),
	writeL([ProNH, ' <- ', ProNB,'.']).


processNegBody((A,B),(ProA;ProB),I,O) :-
	!, negLit(A,NA), processLit(NA,I,O,ProA),
	processNegBody(B,ProB,I,O).

processNegBody(A,ProA,I,O) :-
	negLit(A,NA),processLit(NA,I,O,ProA).
	

	
writeLastVars(A) :-
	processAtom(A,I,O,PA),
	writeL(['lastVars(',A,',[',I,',',O,'],',PA,').']), 
	writeL(['lastVars(',not(A),',[',I,',',O,'],',not(PA),').']), !.

writeIsRulePred(A) :-
	writeL(['is_rulePred(',A,').']).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Auxiliar predicates                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get_Decl(D,_) :- retract(D), !.
get_Decl(_,[]).

get_sol(G,_) :- G, !.
get_sol(_,[]).

assertIfNot(G) :- G, !.
assertIfNot(G) :- my_assert(G).

one_template(Term,-TG) :-
	nonvar(Term),Term = -G,!,
	functor(G,N,A), functor(TG,N,A).
one_template(G,TG) :-
	functor(G,N,A), functor(TG,N,A).

my_assert(G) :- assert(G).


is_abducible(G) :-
	functor(G,N,A), get_sol(abds(L),L), member(N/A,L).

negLit((not A),A) :- !.
negLit(A,(not A)).

flattenConj(Conj,FConj) :-
	conj2list(Conj,L), list2conj(L,FConj).

conj2list((A,B), L) :- !,
	conj2list(A,LA), conj2list(B,LB), append(LA,LB,L).
conj2list(true,[]) :- !.
conj2list(A,[A]).

list2conj([],true).
list2conj([A],A) :- !.
list2conj([A|L],(A,B)) :- list2conj(L,B).

writeL([]) :- nl.
writeL([H|L]) :- write(H), writeL(L).


getTermVars(Term,[]) :- ground(Term), !.
getTermVars(Var,[Var]) :- var(Var), !.
getTermVars(Term,Vars) :-
	Term =.. [_|Args],
	getListVars(Args,Vars).

getListVars([],[]).
getListVars([A|As],Vars) :-
	getTermVars(A,AV),
	getListVars(As,LV), mergeVars(AV,LV,Vars).

mergeVars([],V,V).
mergeVars([V|Vs],LV,Vars) :-
	\+ in_var(V,LV), !, mergeVars(Vs,[V|LV],Vars).
mergeVars([_|Vs],LV,Vars) :-
	mergeVars(Vs,LV,Vars).

in_var(V,[VV|_]) :- V == VV, !.
in_var(V,[_|Vs]) :- in_var(V,Vs).

var_in_term(V,Term) :- V == Term.
var_in_term(V,Term) :- nonvar(Term), Term =.. [_|Args], var_in_termList(V,Args).

var_in_termList(V,[T|_]) :- var_in_term(V,T).
var_in_termList(V,[_|L]) :- var_in_termList(V,L).

countVarOcc(_,Term,0) :- ground(Term), !.
countVarOcc(Var,Term,1) :- Term == Var, !.
countVarOcc(_,Var,0) :- var(Var), !.
countVarOcc(Var,Term,N) :-
	Term =.. [_|Args], countVarOccList(Var,Args,N).

countVarOccList(_,[],0).
countVarOccList(Var,[Term|List],N) :-
	countVarOcc(Var,Term,NT), countVarOccList(Var,List,NL), N is NT+NL.


clean_term(Term,Clean) :- functor(Term,F,A), functor(Clean,F,A).


countVars(Vars,N) :-
	copy_term(Vars,V),
	numbervars(V,0,N).

listlist2disjconj([L],Conj) :- list2conj(L,Conj).
listlist2disjconj([C|L],(Conj;DL)) :-
	list2conj(C,Conj),listlist2disjconj(L,DL).


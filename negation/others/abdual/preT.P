% Preprocessor for abduction interpreter
%
% 24/9/98
%


/*
 Syntax:
 
 Rules are of the form:
        Head <- Body.
 where Head is an atom and Body a conjunction of literals separated by ,
 A literal is either an atom A, or a default literal not A.

Integrity constraints are of the form:
	<- Body.
 or rules where the head is the special (reserved) atom 'false'.

Abducibles are declared by facts:
	abds(ListOfAbds)
where ListOfAbds is the list of predicateName/arity which are abducible. Abducible predicates CANNOT appear in the head of rules.

If several declarations exists in the same file, their union is considered.
*/
 
/*
 Usage:

 generateP(FileName) -> preproprocesses FileName.ab into the file FileName.P.
				FileName is a string.
 
 abdSol(G,Ab) -> returns in Ab an abductive solutions for G.
*/


:- import append/3, member/2 from basics.
:- dynamic hasRules/1, rule/2, abds/1, inBody/1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Operators definition                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- op(950,fy , not ).           % Negation as failure
:- op(1110,xfy, '<-' ).         % Rule symbol
:- op(1110,yf , '<-' ).         % Rule symbol
:- op(1110,fy , '<-' ).         % Rule symbol

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%             Erasing all consulted rules            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clean :- 
	retractall(rule(_,_)), retractall(hasRules(_)),retractall(inBody(_)),
	retractall(abds(_)), 
	assert(inBody(false)). % false appears in the body of topgoal rules

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Consulting a file                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

generateP(FileName) :-
        clean,
        seeAbFile(FileName),
        tellPFile(FileName),
        loadClauses,
        seen, % Close stdin
        processProgram,
	told. % Close stdout

seeAbFile(FileName) :-
	append(FileName,".ab",FExt),
	name(F,FExt), % Convert string to file name
	see(F). % Open this file for stdin

tellPFile(FileName) :-
	append(FileName,".P",FExt),
	name(F,FExt), % Convert string to file name
	tell(F), % Open this file for stdout
	writeHeader.

writeHeader :-
%	write(':- [metaNew].'), nl,
	write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'),nl,
	write('%  This program was generated by the preprocessor       %'),nl,
	write('% for       abduction.                                  %'),nl,
	write('%                                                       %'),nl,
	write('% Jose Alferes, 24/09/98                                %'),nl,
	write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'),nl,nl,
	write('/* The original program was:'),nl,nl.

loadClauses :-
    read(C),
    ( C = end_of_file -> writeBegin;
      ( loadClause(C), write(C), write('.'), nl, loadClauses ) ).
        
writeBegin :-
	write('*/'),nl,nl,
	write(':- op(1100,xfy,''<-'').'), nl,
	write(':- reconsult(metaAb).'),nl, nl,
	write('abducible(_) :- fail.'),nl,nl.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                 Loading one clause                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Declarations
loadClause(abds(L)) :- !,
        get_Decl(abds(L1),L1),
        append(L,L1,NewL),
        my_assert(abds(NewL)).

% ICs

loadClause(( <- B)) :- !,
	loadClause((false <- B)).

% Rules
loadClause((H <- B)) :- !,
	assertHasRules(H), loadBody(B),
	my_assert(rule(H,B)).

% Facts
loadClause(H) :- !,
	assertHasRules(H),
	my_assert(rule(H,true)).

loadBody(((not A),B)) :- !,
	assertInBody(A), loadBody(B).
loadBody((A,B)) :- !,
	assertInBody(A), loadBody(B).
loadBody((not A)) :- !,
	assertInBody(A).
loadBody(A) :-
	assertInBody(A).


assertHasRules(H) :-
	one_template(H,HH),
	assertIfNot(hasRules(HH)).

assertInBody(H) :-
	one_template(H,HH),
	assertIfNot(inBody(HH)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Adding failure rules from predicates with none  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

write_FailRules :-
	retract(inBody(L)), 
	hasNoRules(L),
	processLit(not(L),I,I,NPL),
	write(NPL), write('<- true.'), nl,
	writeLastVars(L),
	fail.
write_FailRules.

hasNoRules(L) :-
	\+ hasRules(L),
	\+ is_abducible(L).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      Processing and asserting the program          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

processProgram :-
	write_FailRules,
	write_abds,
	write_rules.


write_abds :-
	nl,
	get_sol(abds(LAb),LAb),
	write_abd_rules(LAb).

write_abd_rules([]).
write_abd_rules([N/A|L]) :-
	functor(Ab,N,A), processLit(Ab,I,O,AbH),
	writeL(['abducible(',Ab,').']),
	writeL(['(',AbH,' <- true) :- insert(',Ab,',',I,',',O,').']),
	writeL(['(',not(AbH),' <- true) :- insert(',not(Ab),',',I,',',O,').']),
	writeLastVars(Ab),
	write_abd_rules(L).

write_rules :-
	retract(hasRules(H)), !,
	writeLastVars(H),
	find_rules(H,R),
	write_pos_rules(R),
	write_neg_rules(H,R),
	write_rules.


write_rules.

find_rules(H,R) :-
	findall(rule(H,B,true),clause(rule(H,B),true),R).

write_pos_rules([]).
write_pos_rules([rule(H,B,Ineq)|Rs]) :- write_pos_rule(H,B,Ineq), write_pos_rules(Rs).

write_pos_rule(H,true,Ineq) :-
	processLit(H,I,I,ProH),
	addIneqPart(Ineq,[ProH,' <- true'],Write),
	writeL(Write).

write_pos_rule(H,BB,Ineq) :-
	flattenConj(BB,B),
	processBody(B,ProB,I,O),
	processLit(H,I,O,ProH),
	addIneqPart(Ineq,[ProH, ' <- ', ProB],Write),
	writeL(Write).

addIneqPart(true,R,W) :- !, append(R,['.'],W).
addIneqPart(Ineq,R,['('|W]) :- append(R,[') :- ',Ineq,'.'],W).


processBody((A,B),(ProA,ProB),I,O) :-
	!, processLit(A,I,OA,ProA),
	processBody(B,ProB,OA,O).

processBody(A,ProA,I,O) :-
	processLit(A,I,O,ProA).


processLit(true,I,I,true) :- !.
processLit(not(H),I,O,not(ProH)) :- !,
	processAtom(H,I,O,ProH).
processLit(H,I,O,ProH) :-
	processAtom(H,I,O,ProH).

processAtom(H,I,O,ProH) :-
	H =.. [Name|Vars], append(Vars,[I,O],NVars),
	ProH =.. [Name|NVars].



write_neg_rules(H,Rs) :-
	findall(rule(not(H),NegB,Ineq),neg_ruleT(Rs,H,NegB,Ineq),LNeg),
	( LNeg = [], ! ; write_pos_rules(LNeg)).


neg_ruleT(Rs,H,NegB,Ineq) :- neg_rule(Rs,H,NegB,I), flattenConj(I,Ineq).

neg_rule([rule(H,B,_)],T,R,Ineq) :- !,
	one_hip(r(H,B),T,R,Ineq).

neg_rule([rule(H,B,_)|Rs],T,(R1,R),(In1,In)) :- !,
	one_hip(r(H,B),T,R1,In1),
	neg_rule(Rs,T,R,In).

one_hip(r(H,_),T,true,(H \= T)) :- H \== T.
one_hip(r(_,true),_,_,fail) :- !, fail.
one_hip(r(H,Body),T,Hip,true) :- T == H, !,
	one_hip(b(Body),Hip).
one_hip(r(H,Body),T,Hip,(T=H)) :- 
	one_hip(b(Body),Hip).

one_hip(b((A,_)),NA) :-
	negLit(A,NA).
one_hip(b((_,B)),NB) :-
	one_hip(b(B),NB).
one_hip(b(A),NA) :- \+ functor(A,',',2), negLit(A,NA).



writeLastVars(A) :-
	processAtom(A,I,O,PA),
	writeL(['lastVars(',A,',[',I,',',O,'],',PA,').']), 
	writeL(['lastVars(',not(A),',[',I,',',O,'],',not(PA),').']), !.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Auxiliar predicates                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get_Decl(D,_) :- retract(D), !.
get_Decl(_,[]).

get_sol(G,_) :- G, !.
get_sol(_,[]).

assertIfNot(G) :- G, !.
assertIfNot(G) :- my_assert(G).

one_template(G,TG) :-
	functor(G,N,A), functor(TG,N,A).

my_assert(G) :- assert(G).


is_abducible(G) :-
	functor(G,N,A), get_sol(abds(L),L), member(N/A,L).

negLit((not A),A) :- !.
negLit(A,(not A)).

flattenConj(Conj,FConj) :-
	conj2list(Conj,L), list2conj(L,FConj).

conj2list((A,B), L) :- !,
	conj2list(A,LA), conj2list(B,LB), append(LA,LB,L).
conj2list(true,[]) :- !.
conj2list(A,[A]).

list2conj([],true).
list2conj([A],A) :- !.
list2conj([A|L],(A,B)) :- list2conj(L,B).

writeL([]) :- nl.
writeL([H|L]) :- write(H), writeL(L).

%% 
%% This is file tlpcls.ltx - generated with MakeDist v1.0, by M. Reed 
%% 
 
\documentclass{book}

\begin{filecontents*}{tlp.cls}
%%
%% This is file `tlp.cls'
%%
%% CUP Journal  -- Theory and Practice of Logic Programming -- document class
%% Copyright 2000,2001,2002,2003 Cambridge University Press
%%
%% by Alison Woollatt
%%   (based on JFP.cls v1.01)
%%
%% Incorporating parts of authordate.sty
%%    by David Rhead, Cripps Computing Centre (Feb 1990).
%%
%% Bugs (in the case of unchanged files) should be reported to
%% texline@cambridge.org
%%
%% This software may only be used in the preparation of journal articles
%% or books or parts of books to be published by Cambridge University Press.
%% Any other use constitutes an infringement of copyright.
%%
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%%

\NeedsTeXFormat{LaTeX2e}[1997/12/01]
\ProvidesClass{tlp}[2003/07/15 v2.12 Theory and Practice of Logic Programming
  ^^Jdocument class]

\newif\ifprodtf

\DeclareOption{oneside}{\relax}
\DeclareOption{twoside}{\@twosidetrue \@mparswitchtrue}
\DeclareOption{draft}{\setlength\overfullrule{5\p@}}
\DeclareOption{final}{\setlength\overfullrule{\z@}}
\DeclareOption{onecolumn}{\@twocolumnfalse}
\DeclareOption{twocolumn}{\relax}
\DeclareOption{titlepage}{\relax}
\DeclareOption{notitlepage}{\relax}
\DeclareOption{leqno}{\relax}
\DeclareOption{fleqn}{\relax}
\DeclareOption{prodtf}{\prodtftrue}

\ExecuteOptions{twoside,final,onecolumn}
\ProcessOptions\relax

\newif\ifCUPmtlplainloaded
\ifprodtf
  \CUPmtlplainloadedtrue
  \RequirePackage{CUPTimes,tlp2esym}
\fi

\setlength\lineskip{1\p@}
\setlength\normallineskip{1\p@}
\renewcommand\baselinestretch{}

\renewcommand\normalsize{%
  \@setfontsize\normalsize\@xpt{13}%
  \abovedisplayskip 6.5\p@ \@plus 1\p@ \@minus 1\p@
  \belowdisplayskip \abovedisplayskip
  \abovedisplayshortskip 3\p@ \@plus 1\p@
  \belowdisplayshortskip \abovedisplayshortskip
  \let\@listi\@listI}

\normalsize

\newcommand\small{%
  \@setfontsize\small\@ixpt{11}%
  \abovedisplayskip 6\p@ \@plus 1\p@ \@minus 1\p@
  \belowdisplayskip \abovedisplayskip
  \abovedisplayshortskip 3\p@ \@plus 1\p@
  \belowdisplayshortskip \abovedisplayshortskip
  \def\@listi{\leftmargin\leftmargini
    \topsep 6\p@ \@plus 1\p@ \@minus 1\p@
    \parsep \z@ \itemsep \parsep}%
}

\newcommand\footnotesize{%
  \@setfontsize\footnotesize\@viiipt\@ixpt
  \abovedisplayskip 5\p@ \@plus 1\p@ \@minus 1\p@
  \belowdisplayskip \abovedisplayskip
  \abovedisplayshortskip \z@ \@plus 1\p@
  \belowdisplayshortskip \abovedisplayshortskip
  \def\@listi{\leftmargin\leftmargini
    \topsep 4.5\p@ \@plus 1\p@ \@minus 1\p@
    \parsep \z@ \itemsep \parsep}%
}

\newcommand\scriptsize{\@setfontsize\scriptsize\@viipt\@viiipt}
\newcommand\tiny{\@setfontsize\tiny\@vpt\@vipt}
\newcommand\large{\@setfontsize\large\@xiipt{14}}
\newcommand\Large{\@setfontsize\Large\@xivpt{18}}
\ifprodtf
  \newcommand\LARGE{\@setfontsize\LARGE{18}{21}}%
\else
  \newcommand\LARGE{\@setfontsize\LARGE\@xviipt{21}}%
\fi
\newcommand\huge{\@setfontsize\huge\@xxpt{25}}
\newcommand\Huge{\@setfontsize\Huge\@xxvpt{30}}

\newcommand\affilsize{\@setfontsize\affilsize\@viiipt\@xpt}
\let\authorsize\normalsize

\DeclareOldFontCommand{\rm}{\normalfont\rmfamily}{\mathrm}
\DeclareOldFontCommand{\sf}{\normalfont\sffamily}{\mathsf}
\DeclareOldFontCommand{\tt}{\normalfont\ttfamily}{\mathtt}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}
\DeclareOldFontCommand{\it}{\normalfont\itshape}{\mathit}
\DeclareOldFontCommand{\sl}{\normalfont\slshape}{\@nomath\sl}
\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}
\DeclareRobustCommand*\cal{\@fontswitch\relax\mathcal}
\DeclareRobustCommand*\mit{\@fontswitch\relax\mathnormal}

\ifprodtf \else
  \setlength\oddsidemargin{3.75pc}
  \setlength\evensidemargin{3.75pc}
  \setlength\topmargin{3.25pc}
\fi

\setlength\marginparwidth{2.0cm}
\setlength\marginparsep{10\p@}

\setlength\headheight{13\p@}
\setlength\headsep{11\p@}
\setlength\topskip{13\p@}
\setlength\footskip{26\p@}

\setlength\textheight{44\baselineskip}
\addtolength\textheight{\topskip}
\setlength\textwidth{30pc}
\setlength\columnsep{10\p@}
\setlength\columnseprule{\z@}

\setlength\footnotesep{\z@}
\setlength{\skip\footins}{19.5\p@ \@plus 12\p@ \@minus 1\p@}

\setlength\floatsep{13\p@ \@plus 6.5\p@ \@minus 1\p@}
\setlength\textfloatsep{15\p@ \@plus 4.5\p@ \@minus 3\p@}
\setlength\intextsep{13\p@ \@plus 6.5\p@ \@minus 2\p@}
\setlength\dblfloatsep{13\p@ \@plus 6.5\p@ \@minus 2\p@}
\setlength\dbltextfloatsep{15\p@ \@plus 4.5\p@ \@minus 3\p@}
\setlength\@fptop{\z@ \@plus 0fil}
\setlength\@fpsep{13\p@ \@plus 0fil}
\setlength\@fpbot{\z@ \@plus 3fil}
\setlength\@dblfptop{\z@ \@plus 0fil}
\setlength\@dblfpsep{13\p@ \@plus 0fil}
\setlength\@dblfpbot{\z@ \@plus 3fil}
\setlength\marginparpush{5\p@}

\setlength\parskip{\z@ \@plus .3\p@}
\setlength\parindent{1em}
\setlength\partopsep{\z@ \@plus 1\p@}
\@lowpenalty   51
\@medpenalty  151
\@highpenalty 301
\@beginparpenalty -\@lowpenalty
\@endparpenalty -\@lowpenalty
\@itempenalty -\@lowpenalty
\clubpenalty\z@
\widowpenalty\@M

\newcommand\partname{Part}
\newcommand\part{\par\addvspace{4ex}\@afterindentfalse \secdef\@part\@spart}

\def\@part[#1]#2{%
  \ifnum \c@secnumdepth >\m@ne
    \refstepcounter{part}%
    \addcontentsline{toc}{part}{\partname\ \thepart: #1}%
  \else
    \addcontentsline{toc}{part}{#1}%
  \fi
  {\parindent \z@ \centering
   \ifnum \c@secnumdepth >\m@ne
     \normalfont\large\rmfamily \MakeUppercase{\partname}\ %
     \ifcase\thepart \or ONE \or TWO \or THREE \or FOUR \or FIVE
     \or SIX \or SEVEN \or EIGHT \or NINE \or TEN \else \fi
     \par \nobreak
   \fi
   \normalfont\LARGE\rmfamily #2 \markboth{}{}\par}%
   \nobreak \vskip 3ex \@afterheading
}

\def\@spart#1{%
  {\parindent \z@ \centering\normalfont\LARGE\rmfamily #1\par}%
  \nobreak \vskip 3ex \@afterheading
}

\newcommand\section{%
  \@startsection {section}{1}{\z@}
    {-19.5\p@ \@plus -6.5\p@ \@minus -3.25\p@}
    {6.5\p@ \@plus \z@ \@minus 1\p@}
    {\normalfont\normalsize\bfseries\centering}%
}

\newcommand\subsection{%
  \@startsection{subsection}{2}{\z@}
    {-19.5\p@ \@plus -3.25\p@ \@minus -3.25\p@}
    {6.5\p@ \@plus \z@ \@minus 1\p@}
    {\normalfont\normalsize\bfseries\itshape\centering}%
}

\newcommand\subsubsection{%
  \@startsection{subsubsection}{3}{\z@}
    {-19.5\p@ \@plus -3.25\p@ \@minus -3.25\p@}
    {6.5\p@ \@plus \z@ \@minus 1\p@}
    {\normalfont\normalsize\itshape\centering}%
}

\newcommand\paragraph{%
  \@startsection{paragraph}{4}{\z@}
    {-13\p@ \@plus -1.5\p@ \@minus -1.5\p@}
    {-0.5em}
    {\normalfont\normalsize\itshape\raggedright}%
}

\newcommand\subparagraph{%
  \@startsection{subparagraph}{4}{\parindent}
    {-13\p@ \@plus -3.25\p@ \@minus -3.25\p@}
    {-0.5em}
    {\normalfont\normalsize\rmfamily\raggedright}%
}

\def\@seccntformat#1{\csname the#1\endcsname\enskip}% FROM LATEX.LTX

\newcommand\appendixname{Appendix}

\def\appnumberline#1{#1\hspace{9pt}}

\newif\ifinappendix

\def\@sect#1#2#3#4#5#6[#7]#8{%
  \ifnum #2>\c@secnumdepth
    \let\@svsec\@empty
  \else
    \refstepcounter{#1}%
    \protected@edef\@svsec{\@seccntformat{#1}\relax}%
  \fi
  \@tempskipa #5\relax
  \ifdim \@tempskipa>\z@
    \begingroup
      #6{%
        \@hangfrom{\hskip #3\relax\@svsec}%
          \interlinepenalty \@M #8\@@par}%
    \endgroup
    \csname #1mark\endcsname{#7}%
  \ifinappendix
    \addcontentsline{toc}{#1}{%
      \ifnum #2>\c@secnumdepth \else
        \protect\appnumberline{\csname the#1\endcsname}%
      \fi
      #7}%
  \else
    \addcontentsline{toc}{#1}{%
      \ifnum #2>\c@secnumdepth \else
        \protect\numberline{\csname the#1\endcsname}%
      \fi
      #7}%
  \fi
  \else
    \def\@svsechd{%
      #6{\hskip #3\relax
      \@svsec #8}%
      \csname #1mark\endcsname{#7}%
      \addcontentsline{toc}{#1}{%
        \ifnum #2>\c@secnumdepth \else
          \protect\numberline{\csname the#1\endcsname}%
        \fi
        #7}}%
  \fi
  \@xsect{#5}}


\newcommand\appendix{\inappendixtrue\par
  \@addtoreset{equation}{section}%
  \@addtoreset{figure}{section}%
  \@addtoreset{table}{section}%
  \setcounter{section}\z@
  \renewcommand\thesection{Appendix~\@Alph\c@section}%
  \renewcommand\thesubsection{\@Alph\c@section.\@arabic\c@subsection}
  \renewcommand\theequation{\@Alph\c@section\@arabic\c@equation}%
  \renewcommand\thefigure{\@Alph\c@section\,\@arabic\c@figure}%
  \renewcommand\thetable{\@Alph\c@section\,\@arabic\c@table}%
}

\setcounter{secnumdepth}{3}

\newcounter{part}
\newcounter{section}
\newcounter{subsection}[section]
\newcounter{subsubsection}[subsection]
\newcounter{paragraph}[subsubsection]
\newcounter{subparagraph}[paragraph]
\renewcommand\thepart          {\@arabic\c@part}
\renewcommand\thesection       {\@arabic\c@section}
\renewcommand\thesubsection    {\thesection.\@arabic\c@subsection}
\renewcommand\thesubsubsection {\thesubsection.\@arabic\c@subsubsection}
\renewcommand\theparagraph     {\thesubsubsection.\@arabic\c@paragraph}
\renewcommand\thesubparagraph  {\theparagraph.\@arabic\c@subparagraph}

\newskip\@leftskip  \@leftskip=\z@

\setlength\leftmargini   {2.5em}
\setlength\leftmarginii  {1.5em}
\setlength\leftmarginiii {1.5em}
\setlength\leftmarginiv  {1.5em}
\setlength\leftmarginv   {1em}
\setlength\leftmarginvi  {1em}
\setlength\leftmargin    {\leftmargini}
\setlength\labelsep      {5\p@}
\setlength\labelwidth    {\leftmargini}
\addtolength\labelwidth  {-\labelsep}

\newcommand\makeRLlabel[1]{\rlap{#1}\hss}
\newcommand\makeRRlabel[1]{\hss\llap{#1}}

\def\@listI{\leftmargin\leftmargini
  \parsep \z@ \topsep 6.5\p@ \@plus 3\p@ \@minus 3\p@
  \itemsep \z@ \@plus 1\p@ \@minus 1\p@
  \let\makelabel\makeRLlabel}

\def\@listii{\leftmargin\leftmarginii
  \labelwidth\leftmarginii
  \advance\labelwidth-\labelsep
  \topsep 3\p@ \@plus 1\p@ \@minus 1\p@
  \parsep \z@ \itemsep \parsep
  \let\makelabel\makeRLlabel}

\def\@listiii{\leftmargin\leftmarginiii
  \labelwidth\leftmarginiii
  \advance\labelwidth-\labelsep
  \topsep 3\p@ \@plus 1\p@ \@minus 1\p@
  \parsep \z@ \partopsep \z@
  \itemsep \topsep
  \let\makelabel\makeRLlabel}

\def\@listiv{\leftmargin\leftmarginiv
  \labelwidth\leftmarginiv
  \advance\labelwidth-\labelsep
  \let\makelabel\makeRLlabel}

\def\@listv{\leftmargin\leftmarginv
  \labelwidth\leftmarginv
  \advance\labelwidth-\labelsep
  \let\makelabel\makeRLlabel}

\def\@listvi{\leftmargin\leftmarginvi
  \labelwidth\leftmarginvi
  \advance\labelwidth-\labelsep
  \let\makelabel\makeRLlabel}

\let\@listi\@listI
\@listi

\def\itemize{% FROM LATEX.LTX
  \ifnum \@itemdepth >\thr@@ \@toodeep\else
     \advance\@itemdepth \@ne
     \edef\@itemitem{labelitem\romannumeral\the\@itemdepth}%
     \ifintheorem\advance\leftmargin\leftmargini\fi
     \expandafter
     \list
       \csname\@itemitem\endcsname
       {\let\makelabel\makeRRlabel}%
  \fi
}

\newcommand\labelitemi{$\m@th\bullet$}
\newcommand\labelitemii{\normalfont\bfseries ---}
\newcommand\labelitemiii{\normalfont\bfseries --}
\newcommand\labelitemiv{$\m@th\cdot$}

\def\enumerate{% FROM LATEX.LTX
  \ifnum \@enumdepth >\thr@@ \@toodeep\else
    \advance\@enumdepth \@ne
    \edef\@enumctr{enum\romannumeral\the\@enumdepth}%
  \fi
  \@ifnextchar [{\@enumeratetwo}{\@enumerateone}%
}

\def\@enumerateone{%
  \expandafter
   \list
     \csname label\@enumctr\endcsname
     {\usecounter{\@enumctr}%
      \ifintheorem\advance\leftmargin\leftmargini\fi
      \let\makelabel\makeRRlabel}%
}

\def\@enumeratetwo[#1]{%
  \expandafter
  \list
    \csname label\@enumctr\endcsname
    {\usecounter{\@enumctr}%
     \settowidth\labelwidth{\normalfont\rmfamily #1}%
     \leftmargin\labelwidth \advance\leftmargin\labelsep
     \let\makelabel\makeRRlabel}%
}

\newcommand\labelenumi  {{\normalfont\rmfamily\theenumi.}}
\newcommand\labelenumii {{\normalfont\rmfamily(\theenumii)}}
\newcommand\labelenumiii{{\normalfont\rmfamily\theenumiii}}
\newcommand\labelenumiv {{\normalfont\rmfamily\theenumiv}}

\renewcommand\theenumi{\@arabic\c@enumi}
\renewcommand\theenumii{\@alph\c@enumii}
\renewcommand\theenumiii{\@roman\c@enumiii}
\renewcommand\theenumiv{\@Alph\c@enumiv}

\renewcommand\p@enumii{\theenumi}
\renewcommand\p@enumiii{\theenumi(\theenumii)}
\renewcommand\p@enumiv{\p@enumiii\theenumiii}

\newcommand*\descriptionlabel[1]{\hspace\labelsep \normalfont\bfseries #1}

\newenvironment{description}
  {\list{}{\leftmargin 1em \labelwidth\z@ \itemindent-\leftmargin
   \let\makelabel\descriptionlabel}}
  {\endlist}

\newenvironment{verse}
  {\let\\=\@centercr
   \list{}{\itemsep\z@
   \itemindent -2.5em%
   \listparindent \itemindent
   \rightmargin\leftmargin
   \advance\leftmargin 2.5em}\item[]}
  {\endlist}

\newenvironment{quotation}
  {\list{}{\listparindent\parindent
   \itemindent\listparindent
   \leftmargin\z@ \rightmargin\leftmargin
   \parsep \z@ \@plus 1\p@}\item[]%
   \normalfont\small\rmfamily}
  {\endlist}

\let\quote\quotation
\let\endquote\endquotation

\newif\ifrembrks
\newcommand\removebrackets{\rembrkstrue}

\newif\ifintheorem

\def\@begintheorem#1#2{% FROM LATEX.LTX
  \intheoremtrue
  \normalfont\rmfamily
  \trivlist
    \pagebreak[3]\item[\hskip \labelsep{\normalfont\itshape #1\ #2}]%
    \item[]%
}

\def\@opargbegintheorem#1#2#3{% FROM LATEX.LTX
  \intheoremtrue
  \normalfont\rmfamily
  \trivlist
    \pagebreak[3]\item[\hskip \labelsep{\normalfont\itshape #1\ #2\ %
    \ifrembrks #3\/\global\rembrksfalse\else {\upshape(}#3\/{\upshape)}\fi}]%
    \item[]%
}

\def\@endtheorem{\endtrivlist\intheoremfalse}

\newsavebox{\proofsavebox}

\ifprodtf
  \sbox{\proofsavebox}{$\CUPproofbox$}
  \newcommand\proofbox{\hbox{$\CUPproofbox$}}
\else
  \sbox{\proofsavebox}
    {\unitlength 1pt\begin{picture}(6.5,6.5)%
     \put(0,0){\framebox(6.5,6.5){}}\end{picture}}
  \newcommand\proofbox{\usebox{\proofsavebox}\relax}
\fi

\newcommand\mathproofbox{\rlap{\quad\proofbox}}

\def\@nprf{\normalfont\rmfamily \trivlist
  \pagebreak[3]\item[\hskip \labelsep {\normalfont\itshape Proof}]%
  \item[]}

\def\@oprf[#1]{\normalfont\rmfamily \trivlist
  \pagebreak[3]\item[\hskip \labelsep {\normalfont\itshape #1\ }]%
  \item[]}

\newenvironment{proof}
  {\@ifnextchar[{\@oprf}{\@nprf}}
  {\hspace*{1em}\hbox{\proofbox}\endtrivlist}

\newenvironment{proof*}
  {\proof}
  {\endtrivlist}

\renewcommand\theequation{\@arabic\c@equation}

\setlength\arraycolsep{5\p@}
\setlength\tabcolsep{3\p@}
\setlength\arrayrulewidth{.5\p@}
\setlength\doublerulesep{1.5\p@}
\setlength\tabbingsep{\labelsep}
\setlength{\skip\@mpfootins}{\skip\footins}
\setlength\fboxsep{3\p@}
\setlength\fboxrule{.5\p@}

\newcommand\maketitle{\@ifnextchar [{\m@ketitleone}{\m@ketitleone[n]}}

\def\m@ketitleone[#1]{\par
  \begingroup
    \newpage
    \global\@topnum\z@
    \titlefntrue
    \def\thefootnote{\@fnsymbol\c@footnote}%
    \def\@makefnmark{\hbox{$\@thefnmark$}}%
    \@maketitle{#1}%
    \thispagestyle{titlepage}\@thanks
  \endgroup
  \global\let\@maketitle\relax
  \global\let\@thanks\@empty
  \global\let\@title\@empty
  \global\let\@author\@empty
  \global\let\maketitle\relax
  \global\let\thanks\relax
  \setcounter{footnote}\z@
}

\def\pe@rl#1{%
  \if t#1 {\tpe@rl}\else
    \if T#1 {\Tpe@rl}\else
      \if l#1 {\lpe@rl}\else
        \if L#1 {\Lpe@rl}\else
          \if o#1 {\otherpearl}\else
            \if p#1 {\ppe@rl}\else
              \if P#1 {\Ppe@rl}\else
                \vspace*{32\p@}%
              \fi
            \fi 
          \fi
        \fi
      \fi
    \fi
  \fi
}

\def\spe@rl{\vspace*{32\p@}\normalfont\LARGE\rmfamily}
\def\epe@rl#1{\par\vspace*{6.5\p@}\gdef\@shorttitle{#1}}

\def\tpe@rl{\spe@rl T\ls H\ls E\ls O\ls R\ls E\ls T\ls
  I\ls C\ls A\ls L\ns  P\ls E\ls A\ls R\ls L\ls S%
  \epe@rl{Theoretical pearls}%
}

\def\Tpe@rl{\spe@rl T\ls H\ls E\ls O\ls R\ls E\ls T\ls
  I\ls C\ls A\ls L\ns  P\ls E\ls A\ls R\ls L%
  \epe@rl{Theoretical pearl}%
}

\def\lpe@rl{\spe@rl L\ls O\ls G\ls I\ls C\ls A\ls L\ns 
  P\ls E\ls A\ls R\ls L\ls S%
  \epe@rl{Logical pearls}%
}

\def\Lpe@rl{\spe@rl L\ls O\ls G\ls I\ls C\ls A\ls L\ns 
  P\ls E\ls A\ls R\ls L%
  \epe@rl{Logical pearl}%
}

\def\otherpearl{\spe@rl
  \@ifundefined{othrpearl}
    {Please define {\normalfont\ttfamily\char92 othrpearl} to obtain\\ the correct title!}
    {\othrpearl}%
  \epe@rl{Short title--please redefine with {\normalfont\ttfamily\char92 shorttitle}}%
}


% authors can use p or P to get 'Programming Pearl'
\def\ppe@rl{\spe@rl P\ls R\ls O\ls G\ls R\ls A\ls M\ls M\ls I\ls N\ls G\ns  
  P\ls E\ls A\ls R\ls L%
  \epe@rl{Programming pearl}%
}

\def\Ppe@rl{\spe@rl P\ls R\ls O\ls G\ls R\ls A\ls M\ls M\ls I\ls N\ls G\ns  
  P\ls E\ls A\ls R\ls L%
  \epe@rl{Programming pearl}%
}

\newcommand\submitted[1]{\gdef\@submitted{#1}}
  \gdef\@submitted{1 January 2003}
\newcommand\revised[1]{\gdef\@revised{#1}}
  \gdef\@revised{1 January 2003}
\newcommand\accepted[1]{\gdef\@accepted{#1}}
  \gdef\@accepted{1 January 2003}

\def\b@at{\begin{author@tabular}[t]{@{}c@{}}}

\renewcommand\and{and }
\newcommand\@nd{\end{author@tabular}\vskip 6\p@\par\b@at}

\let\authorbreak\relax
\newcommand\auth@rbreak{\end{author@tabular}\\[0pt]\b@at}

\def\@maketitle#1{%
  \newpage
  \vspace*{-15\p@}%
  {\centering \sloppy
   \pe@rl{#1}%
   {\normalfont\LARGE\itshape \@title\par}%
   \vskip 16\p@
   {\normalfont\normalsize\rmfamily
    \let\authorbreak\auth@rbreak
    \let\and\@nd
    \b@at
      \@author
    \end{author@tabular}%
   \par}%
%   \ifprodtf
     \vskip 10pt%
     {{\affilsize\it submitted \@submitted; revised \@revised; accepted \@accepted}}\par
%   \fi
  }%
  \vskip 18\p@ \@plus 2\p@ \@minus 1\p@
}

\def\abs@header#1{%
  \vbox{\hrule \@width\hsize
  \vskip 8\p@ \@plus 3\p@ \@minus 1\p@
  \centerline{\normalfont\normalsize\bfseries #1}}%
}

\def\abs@body{%
  \list{}{\leftmargin\z@ \rightmargin\leftmargin
    \listparindent 1em \parsep \z@ \@plus 1\p@
    \topsep 6.5\p@ \@plus 3\p@ \@minus 1\p@}%
  \item[]\normalfont\small\rmfamily
}

\newcommand\abstractname{Abstract}
\newenvironment{abstract}
  {\abs@header{\abstractname}\abs@body}
  {\endlist 
   %\vbox{\hrule \@width \hsize} %rule now included at end of keywords
   \gdef\abs@header##1{\vskip 2\p@
     \centerline{\normalfont\normalsize\bfseries ##1}}}

\newcommand\keywordsname{KEYWORDS}
\newenvironment{keywords}
  {\noindent\normalfont\small\rmfamily{\em \keywordsname}:}%
  {\vspace{6.5\p@ \@plus 3\p@ \@minus 1\p@}\endlist 
   \vbox{\hrule \@width \hsize}}

\newcommand\capsulename{Capsule Review}
\newenvironment{capsule}
  {\abs@header{\capsulename}\abs@body}
  {\endabstract}

\def\author@tabular{\normalfont\authorsize\rmfamily
  \def\@halignto{}\@authortable}
\let\endauthor@tabular\endtabular

\def\author@tabcrone{{\ifnum0=`}\fi\@xtabularcr\normalfont\affilsize\itshape
  \let\\\author@tabcrtwo\ignorespaces}

\def\author@tabcrtwo{{\ifnum0=`}\fi\@xtabularcr[-3\p@]\normalfont\affilsize\itshape
  \let\\\author@tabcrtwo\ignorespaces}

\def\@authortable{\leavevmode \hbox \bgroup $\let\@acol\@tabacol
  \let\@classz\@tabclassz \let\@classiv\@tabclassiv
  \let\\\author@tabcrone \ignorespaces \@tabarray}

\mark{{}{}}
\renewcommand\author{\@ifnextchar [{\@authortwo}{\@authorone}}
\def\@authorone#1{\gdef\@author{#1}\gdef\@shortauthor{#1}}
\def\@authortwo[#1]#2{\gdef\@author{#2}\gdef\@shortauthor{#1}}
\gdef\@author{\mbox{}}

\newcommand\shortauthor[1]{\gdef\@shortauthor{#1}}
\gdef\@shortauthor{}

\renewcommand\title{\@ifnextchar [{\@titletwo}{\@titleone}}
\def\@titleone#1{\gdef\@title{#1}\gdef\@shorttitle{#1}}
\def\@titletwo[#1]#2{\gdef\@title{#2}\gdef\@shorttitle{#1}}
\gdef\@title{\mbox{}}

\newcommand\shorttitle[1]{\gdef\@shorttitle{#1}}
\gdef\@shorttitle{}

\newcommand\volume[1]{\gdef\@volume{#1}}
\gdef\@volume{{\normalfont\bfseries 1} (1)}

\newcommand\pagerange[1]{\gdef\@pagerange{#1}}
\gdef\@pagerange{1--000}

\newcommand\pubyear[1]{\gdef\@year{#1}}
\gdef\@year{20XX}

\newcommand\jdate[1]{\gdef\@jdate{#1}}
\gdef\@jdate{January \@year}

\newcommand\doi[1]{\gdef\@doi{10.1017/#1}}
\gdef\@doi{10.1017/S147106840100xxxx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\gdef\@journal{%
  \vbox to 5.5\p@{\noindent
    \parbox[t]{4.5in}{\normalfont\indexsize\baselineskip 9\p@
      {\itshape J.\ Fluid\ Mech.} (\@pubyear), {\itshape vol.} \@volume,
      {\itshape pp.} \@pagerange.\quad \copyright\ \@pubyear\ Cambridge University 
        Press\\[2.5\p@]
      DOI: \@doi\quad {Printed in the United Kingdom}}%
  \vss}%
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\journal[1]{\gdef\@journal{#1}}

\def\@journal{%
  \vbox to 5.6\p@{\noindent\parbox[t]{4.8in}{\normalfont\affilsize\rmfamily
    {\itshape TLP\/}\ \@volume: \@pagerange, \@jdate.\quad 
    \copyright\ \@year\ Cambridge University Press\\[2.5\p@]%
    DOI: \@doi\quad Printed in the United Kingdom}%
  \vss}%
}

\def\@underjournal{%
  \vbox to 5.6\p@{\noindent\parbox[t]{4.8in}{\normalfont\affilsize\rmfamily
    {\itshape Under consideration for publication in
     Theory and Practice of Logic Programming\/}\\[2.5\p@]
     \ }%
  \vss}%
}

\def\ps@headings{\let\@mkboth\markboth
  \def\@oddhead{\hfil{\itshape\@shorttitle}\hfil \llap{\thepage}}%
  \def\@evenhead{\rlap{\thepage}\hfil\itshape\@shortauthor\hfil}%
  \let\@oddfoot\@empty
  \let\@evenfoot\@oddfoot
  \def\sectionmark##1{\markboth{##1}{}}%
  \def\subsectionmark##1{\markright{##1}}%
}

\def\ps@myheadings{\let\@mkboth\@gobbletwo
  \def\@oddhead{\hfil{\itshape\rightmark}\hfil \llap{\thepage}}%
  \def\@evenhead{\rlap{\thepage}\hfil\itshape\leftmark\hfil}%
  \let\@oddfoot\@empty
  \let\@evenfoot\@oddfoot
  \let\sectionmark\@gobble
  \let\subsectionmark\@gobble
}

\ifprodtf
  \let\@j@urnal\@journal
\else
  \let\@j@urnal\@underjournal
\fi

\def\ps@titlepage{\leftskip\z@ \let\@mkboth\@gobbletwo
  \def\@oddhead{\@j@urnal \hfil\llap{\thepage}}%
  \let\@evenhead\@oddhead
  \let\@oddfoot\@empty
  \let\@evenfoot\@oddfoot
  \let\sectionmark\@gobble
  \let\subsectionmark\@gobble
}

\def\@pnumwidth{1.55em}
\def\@tocrmarg {2.55em}
\def\@dotsep{4.5}
\setcounter{tocdepth}{2}

\def\@dottedtocline#1#2#3#4#5{% FROM LATEX.LTX
  \ifnum #1>\c@tocdepth \else
    \vskip \z@ \@plus.2\p@
    {\leftskip #2\relax \rightskip \@tocrmarg \parfillskip -\rightskip
     \parindent #2\relax\@afterindenttrue
     \interlinepenalty\@M
     \leavevmode
     \@tempdima #3\relax
     \advance\leftskip \@tempdima \null\hskip -\leftskip
     {#4}\nobreak
     \leaders\hbox{$\m@th
        \mkern \@dotsep mu\hbox{\phantom{.}}\mkern \@dotsep
        mu$}\hfill
     \nobreak
     \hb@xt@\@pnumwidth{\hfil\normalfont \normalcolor #5}%
     \par}%
  \fi}

\newcommand\contentsname{Contents}

\newcommand\tableofcontents{%
  \section*{\contentsname}%
  \@starttoc{toc}\par
  \vspace{13\p@}%
}

\newcommand*\l@part[2]{%
  \ifnum \c@tocdepth >-2\relax
    \addpenalty{-\@highpenalty}%
    \addvspace{.5\baselineskip \@plus 1\p@}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      {\leavevmode
       \normalfont\rmfamily
       #1\hfil \hb@xt@\@pnumwidth{\hfil}}\par
       \nobreak
       \if@compatibility
         \global\@nobreaktrue
         \everypar{\global\@nobreakfalse\everypar{}}%
      \fi
    \endgroup
    \vskip .25\baselineskip \@plus 1\p@
  \fi
}

\newcommand*\l@section[2]{%
  \ifnum \c@tocdepth >\z@
    \addpenalty\@secpenalty
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \normalfont\rmfamily
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      {\bfseries #1}\nobreak\hfil \nobreak\hb@xt@\@pnumwidth{\hss #2}\par
    \endgroup
  \fi}

\newcommand*\l@subsection{\@dottedtocline{2}{1.5em}{2.3em}}
\newcommand*\l@subsubsection{\@dottedtocline{3}{3.8em}{3.2em}}
\newcommand*\l@paragraph{\@dottedtocline{4}{7.0em}{4.1em}}
\newcommand*\l@subparagraph{\@dottedtocline{5}{10em}{5em}}

\newcommand\listfigurename{List of Figures}
\newcommand\listoffigures{%
  \section*{\listfigurename}%
  \@starttoc{lof}\par
  \vskip 13\p@
}

\newcommand*\l@figure{\@dottedtocline{1}{1.5em}{2.3em}}

\newcommand\listtablename{List of Tables}
\newcommand\listoftables{%
  \section*{\listtablename}%
  \@starttoc{lot}\par
  \vskip 13\p@
}

\let\l@table\l@figure

\renewcommand\footnoterule{%
  \kern-3\p@
  \hrule \@width .4\columnwidth height \z@
  \kern 3\p@}

\newif\iftitlefn
\newcommand\@makefntext[1]{%
  \@setpar{\@@par\@tempdima \hsize
  \advance\@tempdima-1em
  \parshape \@ne 1em \@tempdima}\par
  \noindent \hb@xt@ \z@{\hss$\iftitlefn\else^\fi{\@thefnmark}$\ }#1}

\ifprodtf \else \let\highast\ast\fi

\def\@fnsymbol#1{\ensuremath{% FROM LATEX.LTX
  \ifcase#1\or \hbox{$\highast$}\or \dagger\or \ddagger\or
    \mathchar "278\or \mathchar "27B\or \|\or \hbox{$\highast\highast$}\or
    \dagger\dagger\or \ddagger\ddagger\or \mathchar "278\mathchar "278\or
    \mathchar "27B\mathchar "27B\or \|\|\or \else\@ctrerr\fi}%
}

\renewcommand\@makefnmark{\hbox{$^{\@thefnmark}$}}% FROM LATEX.LTX
\renewcommand\thefootnote{\@arabic\c@footnote}% FROM LATEX.LTX
\renewcommand\thempfootnote{\mathit{\@alph\c@mpfootnote}}% FROM LATEX.LTX

\setcounter{topnumber}{2}
\renewcommand\topfraction{.9}
\setcounter{bottomnumber}{1}
\renewcommand\bottomfraction{.9}
\setcounter{totalnumber}{3}
\renewcommand\textfraction{.1}
\renewcommand\floatpagefraction{.9}
\setcounter{dbltopnumber}{2}
\renewcommand\dbltopfraction{.9}
\renewcommand\dblfloatpagefraction{.5}

\newcounter{table}
\renewcommand\thetable{\@arabic\c@table}
\def\fps@table{tbp}
\def\ftype@table{1}
\def\ext@table{lot}
\newcommand\tablename{Table}
\def\fnum@table{\tablename~\thetable}

\newenvironment{table}
  {\@float{table}}
  {\end@float}

\newenvironment{table*}
  {\@dblfloat{table}}
  {\end@dblfloat}

\def\fstyle@table{\normalfont\small\rmfamily}
\def\fjust@table{\centering}
\def\fcapjust@table{\centering}
\def\fcapsize@table{\normalfont\normalsize\rmfamily}
\def\fcapstyle@table{\normalfont\normalsize\itshape}

\newcommand\contname{(cont.)}
\newcommand\continuedfigure{%
  \addtocounter{figure}\m@ne
  \let\curr@thefigure\thefigure
  \def\thefigure{\curr@thefigure\ \contname}%
}

\newcommand\continuedtable{%
  \addtocounter{table}\m@ne
  \let\curr@thetable\thetable
  \def\thetable{\curr@thetable\ \contname}%
}

\newif\ifrem@fullpt
\newcommand\removefullpoint{\global\rem@fullpttrue}

\newif\ifbot@fig
\newenvironment{bottomfigure}{\def\fps@figure{b}%
  \setcounter{bottomnumber}{1}%
  \global\bot@figtrue
  \@float{figure}\fstyle@figure}
  {\end@float}

\newbox\@tempboxb

\long\def\@makecaption#1#2{%
  \ifbot@fig \rule{\textwidth}{.25\p@}\fi
  \vskip 6.5\p@ \@plus .4\p@ \@minus .4\p@
  \begingroup
  \setbox\@tempboxb\hbox{#2}%
  \def\@xtra{\ifdim\wd\@tempboxb>\z@ \ifrem@fullpt\else .\enskip\fi\fi}%
  \setbox\@tempboxa\hbox{#1\@xtra #2}%
  \ifdim\wd\@tempboxa>\tw@\textwidth
    {\let\centering\relax #1\@xtra #2\par}%
  \else
    #1\@xtra #2\par
  \fi
  \endgroup
  \global\bot@figfalse
  \global\rem@fullptfalse
}

\newcounter{figure}
\renewcommand\thefigure{\@arabic\c@figure}
\def\fps@figure{tbp}
\def\ftype@figure{2}
\def\ext@figure{lof}
\newcommand\figurename{Fig.}
\def\fnum@figure{\figurename~\thefigure}

\newenvironment{figure}
  {\@float{figure}}
  {\end@float}

\newenvironment{figure*}
  {\@dblfloat{figure}}
  {\end@dblfloat}

\def\fstyle@figure{\normalfont\small\rmfamily}
\def\fjust@figure{\centering}
\def\fcapjust@figure{\centering}
\def\fcapsize@figure{\normalfont\small\rmfamily}
\def\fcapstyle@figure{\normalfont\small\rmfamily}

\long\def\@caption#1[#2]#3{% FROM LATEX.LTX
  \par
  \addcontentsline{\csname ext@#1\endcsname}{#1}%
    {\protect\numberline{\csname the#1\endcsname}{\ignorespaces #2}}%
  \begingroup
    \@parboxrestore
    \if@minipage
      \@setminipage
    \fi
    \normalsize
    \@makecaption{\csname fcapjust@#1\endcsname
                  \csname fcapsize@#1\endcsname
                  \csname fnum@#1\endcsname}%
                 {\csname fcapstyle@#1\endcsname \ignorespaces #3}\par
  \endgroup
}

\def\@xfloat #1[#2]{% FROM LATEX.LTX
  \@nodocument
  \def\@captype {#1}%
  \def\@fps {#2}%
  \@onelevel@sanitize \@fps
  \def \reserved@b {!}%
  \ifx \reserved@b \@fps
    \@fpsadddefault
  \else
    \ifx \@fps \@empty
      \@fpsadddefault
    \fi
  \fi
  \ifhmode
    \@bsphack
    \@floatpenalty-\@Mii
  \else
    \@floatpenalty-\@Miii
  \fi
  \ifinner
    \@parmoderr\@floatpenalty\z@
  \else
    \@next\@currbox\@freelist
      {%
       \@tempcnta \sixt@@n
       \expandafter \@tfor \expandafter \reserved@a
         \expandafter :\expandafter =\@fps
         \do
          {%
           \if \reserved@a h%
             \ifodd \@tempcnta
             \else
               \advance \@tempcnta \@ne
             \fi
           \fi
           \if \reserved@a t%
             \@setfpsbit \tw@
           \fi
           \if \reserved@a b%
             \@setfpsbit 4%
           \fi
           \if \reserved@a p%
             \@setfpsbit 8%
           \fi
           \if \reserved@a !%
             \ifnum \@tempcnta>15
               \advance\@tempcnta -\sixt@@n\relax
             \fi
           \fi
           }%
       \@tempcntb \csname ftype@\@captype \endcsname
       \multiply \@tempcntb \@xxxii
       \advance \@tempcnta \@tempcntb
       \global \count\@currbox \@tempcnta
       }%
    \@fltovf
  \fi
  \global \setbox\@currbox
    \color@vbox
      \normalcolor
      \vbox \bgroup
        \hsize\columnwidth
        \@parboxrestore
        \@floatboxreset
        \csname fstyle@\@captype\endcsname
        \csname fjust@\@captype\endcsname
}

\let\oldtabular\tabular
\let\endoldtabular\endtabular

\def\tabular{% FROM LATEX.LTX
  \def\@halignto{to \textwidth}\tabskip\tabcolsep \@plus 1fil\@ttabular
}

\def\@ttabular{\leavevmode \hbox \bgroup $\let\@acol\@tabacol
   \let\@classz\@tabclassz
   \let\@classiv\@tabclassiv \let\\\@tabularcr\@ttabarray}

\def\@ttabarray{\m@th\@ifnextchar[\@tarray{\@ttarray}}

\def\@tarray[#1]#2{\t@barray[#1]{@{\tabskip\tw@\tabcolsep \@plus 3\p@}#2}}
\def\@ttarray#1{\t@barray[c]{@{\tabskip\tw@\tabcolsep \@plus 3\p@}#1}}

\def\t@barray[#1]#2{%
  \if #1t\vtop \else \if#1b\vbox \else \vcenter \fi\fi
  \bgroup
  \setbox\@arstrutbox\hbox{%
    \vrule \@height\arraystretch\ht\strutbox
           \@depth\arraystretch \dp\strutbox
           \@width\z@}%
  \@mkpream{#2}%
  \edef\@preamble{%
    \halign \noexpand\@halignto
      \bgroup \tabskip\z@skip \@arstrut \@preamble \tabskip\tabcolsep \@plus 1fil\cr}%
  \let\@startpbox\@@startpbox \let\@endpbox\@@endpbox
  \let\tabularnewline\\%
  \let\par\@empty
  \let\@sharp##%
  \set@typeset@protect
  \lineskip\z@skip\baselineskip\z@skip
  \@preamble}

\newcommand\ls{\kern.15em\relax}
\newcommand\ns{\kern.55em\relax}

\def\hline{% FROM LATEX.LTX
  \noalign{\ifnum0=`}\fi \vskip 6\p@
  \hrule \@height \arrayrulewidth \vskip 6\p@
  \futurelet \reserved@a\@xhline}

\def\@xhline{% FROM LATEX.LTX
  \ifx\reserved@a\hline
    \vskip -12\p@
    \vskip\doublerulesep
  \fi
  \ifnum0=`{\fi}}

\newcommand\today{}
\edef\today{\number\day\ \ifcase\month\or
  January\or February\or March\or April\or May\or June\or
  July\or August\or September\or October\or November\or December
 \fi \ \number\year}

\renewcommand\@biblabel[1]{}% FROM LATEX.LTX
\newcommand\newblock{\hskip .11em \@plus .33em \@minus .07em}

\newcommand\refname{References}

\newcounter{dummy}
\newenvironment{thebibliography}[1]
  {\section*{\refname}%
   \normalfont\small\rmfamily
   \addcontentsline{toc}{section}{\refname}%
   \list{}{\usecounter{dummy}\labelwidth\z@ \leftmargin 1em \itemindent -1em}%
   \parindent\z@
   \parskip 2\p@ \@plus .1\p@
   \sloppy\clubpenalty\z@ \widowpenalty\@M
   \sfcode`\.\@m\relax}
  {\def\@noitemerr
   {\@latex@warning{Empty `thebibliography' environment}}%
   \endlist}

%\def\@citex[#1]#2{% FROM LATEX.LTX
%  \let\@citea\@empty
%  \@cite{\@for\@citeb:=#2\do
%    {\@citea\def\@citea{; }%
%     \edef\@citeb{\expandafter\@firstofone\@citeb}%
%     \if@filesw\immediate\write\@auxout{\string\citation{\@citeb}}\fi
%     \@ifundefined{b@\@citeb}{\mbox{\reset@font\bfseries ?}%
%       \G@refundefinedtrue
%       \@latex@warning
%         {Citation `\@citeb' on page \thepage \space undefined}}%
%       {\csname b@\@citeb\endcsname}}}{#1}}

\def\@cite#1#2{{\if@tempswa #2\else (#1)\fi}}% FROM LATEX.LTX

\let\@internalcite\cite
%%\def\cite{\def\citename##1{##1}\@internalcite}
%%\DeclareRobustCommand\shortcite{\def\citename##1{}\@internalcite}

\def\cite{\def\@citeseppen{-1000}%
    \def\@cite##1##2{(##1\if@tempswa , ##2\fi)}%
    \def\citeauthoryear##1##2##3{##2 ##3}\@internalcite}
\def\citeXNP#1#2{%
  \def\@cite@label{#2}%
  \def\@cite##1##2{##1\if@tempswa , ##2\fi}%
  \def\citeauthoryear##1##2##3{\@cite@label}\@internalcite{#1}}
% \def\@citeseppen{-1000}%
%    \def\@cite@label{#1}
%    \def\@cite##1##2{\if@tempswa ##2\fi}%
%    \def\citeauthoryear##1##2##3{##2 ##3}\@internalcite}
\def\citeNP{\def\@citeseppen{-1000}%
    \def\@cite##1##2{##1\if@tempswa , ##2\fi}%
    \def\citeauthoryear##1##2##3{##2 ##3}\@internalcite}
\def\citeN{\def\@citeseppen{-1000}%
    \def\@cite##1##2{##1\if@tempswa , ##2)\else{)}\fi}%
    \def\citeauthoryear##1##2##3{##2 (##3}\@citedata}
\def\shortcite#1{\citeyear{#1}}
\def\citeS#1{[\citeANP{#1} \citeyearNP{#1}]}
\def\citeNS#1{\citeANP{#1} \citeyear{#1}}
\def\citeNPS#1{\citeANP{#1} \citeyearNP{#1}}
%testing year,year
\def\citeNN{\def\@citeseppen{-1000}%
    \def\@cite##1##2{(##1\if@tempswa , ##2\fi)}%
    \def\citeauthoryear##1##2##3{##3}\@citedata}

\def\citeA{\def\@citeseppen{-1000}%
    \def\@cite##1##2{(##1\if@tempswa , ##2\fi)}%
    \def\citeauthoryear##1##2##3{##2}\@internalcite}
\def\citeANP{\def\@citeseppen{-1000}%
    \def\@cite##1##2{##1\if@tempswa , ##2\fi}%
    \def\citeauthoryear##1##2##3{##2}\@internalcite}

\def\citeyear{\def\@citeseppen{-1000}%
    \def\@cite##1##2{(##1\if@tempswa , ##2\fi)}%
    \def\citeauthoryear##1##2##3{##3}\@citedata}
\def\citeyearNP{\def\@citeseppen{-1000}%
    \def\@cite##1##2{##1\if@tempswa , ##2\fi}%
    \def\citeauthoryear##1##2##3{##3}\@citedata}

%
% \@citedata and \@citedatax:
%
% Place commas in-between citations in the same \citeyear, \citeyearNP,
% or \citeN command.
% Use something like \citeN{ref1,ref2,ref3} and \citeN{ref4} for a list.
%
\def\@citedata{%
        \@ifnextchar [{\@tempswatrue\@citedatax}%
                                  {\@tempswafalse\@citedatax[]}%
}

\def\@citedatax[#1]#2{%
\if@filesw\immediate\write\@auxout{\string\citation{#2}}\fi%
  \def\@citea{}\@cite{\@for\@citeb:=#2\do%
    {\@citea\def\@citea{; }\@ifundefined% by Young
       {b@\@citeb}{{\bf ?}%
       \@warning{Citation `\@citeb' on page \thepage \space undefined}}%
{\csname b@\@citeb\endcsname}}}{#1}}%

% don't box citations, separate with ; and a space
% also, make the penalty between citations negative: a good place to break.
%
\def\@citex[#1]#2{%
\if@filesw\immediate\write\@auxout{\string\citation{#2}}\fi%
  \def\@citea{}\@cite{\@for\@citeb:=#2\do%
    {\@citea\def\@citea{; }\@ifundefined% by Young
       {b@\@citeb}{{\bf ?}%
       \@warning{Citation `\@citeb' on page \thepage \space undefined}}%
{\csname b@\@citeb\endcsname}}}{#1}}%

\newif\iffontfound
\newcommand\checkfont[1]{%
  \batchmode
  \font\test=#1\relax
  \errorstopmode
  \fontfoundfalse
  \ifx\test\nullfont \else \fontfoundtrue\fi
}

\newcommand\email[1]{{\normalfont\rmfamily
  \itshape\textup{(}e-mail: \textup{\texttt{#1})}}}

\edef\r@{\ifprodtf mtr\else cmr\fi}

\let\real@font@warning\@font@warning
\DeclareMathVersion{program}
\let\@font@warning\@gobble
\SetSymbolFont{letters}{program}{OT1}{\r@}{m}{sl}
\let\@font@warning\real@font@warning
\SetMathAlphabet{\mathnormal}{program}{OT1}{\r@}{m}{sl}

\newcommand{\programmath}{\mathversion{program}}
\newcommand{\unprogrammath}{\mathversion{normal}}
\newcommand{\figrule}{\begin{center}\hrule\end{center}}

\DeclareRobustCommand\dplus{\mathbin{+\!\!+}}
\DeclareRobustCommand\dequals{\mathbin{==}}
\DeclareRobustCommand\dcolon{\mathbin{::}}
\DeclareRobustCommand\dcolonequals{\mathbin{::=}}

\pagestyle{headings}
\pagenumbering{arabic}
\frenchspacing
\flushbottom

\endinput

% end of file tlp.cls
\end{filecontents*}

\begin{filecontents*}{acmtrans.bst}
% "ACM Transactions" BibTeX style, acmtrans.bst 
%  for BibTeX version 0.99c, LaTeX version 3.141
%  Revised 28-MARCH-1996
%  Revised 30-JUNE-1995
%  Revised 15-JAN-1996 
%  $Header: acmtrans.bst,v 1.2 96/01/17 09:05:38 boyland Exp $
%
% Hacked by John T. Boyland at University of California, Berkeley
% (with assistance by John R. Hauser)
% Hacked by Andrew W. Appel and Rebecca L. Davies at Princeton University,
% based on a "chicago.bst" by Glenn Paulley at U. Waterloo,
% which was based on "newapa.bst" found at ymir.claremont.edu.
%
%   Citation format: [author-last-name year]
%             [author-last-name and author-last-name year]
%             [author-last-name, author-last-name, and author-last-name year]
%             [author-last-name et al. year]
%             [author-last-name]
%             author-last-name [year]
%             [author-last-name and author-last-name]
%             [author-last-name et al.]
%             [year] or [year,year]
%             year or year,year
%
%   Reference list ordering: alphabetical by author or whatever passes
%    for author in the absence of one.
%
% This BibTeX style has support for abbreviated author lists and for
%    year-only citations.  This is done by having the citations
%    actually look like
%
%    \citeauthoryear{full-author-info}{abbrev-author-info}{year}
%
% The LaTeX style has to have the following (or similar)
%
%     \let\@internalcite\cite
%     \def\fullcite{\def\citeauthoryear##1##2##3{##1, ##3}\@internalcite}
%     \def\fullciteA{\def\citeauthoryear##1##2##3{##1}\@internalcite}
%     \def\shortcite{\def\citeauthoryear##1##2##3{##2, ##3}\@internalcite}
%     \def\shortciteA{\def\citeauthoryear##1##2##3{##2}\@internalcite}
%     \def\citeyear{\def\citeauthoryear##1##2##3{##3}\@internalcite}
%
% These TeX macro definitions are found in acmtrans.sty. Additional
% commands to manipulate different components of a citation can be defined
% so that, for example, you can list author's names without parentheses
% if using a citation as a noun or object in a sentence.
%
% Features of acmtrans.bst:
% ========================
%
% - all authors appear last name first.
% - all pages are listed xx-xx, (no pp.) and are at the end of the reference
% - publishers are identified as publisher, address
% - conferences papers (inproceedings) may give city of conference,
%   date of conference, and journal that the proceedings appear in.
% - months abbreviated to max four letters (eg. Mar.)
% - volume of a series indicated after the title of the series
% - editors appear after edited title and are identified by a trailing "Eds."
%   not in parentheses.  Editor names are not given in small caps.
%   (unless there is no author line)
% - names terminated with a period even if there is no first name.
% - editions are indicated trailing after the work, not in parentheses.
% - "et al." citations have a protected period to avoid bad spacing (jrh)
% - "address" required when publisher given
% - series (roman) and volume are in a sentence separate from (book-)title
%
%
% Features of chicago.bst:
% =======================
%
% - full names used in citations, but abbreviated citations are available
%   (see above)
% - if an entry has a "month", then the month and year are also printed
%   as part of that bibitem.
% - all conjunctions use "and" instead of "\&"
% - major modification from Chicago Manual of Style (13th ed.) is that
%   only the first author in a reference appears last name first-
%   additional authors appear as J. Q. Public.
% - pages are listed as "pp. xx-xx" in all entry types except
%   article entries.
% - book, inbook, and manual use "location: publisher" (or organization)
%   for address and publisher. All other types list publishers separately.
% - "pp." are used to identify page numbers for all entry types except
%   articles.
% - organization is used as a citation label if neither author nor editor
%   is present (for manuals).
% - "et al." is used for long author and editor lists, or when "others"
%   is used.
%
% Modifications and bug fixes from newapa.bst:
% ===========================================
%
%   - added month, year to bib entries if month is present
%   - fixed bug with In proceedings, added necessary comma after title
%   - all conjunctions changed to "and" from "\&"
%   - fixed bug with author labels in my.full.label: "et al." now is
%        generated when "others" is an author name
%   - major modification from Chicago Manual of Style (13th ed.) is that
%     only the first author in a reference appears last name first-
%     additional authors appear as J. Q. Public.
%   - pages are listed as "pp. xx-xx" in all entry types except
%     article entries. Unnecessary (IMHO) "()" around page numbers
%     were removed, and page numbers now don't end with a period.
%   - created chicago.sty for use with this bibstyle (required).
%   - fixed bugs in FUNCTION {format.vol.num.pages} for missing volume,
%     number, and /or pages. Renamed to format.jour.vol.
%   - fixed bug in formatting booktitles: additional period an error if
%     book has a volume.
%   - fixed bug: editors usually given redundant period before next clause
%     (format.editors.dot) removed.
%   - added label support for organizations, if both author and editor
%     are missing (from alpha.bst). If organization is too long, then
%     the key field is used for abbreviated citations.
%   - In proceedings or books of several volumes, no comma was written
%     between the "Volume x" and the page numbers (this was intentional
%     in newapa.bst). Fixed.
%   - Some journals may not have volumes/numbers, only month/year (eg.
%     IEEE Computer). Fixed bug in article style that assumed volume/number
%     was always present.
%
% Original documentation for newapa.sty:
% =====================================
%
% This version was made by modifying the master file made by
% Oren Patashnik (PATASHNIK@SCORE.STANFORD.EDU), and the 'named' BibTeX
% style of Peter F. Patel-Schneider.
%
% Copyright (C) 1985, all rights reserved.
% Copying of this file is authorized only if either
% (1) you make absolutely no changes to your copy, including name, or
% (2) if you do make changes, you name it something other than 'newapa.bst'.
% There are undoubtably bugs in this style.  If you make bug fixes,
% improvements, etc.  please let me know.  My e-mail address is:
%    spencer@cgrg.ohio.state.edu or 71160.3141@compuserve.com
%
% This style was made from 'plain.bst', 'named.bst', and 'apalike.bst',
% with lots of tweaking to make it look like APA style, along with tips
% from Young Ryu and Brian Reiser's modifications of 'apalike.bst'.

ENTRY
  { address
    author
    booktitle
    chapter
    city	% jtb: added
    date	% jtb: added
    edition
    editor
    howpublished
    institution
    journal
    key
    month
    note
    number
    organization
    pages
    publisher
    school
    series
    title
    type
    volume
    year
  }
  {}
  { label.year extra.label sort.year sort.label }

INTEGERS { output.state before.all mid.sentence after.sentence after.block }

FUNCTION {init.state.consts}
{ #0 'before.all :=
  #1 'mid.sentence :=
  #2 'after.sentence :=
  #3 'after.block :=
}

STRINGS { s t u }

FUNCTION {output.nonnull}
{ 's :=
  output.state mid.sentence =
    { ", " * write$ }
    { output.state after.block =
    { add.period$ write$
      newline$
      "\newblock " write$
    }
    { output.state before.all =
        'write$
        { add.period$ " " * write$ }
      if$
    }
      if$
      mid.sentence 'output.state :=
    }
  if$
  s
}

% Use a colon to separate output. Used only for address/publisher
% combination in book/inbook types, address/institution for manuals,
% and organization:publisher for proceedings (inproceedings).
%
FUNCTION {output.nonnull.colon}
{ 's :=
  output.state mid.sentence =
    { ": " * write$ }
    { output.state after.block =
    { add.period$ write$
      newline$
      "\newblock " write$
    }
    { output.state before.all =
        'write$
        { add.period$ " " * write$ }
      if$
    }
      if$
      mid.sentence 'output.state :=
    }
  if$
  s
}

FUNCTION {output}
{ duplicate$ empty$
    'pop$
    'output.nonnull
  if$
}

FUNCTION {output.colon}
{ duplicate$ empty$
    'pop$
    'output.nonnull.colon
  if$
}

FUNCTION {output.check}
{ 't :=
  duplicate$ empty$
    { pop$ "empty " t * " in " * cite$ * warning$ }
    'output.nonnull
  if$
}

FUNCTION {output.check.colon}
{ 't :=
  duplicate$ empty$
    { pop$ "empty " t * " in " * cite$ * warning$ }
    'output.nonnull.colon
  if$
}

FUNCTION {output.year.check}
{ year empty$
     { "empty year in " cite$ * warning$ }
     { write$
        " " year * extra.label *
       mid.sentence 'output.state :=
     }
  if$
}


FUNCTION {fin.entry}
{ add.period$
  write$
  newline$
}

FUNCTION {new.block}
{ output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.sentence}
{ output.state after.block =
    'skip$
    { output.state before.all =
    'skip$
    { after.sentence 'output.state := }
      if$
    }
  if$
}

FUNCTION {not}
{   { #0 }
    { #1 }
  if$
}

FUNCTION {and}
{   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {or}
{   { pop$ #1 }
    'skip$
  if$
}

FUNCTION {new.block.checka}
{ empty$
    'skip$
    'new.block
  if$
}

FUNCTION {new.block.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.block
  if$
}

FUNCTION {new.sentence.checka}
{ empty$
    'skip$
    'new.sentence
  if$
}

FUNCTION {new.sentence.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.sentence
  if$
}

FUNCTION {field.or.null}
{ duplicate$ empty$
    { pop$ "" }
    'skip$
  if$
}

%
% Emphasize the top string on the stack.
%
FUNCTION {emphasize}
{ duplicate$ empty$
    { pop$ "" }
    { "{\em " swap$ * "}" * }
  if$
}

%
% Emphasize the top string on the stack, but add a trailing space.
%
FUNCTION {emphasize.space}
{ duplicate$ empty$
    { pop$ "" }
    { "{\em " swap$ * "\/}" * }
  if$
}

%
% Emphasize the top string on stack, add a trailing comma and space.
%
FUNCTION {emphasize.comma}
{ duplicate$ empty$
    { pop$ "" }
    { "{\em " swap$ * ",\/}" * }
  if$
}

INTEGERS { nameptr namesleft numnames }
%
% Format bibliographical entries with the first author last name first,
% and subsequent authors with initials followed by last name.
% All names are formatted in this routine.
%

FUNCTION {format.names}
{ 's :=
  #1 'nameptr :=               % nameptr = 1;
  s num.names$ 'numnames :=    % numnames = num.name$(s);
  numnames 'namesleft :=
    { namesleft #0 > }

    { nameptr #1 =
        {"{\sc " s nameptr "{vv~}{ll}{, jj}{, f.}" format.name$ * "}" * 't := }
        {"{\sc " s nameptr "{vv~}{ll}{, jj}{, f.}" format.name$ * "}" * 't := }
      if$
      nameptr #1 >
        { namesleft #1 >
              { ", " * t * }
              { numnames #2 >
                  { "," * }
                  'skip$
                if$
                t "{\sc others}" =
                    { " {\sc et~al\mbox{.}}" * } % jrh: avoid spacing problems
                    { " {\sc and} " * t * } % from Chicago Manual of Style
                  if$
               }
               if$
             }
            't
        if$
        nameptr #1 + 'nameptr :=          % nameptr += 1;
        namesleft #1 - 'namesleft :=      % namesleft =- 1;
    }
  while$
}

FUNCTION {my.full.label}
{ 's :=
  #1 'nameptr :=               % nameptr = 1;
  s num.names$ 'numnames :=    % numnames = num.name$(s);
  numnames 'namesleft :=
    { namesleft #0 > }

    { s nameptr "{vv~}{ll}" format.name$ 't :=  % get the next name
      nameptr #1 >
        { namesleft #1 >
              { ", " * t * }
              { numnames #2 >
                  { "," * }
                  'skip$
                if$
                t "others" =
                    { " et~al\mbox{.}" * } % jrh: avoid spacing problems
                    { " and " * t * } % from Chicago Manual of Style
                  if$
               }
               if$
             }
            't
        if$
        nameptr #1 + 'nameptr :=          % nameptr += 1;
        namesleft #1 - 'namesleft :=      % namesleft =- 1;
    }
  while$

}

FUNCTION {format.names.fml}
%
% Format names in "familiar" format, with first initial followed by
% last name. Like format.names, ALL names are formatted.
% jtb: The names are NOT put in small caps
%
{ 's :=
  #1 'nameptr :=               % nameptr = 1;
  s num.names$ 'numnames :=    % numnames = num.name$(s);
  numnames 'namesleft :=
    { namesleft #0 > }

    { "{" s nameptr "{f.~}{vv~}{ll}{, jj}" format.name$ * "}" * 't :=

      nameptr #1 >
        { namesleft #1 >
              { ", " * t * }
               { numnames #2 >
                    { "," * }
                    'skip$
                  if$
                  t "{others}" =
                        { " {et~al\mbox{.}}" * }
                        { " {and} " * t * }
%                       { " {\&} " * t * }
                      if$
                }
               if$
             }
            't
        if$
        nameptr #1 + 'nameptr :=          % nameptr += 1;
        namesleft #1 - 'namesleft :=      % namesleft =- 1;
    }
  while$
}

FUNCTION {format.authors}
{ author empty$
    { "" }
    { author format.names add.period$} % jtb: add period if none before
  if$
}

FUNCTION {format.key}
{ empty$
    { key field.or.null }
    { "" }
  if$
}

%
% Format editor names for use in the "in" types: inbook, incollection,
% inproceedings: first initial, then last names. When editors are the
% LABEL for an entry, then format.editor is used which lists editors
% by last name first.
%
FUNCTION {format.editors.fml}
{ editor empty$
    { "" }
    { editor format.names.fml
      editor num.names$ #1 >
    { ", Eds." * }	% jtb: removed parentheses
    { ", Ed." * }	% jtb: removed parentheses
      if$
    }
  if$
}

%
% Format editor names for use in labels, last names first.
%
FUNCTION {format.editors}
{ editor empty$
    { "" }
    { editor format.names
      editor num.names$ #1 >
    { ", Eds." * }	% jtb: removed parentheses
    { ", Ed." * }	% jtb: removed parentheses
      if$
    }
  if$
}

FUNCTION {format.title}
{ title empty$
    { "" }
    { title "t" change.case$ }
  if$
}

% Note that the APA style requres case changes
% in article titles. The following does not
% change cases. If you perfer it, uncomment the
% following and comment out the above.

%FUNCTION {format.title}
%{ title empty$
%    { "" }
%    { title }
%  if$
%}

FUNCTION {n.dashify}
{ 't :=
  ""
    { t empty$ not }
    { t #1 #1 substring$ "-" =
    { t #1 #2 substring$ "--" = not
        { "--" *
          t #2 global.max$ substring$ 't :=
        }
        {   { t #1 #1 substring$ "-" = }
        { "-" *
          t #2 global.max$ substring$ 't :=
        }
          while$
        }
      if$
    }
    { t #1 #1 substring$ *
      t #2 global.max$ substring$ 't :=
    }
      if$
    }
  while$
}

FUNCTION {format.btitle}
{ edition empty$
  { title emphasize }
  { title empty$
    { title emphasize } % jtb: what is this supposed to do ?!?
    { "{\em " title * "\/}, " * edition * " ed." * } % jtb: no parens for ed.
    if$
  }
  if$
}

FUNCTION {format.emphasize.booktitle}
{ edition empty$
  { booktitle emphasize }
  { booktitle empty$
    { booktitle emphasize } % jtb: what is this supposed to do ?!?
    { "{\em " booktitle * "\/}, " * edition * " ed." * } % jtb: no ()s for ed.
    if$
    }
  if$
  }

% jtb: if the preceding string (the title of the conference) is non-empty,
% jtb: append the location, otherwise leave empty (so as to trigger the
% jtb: error message in output.check
FUNCTION {format.city}
{ duplicate$ empty$
  { }
  { city empty$
     { date empty$
       { }
       { " (" * date * ")" * }
       if$
     }
     { date empty$
       { " (" * city * ")" * }
       { " (" * city * ", " * date * ")" * }
       if$
     }
     if$
  }
  if$
}

FUNCTION {tie.or.space.connect}
{ duplicate$ text.length$ #3 <
    { "~" }
    { " " }
  if$
  swap$ * *
}

FUNCTION {either.or.check}
{ empty$
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}

% jtb: If there is a series, this is added and the volume trails after it.
% jtb: Otherwise, "Vol" is Capitalized.
FUNCTION {format.bvolume}
{ volume empty$
    { "" }
    { series empty$
        { "Vol." volume tie.or.space.connect}
        { series ", " * "vol." volume tie.or.space.connect *}
      if$
      "volume and number" number either.or.check
    }
  if$
}

FUNCTION {format.number.series}
{ volume empty$
    { number empty$
    { series field.or.null }
    { output.state mid.sentence =
        { "Number" } % gnp - changed to mixed case always
        { "Number" }
      if$
      number tie.or.space.connect
      series empty$
        { "there's a number but no series in " cite$ * warning$ }
        { " in " * series * }
      if$
    }
      if$
    }
    { "" }
  if$
}

INTEGERS { multiresult }

FUNCTION {multi.page.check}
{ 't :=
  #0 'multiresult :=
    { multiresult not
      t empty$ not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
    { #1 'multiresult := }
    { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}

FUNCTION {format.pages}
{ pages empty$
  { "" }
  { pages multi.page.check
	{ pages n.dashify } % gnp - removed () % jtb: removed pp.
	{ pages }
    if$
  }
  if$
}

% By Young (and Spencer)
% GNP - fixed bugs with missing volume, number, and/or pages
%
% Format journal, volume, number, pages for article types.
%
FUNCTION {format.jour.vol}
{ journal empty$
    { "no journal in " cite$ * warning$
      "" }
    { journal emphasize.space }
    if$
  number empty$
    { volume empty$
       { "no number and no volume in " cite$ * warning$
         "" * }
       { "~{\em " * Volume * "}" * }
      if$
    }
    { volume empty$
      {"no volume for " cite$ * warning$
       "~" * number * }
      { "~" *
        volume emphasize.comma
        "~" * number * * }
      if$
     month empty$
     {} 
     {" (" * month * ")" *} 
     if$
    }
  if$
  pages empty$
    {"page numbers missing in " cite$ * warning$
     "" * } % gnp - place a null string on the stack for output
    { duplicate$ empty$
      { pop$ format.pages }
      { ", " *  pages n.dashify * } % gnp - removed pp. for articles
      if$
    }
  if$
}

FUNCTION {format.chapter.pages}
{ chapter empty$
    'format.pages
    { type empty$
        { "Chapter" } % gnp - changed to mixed case
        { type "t" change.case$ }
      if$
      chapter tie.or.space.connect
      pages empty$
        {"page numbers missing in " cite$ * warning$} % gnp - added check
        { ", " * format.pages * }
      if$
    }
  if$
}

% jtb: format for collections or proceedings not appearing in a journal
FUNCTION {format.in.emphasize.booktitle}
{ booktitle empty$
  { "" }
  { "In " format.emphasize.booktitle * }
  if$
}

% jtb: format for proceedings appearing in a journal
FUNCTION {format.in.booktitle}
{ booktitle empty$
  { "" }
  { "In " booktitle * }
  if$
}

FUNCTION {format.in.ed.booktitle}
{ booktitle empty$
  { "" }
  { editor empty$
    { "In " format.emphasize.booktitle * }
		% jtb: swapped editor location
    { "In " format.emphasize.booktitle * ", " * format.editors.fml * }
    if$
  }
  if$
}

FUNCTION {format.thesis.type}
{ type empty$ 
    'skip$
%   {pop$
   {{ "" }
   type "t" change.case$}
  if$
}

FUNCTION {format.tr.number}
{ type empty$
    { "Tech. Rep." }
    'type
  if$
  number empty$
    { "t" change.case$ }
    { number tie.or.space.connect }
  if$
}

FUNCTION {format.article.crossref}
{ "See"
  "\citeN{" * crossref * "}" *
}

FUNCTION {format.crossref.editor}
{ editor #1 "{vv~}{ll}" format.name$
  editor num.names$ duplicate$
  #2 >
    { pop$ " et~al\mbox{.}" * }		% jrh: avoid spacing problems
    { #2 <
    'skip$
    { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
        { " et~al\mbox{.}" * }		% jrh: avoid spacing problems
        { " and " * editor #2 "{vv~}{ll}" format.name$ * }
      if$
    }
      if$
    }
  if$
}

FUNCTION {format.book.crossref}
{ volume empty$
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      "In "
    }
    { "Volume" volume tie.or.space.connect % gnp - changed to mixed case
      " of " *
    }
  if$
  editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
    { series empty$
        { "need editor, key, or series for " cite$ * " to crossref " *
          crossref * warning$
          "" *
        }
        { "{\em " * series * "\/}" * }
      if$
    }
    { key * }
      if$
    }
    { format.crossref.editor * }
  if$
  " \citeN{" * crossref * "}" *
}

FUNCTION {format.incoll.inproc.crossref}
{ "See"
  " \citeN{" * crossref * "}" *
}

% format.lab.names:
%
% determines "short" names for the abbreviated author information.
% "Long" labels are created in calc.label, using the routine my.full.label
% to format author and editor fields.
%
% There are 4 cases for labels.   (n=3 in the example)
% a) one author             Foo
% b) one to n               Foo, Bar and Baz
% c) use of "and others"    Foo, Bar et al.
% d) more than n            Foo et al.
%
FUNCTION {format.lab.names}
{ 's :=
  s num.names$ 'numnames :=
  numnames #2 >    % change number to number of others allowed before
		   % forcing "et al".
    { s #1 "{vv~}{ll}" format.name$ " et~al\mbox{.}" * } % jrh: \mbox{} added
    {
      numnames #1 - 'namesleft :=
      #2 'nameptr :=
      s #1 "{vv~}{ll}" format.name$
	{ namesleft #0 > }
	{ nameptr numnames =
	    { s nameptr "{ff }{vv }{ll}{ jj}" format.name$ "others" =
		{ " et~al\mbox{.}" * }		% jrh: avoid spacing problems
		{ " and " * s nameptr "{vv~}{ll}" format.name$ * }
	      if$
	    }
	    { ", " * s nameptr "{vv~}{ll}" format.name$ * }
	  if$
	  nameptr #1 + 'nameptr :=
	  namesleft #1 - 'namesleft :=
	}
      while$
    }
  if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$
          { "no key, author in " cite$ * warning$
            cite$ #1 #3 substring$ }
         'key
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.label}
{ editor empty$
    { key empty$
          { "no key, editor in " cite$ * warning$
            cite$ #1 #3 substring$ }
          'key
        if$
     }
     { editor format.lab.names }
  if$
}

FUNCTION {author.key.organization.label}
%
% added - gnp. Provide label formatting by organization if author is null.
%
{ author empty$
    { organization empty$
	{ key empty$
	    { "no key, author or organization in " cite$ * warning$
              cite$ #1 #3 substring$ }
	    'key
	  if$
	}
        { organization }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.organization.label}
%
% added - gnp. Provide label formatting by organization if editor is null.
%
{ editor empty$
    { organization empty$
	{ key empty$
	    { "no key, editor or organization in " cite$ * warning$
              cite$ #1 #3 substring$ }
	    'key
	  if$
	}
        { organization }
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
          { key empty$
               { "no key, author, or editor in " cite$ * warning$
                 cite$ #1 #3 substring$ }
             'key
           if$
         }
          { editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {calc.label}
%
% Changed - GNP. See also author.organization.sort, editor.organization.sort
% Form label for BibTeX entry. The classification of which fields are used
% for which type of entry (book, inbook, etc.) are taken from alpha.bst.
% The change here from newapa is to also include organization as a
% citation label if author or editor is missing.
%
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.key.label
    { type$ "proceedings" =
	'editor.key.organization.label
	{ type$ "manual" =
	    'author.key.organization.label
	    'author.key.label
	  if$
	}
      if$
    }
  if$

  author empty$  % generate the full label citation information.
    { editor empty$
        { organization empty$
           { "no author, editor, or organization in " cite$ * warning$
             "??" }
           { organization }
           if$
        }
        { editor my.full.label }
        if$
    }
    { author my.full.label }
  if$

% leave label on the stack, to be popped when required.

  "}{" * swap$ * "}{" *
%  year field.or.null purify$ #-1 #4 substring$ *
%
% save the year for sort processing afterwards (adding a, b, c, etc.)
%
  year field.or.null purify$ #-1 #4 substring$
  'label.year :=
}

FUNCTION {output.bibitem}
{ newline$

  "\bibitem[\protect\citeauthoryear{" write$
  calc.label write$
  sort.year write$
  "}]{" write$

  cite$ write$
  "}" write$
  newline$
  ""
  before.all 'output.state :=
}

FUNCTION {article}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output          % added
  output.year.check                 % added
  new.block
  format.title
  "title" output.check
  new.block
  crossref missing$
    { format.jour.vol output
    }
    { format.article.crossref output.nonnull
      format.pages output
    }
  if$
  new.block
  note output
  fin.entry
}

FUNCTION {book}
{ output.bibitem
  author empty$
    { format.editors
	  "author and editor" output.check }
    { format.authors
	  output.nonnull
      crossref missing$
    	{ "author and editor" editor either.or.check }
    	'skip$
      if$
    }
  if$
  output.year.check       % added
  new.block
  format.btitle
  "title" output.check
  crossref missing$
    { new.sentence		% jtb: start a new sentence for series/volume
      format.bvolume output
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" output.check
      address "address" output.check	% jtb: require address
    }
    { new.block
      format.book.crossref output.nonnull
    }
  if$
  new.block
  note output
  fin.entry
}

FUNCTION {booklet}
{ output.bibitem
  format.authors output
  author format.key output          % added
  output.year.check                 % added
  new.block
  format.title
  "title" output.check
  new.block
  howpublished output
  address output
  new.block
  note output
  fin.entry
}

FUNCTION {inbook}
{ output.bibitem
  author empty$
    { format.editors
      "author and editor" output.check
    }
    { format.authors output.nonnull
      crossref missing$
    { "author and editor" editor either.or.check }
    'skip$
      if$
    }
  if$
  output.year.check                 % added
  new.block
  format.btitle
  "title" output.check
  crossref missing$
    { new.sentence		% jtb: start a new sentence for series/volume
      format.bvolume output
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" output.check
      address "address" output.check	% jtb: require address
      format.chapter.pages
      "chapter and pages" output.check	% jtb: moved from before publisher
    }
    { format.chapter.pages "chapter and pages" output.check
      new.block
      format.book.crossref output.nonnull
    }
  if$
  new.block
  note output
  fin.entry
}

FUNCTION {incollection}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output       % added
  output.year.check              % added
  new.block
  format.title
  "title" output.check
  new.block
  crossref missing$
  { format.in.ed.booktitle
    "booktitle" output.check
    new.sentence		% jtb: start a new sentence for series/volume
    format.bvolume output
    format.number.series output
    new.sentence
    publisher "publisher" output.check
    address "address" output.check	% jtb: require address
    format.chapter.pages output % gnp - was special.output.nonnull
%                                 left out comma before page numbers
				% jtb: moved from before publisher
  }
  { format.incoll.inproc.crossref
	output.nonnull
    format.chapter.pages output
  }
  if$
  new.block
  note output
  fin.entry
}

FUNCTION {inproceedings}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output            % added
  output.year.check                   % added
  new.block
  format.title
  "title" output.check
  new.block
  crossref missing$
    { journal missing$		% jtb: proceedings appearing in journals
      { format.in.emphasize.booktitle format.city "booktitle" output.check
        format.editors.fml output
        new.sentence		% jtb: start a new sentence for series/volume
        format.bvolume output
        format.number.series output
        new.sentence
        organization output
        publisher "publisher" output.check % jtb: require publisher (?)
        address "address" output.check	% jtb: require address
        format.pages output	% jtb: moved from before publisher
       }
       % jtb: new:
       { format.in.booktitle format.city "booktitle" output.check
         format.editors.fml output
         new.sentence
         format.jour.vol output
       }
       if$
      }
    { format.incoll.inproc.crossref output.nonnull
      format.pages output
    }
  if$
  new.block
  note output
  fin.entry
}

FUNCTION {conference} { inproceedings }

FUNCTION {manual}
{ output.bibitem
  author empty$
    { editor empty$
      { organization "organization" output.check
        organization format.key output }  % if all else fails, use key
      { format.editors "author and editor" output.check }
      if$
    }
    { format.authors output.nonnull }
    if$
  output.year.check                 % added
  new.block
  format.btitle
  "title" output.check
  organization address new.block.checkb
  % jtb: back to normal style: organization, address
  organization "organization" output.check
  address output
  new.block
  note output
  fin.entry
}

FUNCTION {mastersthesis}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output          % added
  output.year.check                 % added
  new.block
  format.title
  "title" output.check
  new.block
  "M.S.\ thesis" format.thesis.type output.nonnull
  school "school" output.check
  address output
  new.block
  note output
  fin.entry
}

FUNCTION {misc}
{ output.bibitem
  format.authors output
  author format.key output            % added
  output.year.check                   % added
  title howpublished new.block.checkb
  format.title output
  new.block
  howpublished output
  new.block
  note output
  fin.entry
}

FUNCTION {phdthesis}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output            % added
  output.year.check                   % added
  new.block
  format.title
  "title" output.check
  new.block  
  format.thesis.type "Ph.D. thesis" output.nonnull
  school "school" output.check
  address output
  new.block
  note output
  fin.entry
}

FUNCTION {proceedings}
{ output.bibitem
  editor empty$
    { organization output
      organization format.key output }  % gnp - changed from author format.key
    { format.editors output.nonnull }
  if$
% author format.key output             % gnp - removed (should be either
%                                        editor or organization
  output.year.check                    % added (newapa)
  new.block
  format.btitle format.city "title" output.check	% jtb: added city
  new.sentence
  format.bvolume output
  format.number.series output
  new.sentence
  organization output
  % jtb: normal order: publisher, address
  publisher output
  address output
  new.block
  note output
  fin.entry
}

FUNCTION {techreport}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output             % added
  output.year.check                    % added
  new.block
  format.title
  "title" output.check
  new.block
  format.tr.number output		% jtb: moved month ...
  institution "institution" output.check
  address output
  new.sentence
  month output				% jtb: ... to here (no parens)
  new.block
  note output
  fin.entry
}

FUNCTION {unpublished}
{ output.bibitem
  format.authors
  "author" output.check
  author format.key output              % added
  output.year.check                      % added
  new.block
  format.title
  "title" output.check
  new.block
  note "note" output.check
  fin.entry
}

FUNCTION {default.type} { misc }

MACRO {jan} {"Jan."}

MACRO {feb} {"Feb."}

MACRO {mar} {"Mar."}		% jtb: corrected: was "March"

MACRO {apr} {"Apr."}		% jtb: corrected: was "April"

MACRO {may} {"May"}

MACRO {jun} {"June"}

MACRO {jul} {"July"}

MACRO {aug} {"Aug."}

MACRO {sep} {"Sept."}

MACRO {oct} {"Oct."}

MACRO {nov} {"Nov."}

MACRO {dec} {"Dec."}

MACRO {acmcs} {"ACM Comput. Surv."}

MACRO {acmlett} {"ACM Lett. Program. Lang. Syst."}

MACRO {acta} {"Acta Inf."}

MACRO {ai} {"Artificial Intelligence"}

MACRO {al} {"Ada Lett."}

MACRO {acr} {"Adv. Comput. Res."}

MACRO {bit} {"Bit"}

MACRO {cacm} {"Commun. ACM"}

MACRO {cj} {"Comput. J."}

MACRO {cn} {"Comput. Netw."}

MACRO {cl} {"Comput. Lang."}

MACRO {ibmjrd} {"IBM J. Res. and Development"}

MACRO {ibmsj} {"IBM Systems Journal"}

MACRO {ict} {"Inf. Contr."}

MACRO {ieebcs} {"IEE/BCS Softw. Eng. J."}

MACRO {ieees} {"IEEE Softw."}

MACRO {ieeese} {"IEEE Trans. Softw. Eng."}

MACRO {ieeetc} {"IEEE Trans. Comput."}

MACRO {ieeetcad}
 {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}

MACRO {ieeetpds} {"IEEE Trans. Parall. Distrib. Syst."}

MACRO {ieeetit} {"IEEE Trans. Inf. Theory"}

MACRO {ipl} {"Inf. Process. Lett."}

MACRO {icp} {"Inf. Comput."}

MACRO {ist} {"Inf. Softw. Tech."}

MACRO {ijsa} {"Int. J. Supercomput. Appl."}

MACRO {ijpp} {"Int. J. Parallel Program."}

MACRO {jlp} {"J. Logic Program."}

MACRO {jfp} {"J. Funct. Program."}

MACRO {jcss} {"J. Comput. Syst. Sci."}

MACRO {jsmrp} {"J. Softw. Maint. Res. Pract."}

MACRO {jss} {"J. Syst. Softw."}

MACRO {jlc} {"J. Logic and Comput."}

MACRO {jlsc} {"J. Lisp Symb. Comput."}

MACRO {lpls} {"Lett. Program. Lang. Syst."}

MACRO {mor} {"Math. Oper. Res."}

MACRO {mscs} {"Math. Struct. Comput. Sci."}

MACRO {mst} {"Math. Syst. Theor."}	% jtb: was Math. Syst. Theory
				% jtb: (if you ask me, I prefer the old way)
MACRO {ngc} {"New Gen. Comput."}

MACRO {scp} {"Sci. Comput. Program."}

MACRO {sicomp} {"SIAM J. Comput."}

MACRO {spe} {"Softw. Pract. Exper."}

MACRO {tocs} {"ACM Trans. Comput. Syst."}

MACRO {tods} {"ACM Trans. Database Syst."}

MACRO {tog} {"ACM Trans. Graphics"}

MACRO {toms} {"ACM Trans. Math. Softw."}

MACRO {toois} {"ACM Trans. Office Inf. Syst."}

MACRO {toplas} {"ACM Trans. Program. Lang. Syst."}

MACRO {tocl} {"ACM Trans. On Comp. Logic"}

MACRO {tcs} {"Theor. Comput. Sci."}	% jtb: was Theor. Comp. Sci.

MACRO {tr} {"Tech. Rep."}

READ

FUNCTION {sortify}
{ purify$
  "l" change.case$
}

INTEGERS { len }

FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}



FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  ""
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { nameptr #1 >
          { "   " * }
         'skip$
      if$
      s nameptr "{vv{ } }{ll{ }}{  f{ }}{  jj{ }}" format.name$ 't :=
      nameptr numnames = t "others" = and
          { " et~al" * }
          { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}

FUNCTION {author.sort}
{ author empty$
    { key empty$
         { "to sort, need author or key in " cite$ * warning$
           "" }
         { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.sort}
{ editor empty$
    { key empty$
         { "to sort, need editor or key in " cite$ * warning$
           ""
         }
         { key sortify }
      if$
    }
    { editor sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty$
    { "missing author in " cite$ * warning$
      editor empty$
         { key empty$
             { "to sort, need author, editor, or key in " cite$ * warning$
               ""
             }
             { key sortify }
           if$
         }
         { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.organization.sort}
%
% added - GNP. Stack author or organization for sorting (from alpha.bst).
% Unlike alpha.bst, we need entire names, not abbreviations
%
{ author empty$
    { organization empty$
	{ key empty$
	    { "to sort, need author, organization, or key in " cite$ * warning$
	      ""
	    }
	    { key sortify }
	  if$
	}
	{ organization sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.organization.sort}
%
% added - GNP. Stack editor or organization for sorting (from alpha.bst).
% Unlike alpha.bst, we need entire names, not abbreviations
%
{ editor empty$
    { organization empty$
	{ key empty$
	    { "to sort, need editor, organization, or key in " cite$ * warning$
	      ""
	    }
	    { key sortify }
	  if$
	}
	{ organization sortify }
      if$
    }
    { editor sort.format.names }
  if$
}

FUNCTION {presort}
%
% Presort creates the bibentry's label via a call to calc.label, and then
% sorts the entries based on entry type. Chicago.bst adds support for
% including organizations as the sort key; the following is stolen from
% alpha.bst.
%
{ calc.label sortify % recalculate bibitem label
  year field.or.null purify$ #-1 #4 substring$ * % add year
  "    "
  *
  type$ "book" =
  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
	'editor.organization.sort
	{ type$ "manual" =
	    'author.organization.sort
	    'author.sort
	  if$
	}
      if$
    }
  if$
  #1 entry.max$ substring$        % added for newapa
  'sort.label :=                  % added for newapa
  sort.label                      % added for newapa
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}

SORT             % by label, year, author/editor, title

STRINGS { last.label next.extra }

INTEGERS { last.extra.num }

FUNCTION {initialize.extra.label.stuff}
{ #0 int.to.chr$ 'last.label :=
  "" 'next.extra :=
  #0 'last.extra.num :=
}

FUNCTION {forward.pass}
%
% Pass through all entries, comparing current entry to last one.
% Need to concatenate year to the stack (done by calc.label) to determine
% if two entries are the same (see presort)
%
{ last.label
  calc.label year field.or.null purify$ #-1 #4 substring$ * % add year
  #1 entry.max$ substring$ =     % are they equal?
     { last.extra.num #1 + 'last.extra.num :=
       last.extra.num int.to.chr$ 'extra.label :=
     }
     { "a" chr.to.int$ 'last.extra.num :=
       "" 'extra.label :=
       calc.label year field.or.null purify$ #-1 #4 substring$ * % add year
       #1 entry.max$ substring$ 'last.label := % assign to last.label
     }
  if$
}

FUNCTION {reverse.pass}
{ next.extra "b" =
    { "a" 'extra.label := }
     'skip$
  if$
  label.year extra.label * 'sort.year :=
  extra.label 'next.extra :=
}

EXECUTE {initialize.extra.label.stuff}

ITERATE {forward.pass}

REVERSE {reverse.pass}

FUNCTION {bib.sort.order}
{ sort.label
  "    "
  *
  year field.or.null sortify
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {bib.sort.order}

SORT             % by sort.label, year, title --- giving final bib. order.

FUNCTION {begin.bib}

{ preamble$ empty$
    'skip$
    { preamble$ write$ newline$ }
  if$
  "\begin{thebibliography}{}" write$ newline$
}


EXECUTE {begin.bib}

EXECUTE {init.state.consts}

ITERATE {call.type$}

FUNCTION {end.bib}
{ newline$
  "\end{thebibliography}" write$ newline$
}

EXECUTE {end.bib}
\end{filecontents*}

\begin{filecontents*}{tlp2egui.tex}
% TLP2egui.tex / guide for TLP
% v2.12, released 23-apr-2003
%   (based on JFP2egui.tex v1.01)
% Copyright (C) 2000,2001,2002,2003 Cambridge University Press

\NeedsTeXFormat{LaTeX2e}

\documentclass{tlp}
\nocite{*}% includes all entries of BibTeX database into the list of references.

%%% Macros for the guide only %%%
\hyphenation{either}
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

  \title[Theory and Practice of Logic Programming]
        {\LaTeXe\ guide for Theory and Practice of
        Logic Programming}

  \author[A. J. Woollatt]
         {ALISON J. WOOLLATT\\
         Cambridge University Press, Cambridge CB2 2BS, UK\\
         \email{texline@cambridge.org}}

\jdate{March 2003}
\pubyear{2003}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{S1471068401001193}

\newtheorem{lemma}{Lemma}[section]

\begin{document}

\label{firstpage}

\maketitle

  \begin{abstract}
    This guide is for authors who are preparing papers for the journal 
    \emph{Theory and Practice of Logic Programming} (hereafter called
    Logic Programming) using the \LaTeXe\ document-preparation system
    and the Logic Programming class file (\texttt{tlp.cls}).
  \end{abstract}

  \begin{keywords}
    \LaTeX2e guide, Cambridge University Press, typeface
  \end{keywords}

\tableofcontents

\section{Introduction}

In addition to the standard submission of hardcopy from authors, the
journal now accepts machine-readable forms of papers
in \LaTeXe. The layout design for the \emph{Logic Programming} journal
has been implemented as a \LaTeXe\ class file, based on the \verb"article"
class as discussed in the \LaTeX\ manual (2nd edition) \cite{LaTeX}.
Commands which differ from the standard \LaTeXe\ interface, or which are
provided in addition to the standard interface, are explained in this
guide (which is \emph{not} a substitute for the \LaTeXe\ manual itself).

Note that the final printed version of papers will use the Monotype Times
typeface rather than the Computer Modern typeface available to authors. For
this reason line and page breaks will change and authors should not insert
hard breaks in their text.

Authors planning to submit their papers in \LaTeXe\ are advised to use
\verb"tlp.cls" as early as possible in the creation of their files.

\subsection{Introduction to \LaTeX}

\LaTeX\ is constructed as a series of macros on top of the \TeX\ typesetting
program. \LaTeX\ adds to \TeX\ a collection of facilities which simplify
typesetting for authors by allowing them to concentrate on the logical
structure of the document rather than its visual layout. Careful use of the
\LaTeX\ mark-up philosophy results in uniform layout rather than the
\emph{ad hoc} results of some word-processing systems. Authors are advised to
let the defaults control font selection etc., rather than tinker themselves.

The \LaTeX\ system provides a consistent and comprehensive document preparation
interface. Among other things, \LaTeX\ can automatically number list
entries, equations, figures, tables and footnotes, as well as sections and
subsections. Using this numbering system, bibliographic citations, page
references and cross references to any other numbered entity (e.g. sections,
equations, figures) are straightforward.

\subsection{The TLP document class}

The use of document classes allows a simple change of style (or style option)
to transform the appearance of your document. The TLP class preserves the
standard \LaTeX\ interface such that any document which can be produced
using the standard \LaTeX\ \verb"article" class can also be produced with
the TLP class.
However, the measure (or width of text) is different from that
for ARTICLE; therefore line breaks will change and it is possible that
longer equations may need re-setting.
Authors are urged to use \verb"tlp.cls" from the beginning of their document
preparation, otherwise longer lines may require re-formatting at a later stage.

\subsection{General style issues}

Use of \LaTeX\ defaults will result in a pleasing uniformity of layout
and font selection. Authors should resist the temptation to make
\emph{ad hoc} changes to these. Also avoid use of direct formatting unless
really necessary. Papers will be edited as usual, and this process may be
obstructed by the use of inserted line breaks, etc.

For general style issues, authors are referred to the `Preparation of
manuscripts' in the back cover of the journal. Authors who are interested in
the details of style are referred to \citeN{Butcher} and \citeN{Chicago}. The
language used in the journal is British English, and spelling should conform
to this.

Use should be made of symbolic references (\verb"\ref") in order to
protect against late changes of order, etc.

\subsection{Submission of \LaTeX\ articles}

Authors who intend to submit a \LaTeX\ article should obtain a copy of the
TLP class file. This is available by anonymous FTP from
%
\begin{verbatim}
  ftp.cup.cam.ac.uk
\end{verbatim}
%
You will find the class file and instructions contained in a
single file \verb"tlpcls.ltx" in the directory
%
\begin{verbatim}
  pub/texarchive/journals/latex/tlp-cls
\end{verbatim}
%
The \verb"readme.txt" (which is the same directory) tells you how to
unpack the file \verb"tlpcls.ltx".
There is also an `\verb"unpacked"' directory containing all the files
separately, in case of difficulty. If you cannot obtain the TLP files,
use the standard \verb"article" class, with the default `\verb"10pt"' option.

When submitting the final article, ensure that  the following are included and
are clearly labelled.
\begin{enumerate}
  \item A hardcopy printout of the article.
  \item The input file (exactly matching the hardcopy).
  \item A copy of any user-defined macros.
  \item If you have used \textsc{Bib}\TeX, the \verb".bib", \verb".bbl"
        and \verb".bst" files that were used.
  \item Any other files necessary to prepare the article for typesetting.
\end{enumerate}
The files for the \emph{final} article should be text-only. Hardcopy
(or postscript) and files of the final article are submitted to the
Editor-in-Chief. 


\section{Using the TLP class file}
\label{usingtlpclass}

First, copy the file \verb"tlp.cls" (and download \verb"acmtrans.bst" if you 
use Bib\TeX -- see section~\ref{acmtrans} on page~\pageref{acmtrans} for 
downloading instructions) into an appropriate subdirectory on your system. 
The TLP class is implemented as a complete document class, and \emph{not} 
as an class option. In order to use the TLP class, replace \verb"article" 
by \verb"tlp" in the \verb"\documentclass" command at the beginning of your 
document: that is,
%
\begin{verbatim}
  \documentclass{article}
\end{verbatim}
%
is replaced by
%
\begin{verbatim}
  \documentclass{tlp}
\end{verbatim}
%
Author-defined macros should be inserted before \verb"\begin{document}",
or in a separate file and should be included with the submission.
Authors must not change any of the macro definitions or parameters
in \verb"tlp.cls".

\subsection{Document class options}\label{sec:ClassOp}

In general, the following standard document class options should \emph{not} be
used with the TLP class file:
%
\begin{itemize}
  \item \texttt{10pt}, \texttt{11pt} and \texttt{12pt} -- unavailable;
  \item \texttt{twoside} is the default (\texttt{oneside} is disabled);
  \item \texttt{onecolumn} is the default (\texttt{twocolumn} is disabled);
  \item \texttt{titlepage} is not required and is disabled;
  \item \texttt{fleqn} and \texttt{leqno} should not be used, and are disabled.
\end{itemize}
%
\ifprodtf
The following new class options are provided:
\begin{itemize}
  \item \texttt{prodtf} -- tells the class file that we want to use the
    production typeface. This automatically sets the odd, even and top
    margins.
\end{itemize}
\fi

\section{Additional facilities}

In addition to all the standard \LaTeX\ design elements, the TLP class
includes the following features.
%
\begin{itemize}
  \item Additional commands for typesetting the title page. Extended
        commands for specifying a short version of the title and author(s)
        for the running headlines.
  \item A new option to the \verb"\maketitle" command to create a 
        Programming Pearl.
  \item A \verb"proof" environment.
  \item A \verb"keywords" environment for typesetting Keywords.
  \item Control of enumerated lists.
\end{itemize}
%
Once you have used these additional facilities in your document,
it can be processed only with \verb"tlp.cls".

\subsection{Titles, authors' names and running headlines}

At the beginning of your article, the title should be generated in the
usual way using the \verb"\maketitle" command. Immediately following the
title you must include an abstract and keywords. 
For example, the titles for this guide were produced by the following source.
%
\begin{verbatim}
  \title[Theory and Practice of Logic Programming]
        {\LaTeXe\ guide for the Theory and Practice of
        Logic Programming}

  \author[A. J. Woollatt]
         {ALISON J. WOOLLATT\\
         Cambridge University Press, Cambridge CB2 2BS, UK\\
         \email{texline@cambridge.org}}
\end{verbatim}

\begin{verbatim}
  \begin{document}
  \maketitle

  \begin{abstract}
    This guide is for authors who are preparing papers...
  \end{abstract}

  \begin{keywords}
    \LaTeX2e guide, Cambridge University Press, typeface
  \end{keywords}
\end{verbatim}

In the TLP class, the title of the article and the author's name (or
authors' names) are used both at the beginning of the article for the main
title and throughout the article as running headlines at the top of every
page. The title is used on odd-numbered pages (rectos) and the author's name
appears on even-numbered pages (versos). The \verb"\pagestyle" and
\verb"\thispagestyle" commands should \emph{not} be used.  Similarly, the
commands \verb"\markright" and \verb"\markboth" should not be necessary.

Although the article title can run to several lines of text, the running
headline must be a single line. Moreover, the title can incorporate new-line
commands (e.g. \verb"\\"), but these are not acceptable in a running headline.
To enable you to specify an alternative short title, and an alternative short
author's name, the standard \verb"\title" and \verb"\author" commands have
been extended to take an optional argument to be used as the running headline.
%
\begin{verbatim}
  \title[Short title]
        {Full title which can be as long as necessary}
  \author[Author name]
         {AUTHOR NAME \\ Affiliation}
\end{verbatim}
%
Notice that the author name in the argument for the running head should
be in mixed case, and the author name for the title should be in upper
case only. The author affiliation is set in the normal way, after a
\verb"\\" in the argument to the \verb"\author" command.

Any `work supported by' or `authors current address' information should
be inserted via \verb"\thanks" commands, which should be positioned
after the appropriate `AUTHOR NAME' in the \verb"\author" command.

If there are four (or more) authors for the article, the author running head
should contain the first author name followed by `et~al.' only. e.g.
%
\begin{verbatim}
  \author[Author1 et al.]
         {AUTHOR1...}
\end{verbatim}

The previous examples show an article with one author, the normal
\LaTeX\ conventions have been extended to allow the author names and
their affiliations to be typeset in the correct TLP style. The following
examples should cover most possibilities:

\textit{Case 1.} Two authors with the same affiliation:
%
\begin{verbatim}
  \author[Author1 and Author2]
         {AUTHOR1 and AUTHOR2\\
          Affiliation for both authors}
\end{verbatim}
%
If the author names are too long to fit onto one line, it should be
broken into two or more lines using the \verb"\authorbreak" command.
Don't use \verb"\\" to linebreak the author names -- as this will not do what
you expect.

\textit{Case 2.} Two authors with different affiliations:
%
\begin{verbatim}
  \author[Author1 and Author2]
         {AUTHOR1\\
          Affiliation for Author1
          \and AUTHOR2\\
          Affiliation for Author2}
\end{verbatim}

\textit{Case 3.} Three (or more) authors, two with the same affiliation:
%
\begin{verbatim}
  \author[Author1, Author2 and Author3]
         {AUTHOR1, AUTHOR2\\
            Affiliation for Author1 and Author2
          \and AUTHOR3\\
            Affiliation for Author3}
\end{verbatim}


\subsection{Programming Pearl}

To provide for the Programming Pearl style, \verb"\maketitle" can take 
an optional argument \verb"p" (or \verb"P"). Thus, \verb"\maketitle[p]" will make a
title page, and set up the running headline, for a `Programming Pearl' article.


\subsection{Proofs}

A new environment exists for creating Proofs, e.g.
%
\begin{proof}
  Use $K_\lambda$ and $S_\lambda$ to translate combinators
  into $\lambda$-terms. For the converse, translate
  $\lambda x$ \ldots by [$x$] \ldots and use induction
  and the lemma.
\end{proof}
%
This was produced by the following code:
%
\begin{verbatim}
  \begin{proof}
    Use $K_\lambda$ and $S_\lambda$ to...
  \end{proof}
\end{verbatim}
%
The end of proof marker \proofbox\ is produced automatically. If you wish
to omit this, use the \verb"proof*" environment instead.

If a proof ends with a display equation, then it is customary for the proofbox
to be positioned at the end of equation finishing the proof. \eg
%
\begin{proof*}
  Use $K_\lambda$ and $S_\lambda$ to translate combinators
  into $\lambda$-terms. For the converse, translate
  $\lambda x$ \ldots by [$x$] \ldots and use induction
  and the lemma.
  \[ a_1 \equiv (2\Omega M^2/x) \mathproofbox \]
\end{proof*}
%
Was produced with:
%
\begin{verbatim}
  \begin{proof*}
    Use $K_\lambda$ and $S_\lambda$ to...
    \[ a_1 \equiv (2\Omega M^2/x) \mathproofbox \]
  \end{proof*}
\end{verbatim}
%
Notice the use of \verb"proof*" to turn off the automatic proofbox.

The proof environment will also take an optional argument which allows you
to produce `special' proofs. e.g.
%
\begin{proof}[Proof of Theorem 27]
  We define a linear isometry $A:H\rightarrow H$ by the nonlinear
  Schr\"{o}dinger equation. It would not be hard to modify the
  proof to obtain an analogous result for ellipsoids rather than
  spheres.
\end{proof}
%
Which was produced like this:
%
\begin{verbatim}
  \begin{proof}[Proof of Theorem 27]
    We define a linear isometry...
  \end{proof}
\end{verbatim}
%
Notice that once the optional argument is used, you have to type all of
the text which is to appear as the heading.

\subsection{Programs}\label{sec-programs}

TLP encourages authors to use one of two styles for typesetting programs,
\emph{mathematical} and \emph{verbatim}.

A program typeset in the mathematical style is shown in
figure~\ref{mathfigure}, and the commands used to typeset this program
are shown in figure~\ref{mathtypeset}.  This uses the ordinary
mathematics mode of \LaTeX: displayed programs are surrounded by
\verb|\[| and \verb|\]|, and the \verb|array| command is used for
alignment.  However, there are two important differences.  First, the
\verb|\programmath| command appears before the program text; this
causes math mode to use ordinary spacing for italic identifiers,
rather than math spacing.  The \verb|\unprogrammath| command returns
to normal math spacing.  Second, in math mode spaces are ignored, so a
tilde \verb|~| is used instead.  (In \LaTeX, a tilde generates a
``hard space'' that is never replaced by a line break.)  To include
program text in mathematics style inline, surround it with dollar
\$ signs.  For example, the input
\begin{verbatim}
  See how \programmath $differ~x$
  differs from \unprogrammath $differ x$.
\end{verbatim}
produces the output
\begin{center}
  See how \programmath $differ~x$
  differs from \unprogrammath $differ x$.
\end{center}

A program typeset in the verbatim style is shown in
figure~\ref{verbfigure}, and the commands used to typeset this program
are shown in figure~\ref{verbtypeset}.  This uses the ordinary
verbatim mode of \LaTeX: displayed programs are surrounded by
\verb|\begin{verbatim}| and \verb|\end{verbatim}|, and alignment is
indicated with spaces in the source file (don't use tabs, which may
not be processed properly).  To include program
text in verbatim style inline, use the \verb|\verb| command.
For example, the input
\begin{center}
\begin{verbatim}
  On a terminal, this looks like \verb"differ x".
\end{verbatim}
\end{center}
produces the output
\begin{center}
  On a terminal, this looks like \verb"differ x".
\end{center}

It is recommended that programs in figures be offset from the text
using the \verb|\figrule| command, as shown in figures~\ref{mathfigure}%
--\ref{verbtypeset}.

\begin{figure}
\figrule
\programmath
\[
\begin{array}{lcl}
exp                   & :: & Exp \rightarrow Arr \rightarrow Val \\
exp~(Var~i)~a         & =  & index~i~a \\
exp~(Const~v)~a       & =  & v \\
exp~(Plus~e_1~e_2)~a  & =  & exp~e_1~a+exp~e_2~a \\
\\
com                   & :: & Com \rightarrow Arr \rightarrow Arr \\
com~(Asgn~i~e)~a      & =  & update~i~(exp~e~a)~a \\
com~(Seq~c_1~c_2)~a   & =  & com~c_2~(com~c_1~a) \\
com~(If~e~c_1~c_2)~a  & =  & \textrm{if } exp~e~a \dequals 0 \textrm{ then }
                                      com~c_1~a \textrm{ else } com~c_2~a \\
\\
prog                  & :: & Prog \rightarrow Val\\
prog~(Prog~c~e)       & =  & exp~e~(com~c~(newarray~0))
\end{array}
\]
\unprogrammath
\caption{Example program in mathematical style.}\label{mathfigure}
\figrule
\begin{center}
\begin{verbatim}
\begin{figure}
\figrule
\programmath
\[
\begin{array}{lcl}
exp                   & :: & Exp \rightarrow Arr \rightarrow Val \\
exp~(Var~i)~a         & =  & index~i~a \\
exp~(Const~v)~a       & =  & v \\
exp~(Plus~e_1~e_2)~a  & =  & exp~e_1~a+exp~e_2~a \\
\\
com                   & :: & Com \rightarrow Arr \rightarrow Arr \\
com~(Asgn~i~e)~a      & =  & update~i~(exp~e~a)~a \\
com~(Seq~c_1~c_2)~a   & =  & com~c_2~(com~c_1~a) \\
com~(If~e~c_1~c_2)~a  & =  & \textrm{if } exp~e~a \dequals 0 \textrm{ then }
                                      com~c_1~a \textrm{ else } com~c_2~a \\
\\
prog                  & :: & Prog \rightarrow Val\\
prog~(Prog~c~e)       & =  & exp~e~(com~c~(newarray~0))
\end{array}
\]
\unprogrammath
\caption{Example program in mathematical style.}\label{mathfigure}
\figrule
\end{verbatim}
\end{center}
\caption{Typesetting the example program in mathematical style.}\label{mathtypeset}
\figrule
\end{figure}

\begin{figure}
\figrule
\begin{verbatim}
  exp                 :: Exp -> Arr -> Val
  exp (Var i) a       =  index i a
  exp (Const v) a     =  v
  exp (Plus e1 e2) a  =  exp e1 a + exp e2 a

  com                 :: Com -> Arr -> Arr
  com (Asgn i e) a    =  update i (exp e a) a
  com (Seq c1 c2) a   =  com c2 (com c1 a)
  com (If e c1 c2) a  =  if  exp e a == 0  then  com c1 a  else  com c2 a

  prog                :: Prog -> Val
  prog (Prog c e)     =  exp e (com c (newarray 0))
\end{verbatim}
\caption{Example program in verbatim style.}\label{verbfigure}
\figrule
\begin{tabular}{l}
\verb|\begin{figure}| \\
\verb|\figrule| \\
\verb|\begin{center}| \\
\verb|\begin{verbatim}| \\
\verb|exp                 :: Exp -> Arr -> Val| \\
\verb|exp (Var i) a       =  index i a| \\
\verb|exp (Const v) a     =  v| \\
\verb|exp (Plus e1 e2) a  =  exp e1 a + exp e2 a| \\
\\
\verb|com                 :: Com -> Arr -> Arr| \\
\verb|com (Asgn i e) a    =  update i (exp e a) a| \\
\verb|com (Seq c1 c2) a   =  com c2 (com c1 a)| \\
\verb|com (If e c1 c2) a  =  if  exp e a == 0  then  com c1 a  else  com c2 a| \\
\\
\verb|prog                :: Prog -> Val| \\
\verb|prog (Prog c e)     =  exp e (com c (newarray 0))| \\
\verb|\end{verbatim}| \\
\verb|\end{center}| \\
\verb|\caption{Example program in verbatim style.}\label{verbfigure}| \\
\verb|\figrule| \\
\verb|\end{figure}|
\end{tabular}
\caption{Typesetting the example program in verbatim style.}\label{verbtypeset}
\figrule
\end{figure}

Some new macros have been provided for a few convenient symbols in
math mode.  These are illustrated in table~\ref{newcommands}.
%\ifprodtf\newpage\fi

\begin{table}
\caption{New symbol macros}\label{newcommands}
\programmath
\begin{tabular}{lll}
\hline\hline
Symbol                & Usage                  & Keyed as\\
\hline
\verb"\dplus"         & $abc \dplus xyz$         & \verb"$abc \dplus xyz$"\\
\verb"\dequals"       & $abc \dequals xyz$       & \verb"$abc \dequals xyz$"\\
\verb"\dcolon"        & $abc \dcolon xyz$        & \verb"$abc \dcolon xyz$"\\
\verb"\dcolonequals"  & $abc \dcolonequals xyz$  & \verb"$abc \dcolonequals xyz$"\\
\hline\hline
\end{tabular}
\unprogrammath
\end{table}


\subsection{Lists}

The TLP class provides the three standard list environments.
\begin{itemize}
  \item Numbered lists, created using the \verb"enumerate" environment;
  \item Bulleted lists, created using the \verb"itemize" environment;
  \item Labelled lists, created using the \verb"description" environment.
\end{itemize}
The \verb"enumerate" environment numbers each list item with an arabic numeral;
alternative styles can be achieved by inserting a redefinition of the
number labelling command after the \verb"\begin{enumerate}". For example, a
list numbered with roman numerals inside parentheses can be produced by the
following commands:
%
\begin{verbatim}
  \begin{enumerate}[(iii).]
    \renewcommand{\theenumi}{(\roman{enumi})}
    \item first item
          :
  \end{enumerate}
\end{verbatim}
%
This produces the following list:
%
\begin{enumerate}[(iii).]
  \renewcommand{\theenumi}{(\roman{enumi})}
  \item first item
  \item second item
  \item \etc
\end{enumerate}
%
Notice that an optional argument ``\verb"(iii)."'' has been given to the
\verb"enumerate" environment, specifying the \emph{widest label} used in the
list. This is because roman numerals are wider than the arabic numerals
normally used by \verb"enumerate", and so the labels would otherwise have been
pushed out into the margin.

\section{User-defined macros}

If you define your own macros, you must ensure that their names do not
conflict with any existing macros in \LaTeX\ (or \AMSLaTeX\ %
if you are using this). You should also place them in the preamble of
your input file, between the \verb"\documentclass" (but after any
\verb"\usepackage" commands) and before the \verb"\begin{document}" command.

Apart from scanning the indexes of the relevant manuals, you can check
whether a macro name is already used by using \verb"\newcommand", which
will check for the existence of the macro you are trying to define.
If the macro exists \LaTeX\ will respond with:
%
\begin{verbatim}
  ! LaTeX Error: Command ... already defined.
\end{verbatim}
%
In this case you should choose another name, and try again.

Such macros must be in a place where they can easily be found and
modified by the journal's editors or typesetter. They must be gathered
together in the preamble of your input file, or in a separate
\verb"macros.tex" file with the command \verb"\input{macros}" in the
preamble. Macro definitions must not be scattered about your document
where they are likely to be completely overlooked by the typesetter.

The same applies to font definitions that are based on Computer Modern
fonts. These must be changed by the typesetter to use the journal's
correct typeface. In this case, you should draw
attention to these font definitions on the hard copy that you submit for
publication and by placing a comment in your input file just before the
relevant definitions, for example \verb"% replace font!"

\section{Some guidelines for using standard facilities}

The following notes may help you achieve the best effects with the TLP class file.

\subsection{Sections}

\LaTeX\ provides five levels of section headings and they are all
defined in the TLP class file:
\begin{itemize}
  \item[] Heading A -- \verb"\section{...}"
  \item[] Heading B -- \verb"\subsection{...}"
  \item[] Heading C -- \verb"\subsubsection{...}"
  \item[] Heading D -- \verb"\paragraph{...}"
  \item[] Heading E -- \verb"\subparagraph{...}"
\end{itemize}
Section numbers are given for sections, subsection and subsubsection headings.

\subsection{Figures and tables}

The \texttt{figure} and \texttt{table} environments are implemented as described in
the \LaTeX\ Manual to
provide consecutively numbered floating inserts for illustrations and tables
respectively.
The standard inserts and their captions are formatted centred.
Line breaks in captions can be inserted as required using \verb"\\".

\subsubsection{Illustrations (or figures)}

The TLP class will cope with most positioning of your illustrations
and you should not normally use the optional positional qualifiers on
the \verb"figure" environment which would override these decisions.
Figure captions should be below the figure itself, therefore the
\verb"\caption" command should appear after the figure or space left
for an illustration.

Figures in TLP will frequently illustrate programs, as shown in
section~\ref{sec-programs} of this guide. Figure~\ref{sample-figure}
shows an example of space left above a caption for artwork to be pasted in.
This was produced with the following commands:
%
\begin{verbatim}
  \begin{figure}
    \vspace{5cm} % the vertical depth of the artwork
    \caption{An example figure with space for artwork.}
    \label{sample-figure}
  \end{figure}
\end{verbatim}
%
\begin{figure}
  \vspace{5cm} % the vertical depth of the artwork
  \caption{An example figure with space for artwork.}
  \label{sample-figure}
\end{figure}
%
The vertical depth should correspond roughly to the artwork you will submit;
it will be adjusted to fit the final artwork exactly.

If your illustration extends over two~pages, you can use the
\verb"\continuedfigure" facility. To use this, you key the figure
caption for the second figure as follows:
%
\begin{verbatim}
  \begin{figure}
    \continuedfigure
    \vspace{80pt}
    \caption{First figure, continued.}
    \label{continued}
  \end{figure}
\end{verbatim}
%
This ensures that the figure counter does not get incremented, and at the
same time adds the word (cont.) to the caption. You may still use labels
and references for this figure.

\subsubsection{Tables}

The TLP class file will cope with most positioning of your tables
and you should not normally use the optional positional qualifiers on the
\verb"table" environment which would override these decisions.
Normal journal style sets the table caption first, followed by a double
rule, the table body and a double rule at the bottom. Single rules and
spanner rules (\verb"\cline") can be used to separate headings from the
columns. For example, table~\ref{sample-table} is produced using the
following commands:\par
%
{\small
\begin{verbatim}
\begin{table}
  \caption{Results of Overloading for 3 Experimental Setups}
  \label{sample-table}
  \begin{minipage}{\textwidth}
    \begin{tabular}{lcrrrrr}
      \hline\hline
      Program& Expt.&
      CPU\footnote{Seconds of elapsed time on an unloaded Sun 3/50.}&
      RelCPU\footnote{CPU Time relative to experiment (a).}& GC&
      Mem\footnote{Bytes of heap used over the duration of the program.}&
      RelMem\footnote{Memory usage relative to experient (a).}\\
      \hline
      8 Queens& (a)&   2.88&  1.00&    6&   1.7M&  1.00\\
      &         (b)&  32.51& 11.29&  193&  48.9M& 28.76\\
      &         (c)&   7.90&  2.74&   42&  11.3M&  6.65\\
      \noalign{\vspace {.5cm}}
      Primes&   (a)&   4.89&  1.00&   19&   5.3M&  1.00\\
      &         (b)&  47.54&  9.72&  204&  54.5M& 10.28\\
      &         (c)&  10.08&  2.06&   47&  13.0M&  2.45\\
      \noalign{\vspace {.5cm}}
      Nfib&     (a)&  21.65&  1.00&  161&  40.4M&  1.00\\
      &         (b)& 221.65& 10.24& 1382& 349.0M&  8.64\\
      &         (c)&  21.30&  0.98&  161&  42.0M&  1.03\\
      \noalign{\vspace {.5cm}}
      KWIC&     (a)&   7.07&  1.00&   15&   6.3M&  1.00\\
      &         (b)&  34.55&  4.89&  109&  47.8M&  7.59\\
      &         (c)&  31.62&  4.47&   53&  45.0M&  7.14\\
      \hline\hline
    \end{tabular}
    \vspace{-2\baselineskip}
  \end{minipage}
\end{table}
\end{verbatim}}
%
\begin{table}
  \caption{Results of Overloading for 3 Experimental Setups}
  \label{sample-table}
  \begin{minipage}{\textwidth}
    \begin{tabular}{lcrrrrr}
      \hline\hline
      Program& Expt.&
      CPU\footnote{Seconds of elapsed time on an unloaded Sun 3/50.}&
      RelCPU\footnote{CPU Time relative to experiment (a).}& GC&
      Mem\footnote{Bytes of heap used over the duration of the program.}&
      RelMem\footnote{Memory usage relative to experient (a).}\\
      \hline
      8 Queens& (a)&   2.88&  1.00&    6&   1.7M&  1.00\\
      &         (b)&  32.51& 11.29&  193&  48.9M& 28.76\\
      &         (c)&   7.90&  2.74&   42&  11.3M&  6.65\\
      \noalign{\vspace {.5cm}}
      Primes&   (a)&   4.89&  1.00&   19&   5.3M&  1.00\\
      &         (b)&  47.54&  9.72&  204&  54.5M& 10.28\\
      &         (c)&  10.08&  2.06&   47&  13.0M&  2.45\\
      \noalign{\vspace {.5cm}}
      Nfib&     (a)&  21.65&  1.00&  161&  40.4M&  1.00\\
      &         (b)& 221.65& 10.24& 1382& 349.0M&  8.64\\
      &         (c)&  21.30&  0.98&  161&  42.0M&  1.03\\
      \noalign{\vspace {.5cm}}
      KWIC&     (a)&   7.07&  1.00&   15&   6.3M&  1.00\\
      &         (b)&  34.55&  4.89&  109&  47.8M&  7.59\\
      &         (c)&  31.62&  4.47&   53&  45.0M&  7.14\\
      \hline\hline
    \end{tabular}
    \vspace{-2\baselineskip}
  \end{minipage}
\end{table}

Notice the use of the `\verb"\vspace{-2\baselineskip}"' command to remove the
unwanted vertical space from above the table footnotes in this example.

Captions for `continued' tables can be generated (in the same way as for figures)
using the \verb"\continuedtable" command. These should be positioned just before
the \verb"\caption" command in the appropriate table environment.

The \verb"tabular" environment should be used to produce ruled tables
that require no positioning (contrary to the \verb"table" environment);
it has been modified for the TLP class in the following ways:
\begin{enumerate}
  \item Additional vertical space is inserted above and below a horizontal rule
        (produced by \verb"\hline");
  \item Tables are centred, and span the full width of the page; that is,
  they are similar to the tables that would be produced by
  \verb"\begin{minipage}{\textwidth}".
\end{enumerate}
Because of this reformatting, vertical rules should not be used;
furthermore, commands to
redefine quantities such as \verb"\arraystretch" should be omitted. If
the old tabular facilities are needed, there is a new environment,
\verb"oldtabular", which has none of the reformatting; it should be used
in exactly the same way.

\subsection{Appendices}

You should use the standard \LaTeX\ \verb"\appendix" command to place any
Appendices, normally, just before any references.
From that point on \verb"\section" will produce an appendix, which are
numbered A, B etc., equations as (A1), (B1) etc.\ Figures and
tables also number A\,1, B\,1 etc.

\subsection{References}\label{acmtrans}

As with standard \LaTeX, there are two ways of producing a list of references;
either by using Bib\TeX\ with the ACM bibliography style \verb"acmtrans.bst",
(download from http://www.acm.org/tocl/latex/), or by compiling a list of 
references by hand (using a \verb"thebibliography" environment).

\subsubsection{Using Bib\TeX}

If you have Bib\TeX\ installed on your system, the following is a brief description
on how to automatically generate a bibliography (\verb".bbl" file) for your
article. Your article should contain at least the following elements:\par
\vspace{6pt}\noindent
%
\verb"  % sample.tex"\\[2pt]
\verb"  \documentclass{tlp}"\\[2pt]
\verb"  \begin{document}"\\[2pt]
\verb"    \cite{"\textit{citations}\verb"}"\\[2pt]
\verb"  \bibliographystyle{acmtrans}"\\[2pt]
\verb"  \bibliography{"\textit{biblio database files}\verb"}"\\[2pt]
\verb"  \end{document}"\\[4pt]
%
Where `\emph{biblio database files}' may be one or more filenames of bibliographic
database files (without the \verb".bib" extension) separated by commas.
First, \LaTeX\ the file \verb"sample.tex". Second, run Bib\TeX\ by typing:
%
\begin{verbatim}
  bibtex sample
\end{verbatim}
%
This creates the file \verb"sample.bbl". Third, re-\LaTeX\ your
document, and the newly-created \verb"sample.bbl" will be read in
and typeset. You will then need to \LaTeX\ the document once more to resolve any
unresolved citation references.

\subsubsection{Typesetting the references by hand}

The following listing shows some references prepared in the style of the
journal. It was generated from tlp2egui.bib and produces the references at the 
end of this guide.
%
\begin{verbatim}
\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Butcher}{Butcher}{1981}]{Butcher}
  {\sc Butcher, J.} 1981.
  \newblock {\em Copy-editing: The Cambridge Handbook}.
  \newblock Cambridge University Press.

\bibitem[\protect\citeauthoryear{{{C}adence {R}esearch 
  {S}ystems}}{{{C}adence {R}esearch {S}ystems}}{1994}]{crs:chez}
  {\sc {{C}adence {R}esearch {S}ystems}}. 1994.
  \newblock {\it {C}hez} {S}cheme {R}eference {M}anual.

\bibitem[\protect\citeauthoryear{Cameron and Ito}{Cameron and
  Ito}{1984}]{ci:gramps}
  {\sc Cameron, R.~D.} {\sc and} {\sc Ito, M.~R.} 1984.
  \newblock Grammar-based definition of metaprogramming systems.
  \newblock {\em {ACM} Transactions on Programming Languages and 
  Systems\/}~{\em 6,\/}~1 (Jan.), 20--54.

\bibitem[\protect\citeauthoryear{Grossman}{Grossman}{1982}]{Chicago}
  {\sc Grossman, J.}, Ed. 1982.
  \newblock {\em The Chicago Manual of Style}.
  \newblock University of Chicago Press.

\bibitem[\protect\citeauthoryear{Lamport}{Lamport}{1986}]{LaTeX}
  {\sc Lamport, L.} 1986.
  \newblock {\em \LaTeX: A Document Preparation System\/}, 2 ed.
  \newblock Addison-Wesley, New York.

\end{thebibliography}
\end{verbatim}
%
The above list is typeset at the end of this guide.
Each entry takes the form
%
\begin{verbatim}
\bibitem[\protect\citeauthoryear{}{Citeauthor(s)}%
  {Date}]{tag}
  Bibliography entry
\end{verbatim}
%
where
\begin{itemize} 
\item \verb"Citeauthor(s)" are the author names as they are cited in the text;
\item \verb"Date" is the date to be cited in the text; 
\item \verb"tag" is the tag that is to be used as an argument for the \verb"\cite"-type
            commands; 
\item \verb"Bibliography entry" should be the material that is to appear in the bibliography, 
suitably formatted. 
\end{itemize}

\subsubsection{Multiple references}

References should be listed alphabetically by author name(s) and
then by year if the same author has several papers. If some papers by
the same author(s) also fall in the same year, their dates should be
in the form (1993a), (1993b), \etc

Formatting for italic etc.\ should be avoided unless you are sure you
understand the style of references; please concentrate on giving full and
clear information.

\subsubsection{References in the text}

References in the text are given by author and date. Whichever method
is used to produce the bibliography, the references in
the text are done in the same way. Each bibliographical entry has a key,
which is assigned by the author and used to refer to that entry in the
text.

The TLP class file enables you to choose many forms of citation (see table~\ref{citations}). 
There are some repetitions in this table; these are deliberate as authors
tend to have their own preferences. Usage depends on the construction of the sentence -- 
here are some typical examples:
\begin{quote}
  The reader is referred elsewhere \cite{Butcher} for the correctness 
  proofs.\\[-0.5\baselineskip]

  In this paper we limit ourselves to the study of the propositional case that, 
  as shown in \citeN{Butcher}, can be viewed as the target of a possible abstract
  interpretation of a first-order program.\\[-0.5\baselineskip]

  Following the semantic framework of (constraint) logic programming 
  \cite{crs:chez,ci:gramps} we formulate the bottom-up evaluation procedure in two steps.
\end{quote}

\begin{table}
\caption{Citation formats available}\label{citations}
\begin{tabular}{ll}
\hline\hline
LaTeX command              & Output\\
\hline
\verb"\citeN{Butcher}"     & \citeN{Butcher}\\
\verb"\citeNS{Butcher}"    & \citeNS{Butcher}\\
\verb"\cite{Butcher}"      & \cite{Butcher}\\
\verb"\citeNP{Butcher}"    & \citeNP{Butcher}\\
\verb"\citeNPS{Butcher}"   & \citeNPS{Butcher}\\
\verb"\citeS{Butcher}"     & \citeS{Butcher}\\
\verb"\citeA{Butcher}"     & \citeA{Butcher}\\
\verb"\citeANP{Butcher}"   & \citeANP{Butcher}\\
\verb"\citeNN{Butcher}"    & \citeNN{Butcher}\\
\verb"\citeyear{Butcher}"  & \citeyear{Butcher}\\
\verb"\shortcite{Butcher}" & \shortcite{Butcher}\\
\verb"\citeyearNP{Butcher}"     & \citeyearNP{Butcher}\\
\verb"\cite{Butcher,ci:gramps}" & \cite{Butcher,ci:gramps}\\
\hline\hline
\end{tabular}
\end{table}



\appendix

\mbox{}\vfill\eject
\section{Special commands in {\mdseries\texttt{tlp.cls}}}

The following is a summary of the new commands, optional arguments and
environments which have been added to the standard \LaTeX\ user-interface
in creating the TLP class file.\par
\vspace{8pt}

\bcmdtab
\emph{New commands}    & \\[3pt]
\verb"\authorbreak"    & allows a list of authors to be broken in to separate
                         lines without starting an affiliation.\\
\verb"\continuedfigure" & adds the word (cont.) to the next figure caption, and
                          also stops the figure counter from being stepped.\\
\verb"\continuedtable"  & as for \verb"\continuedfigure", except this command
                          achieves the same effect for tables.\\
\verb"\email"          & used to typeset an authors e-mail address (should only be
                         used in the \verb"\author" command).\\
\verb"\proofbox"       & typesets a proof box \proofbox\ (this is normally
                         put in automatically at the end of the \verb"proof"
                         environment). If you need to insert a \verb"\proofbox"
                         manually, you should add a `\verb"\quad"' of
                         space before it in the output.\\
\verb"\removebrackets" & removes the `(\ )' brackets from the optional
                          argument of environments created by the
                          \verb"\newtheorem" command. Should be placed
                          just before the appropriate environment.\\
\ifprodtf
\verb"\removefullpoint" & removes the full point from the next \verb"\caption"
                          command, usually used for figures when they are split
                          from their captions.\\
\fi
\verb"\cite"$\,x$          & see table~\ref{citations}\\
\verb"\mathproofbox"   & as \verb"\proofbox", except this version is intended
                         for use in equations ending proofs (it typesets the
                         proof box using \verb"\rlap" with 1em of extra space).\\[6pt]
\emph{New environments} & \\[3pt]
\ifprodtf
\verb"bottomfigure"     & for split figures and captions (on facing page).\\
\fi
\verb"oldtabular"       & preserves the orginal tabular environment, which
                          has been modified to insert additional space above
                          and below an \verb"\hrule". The body of the environment
                          is centred with rules full out across the text measure.\\
\verb"proof"            & to typeset mathematical proofs, the \verb"*"-form omits
                          the proof box.
\ifprodtf
  \ecmdtab \newpage \bcmdtab
\else \\[6pt]
\fi
\emph{New optional arguments} & \\[3pt]
\verb"[<short title>]"  & in the \verb"\title" command: to define a right
                          running headline that is different from the article
                          title. The \verb"\shorttitle" command also
                          achieves the same effect.
\ifprodtf \\ \else
  \ecmdtab \newpage \bcmdtab
  \emph{New optional arg. (cont.)} & \\[3pt]
\fi
\verb"[<short author>]" & in the \verb"\author" command: to define a left
                          running headline that is different from the
                          authors' names as typeset at the article opening.
                          The \verb"\shortauthor" command also
                          achieves the same effect.\\
\verb"[<pearl style>]" %& -- optional argument \verb"p" to the \verb"\maketitle" command
                          %which allows `Programming Pearls' to be typeset.\\
                        & optional argument \verb"p" (or \verb"P") to the \verb"\maketitle" command
                          which allows `Programming Pearl' to be typeset.\\
\verb"[<widest label>]" & in \verb"\begin{enumerate}": to ensure the correct
                          alignment of numbered lists.
\ecmdtab

\ifprodtf
%
\section{Notes for editors}

This appendix contains additional information which may be useful to
those who are involved with the final production stages of an article.
Authors, who are generally not typesetting the final pages in the
journal's typeface (Monotype Times), do not need this information.

\subsection{Setting the production typeface}

The global \verb"\documentclass" option `\verb"prodtf"' sets up
\verb"tlp.cls" to typeset in the production typeface -- Monotype Times.
e.g.
%
\begin{verbatim}
  \documentclass[prodtf]{tlp}
\end{verbatim}

\subsection{Catchline commands}

To be placed in the preamble:
\begin{itemize}
  \item \verb"\jdate{March 2003}"
  \item \verb"\pagerange{35--48}"
  \item \verb"\pubyear{2003}"
  \item \verb"\volume{\textbf{8} (1):}"
  \item \verb"\doi{S1471068401001193}"
  \item \verb"\submitted{1 January 2003}"
  \item \verb"\revised{1 January 2003}"
  \item \verb"\accepted{1 January 2003}"
\end{itemize}
Note that the latter three will default to `1 January 2003'.

\subsection{Landscape material}

The add on package \verb"TLPland" provides macros for landscape figures and
tables. See the \verb"TLPland" guide for further information.

\subsection{Figures with split artwork/captions}

When a figure is too large to fit on a page with its caption, you can use
the following procedure to place the figure, and then its caption at the foot
of the facing page. First set the figure with a short caption
using the normal \verb"figure" environment, e.g.
\begin{verbatim}
  \begin{figure}
    ...
    \caption{For caption see facing page.}
  \end{figure}
\end{verbatim}
Then set the correct (long) caption, so that it appears on the facing page:
\begin{verbatim}
  \begin{bottomfigure}
    \addtocounter{figure}{-1}
    \caption{This is the long caption...}
  \end{bottomfigure}
\end{verbatim}
If the figure falls on a recto, you may have to move the \verb"bottomfigure"
environment to before the \verb"figure" environment. In this case you need to
move the \verb"\addtocounter" command into the \verb"figure" environment
instead.

The \verb"bottomfigure" environment places a full measure rule above the
bottom-caption automatically.

\subsection{Editing citations (when the author has used the
 {\mdseries\textup{\texttt{cite}}} command)}

In the past when an automatic \verb"\cite" command produced text in the output
which needed to be changed, the argument (in [ ]) from the bibliography entry
was copied to the location of the \verb"\cite" command and then modified.
The \verb"\cite" command would then be removed as part of this process.

In the near future, we will probably have to supply \TeX\ output which will
need to contain `PDF marks' for interactive browsing.  Clearly by removing
the automatic link to the bibliographic entry (referenced by the \verb"\cite"),
we are making extra work for ourselves later on.

To avoid this, the function of the \verb"\cite" command's optional argument
has been changed. For example, the \verb"\cite" command for the
`\verb"ci:gramps"' entry gives:
\[ \hbox{\cite{ci:gramps}} \]
but you want the following to appear in the text:
\[ \hbox{(\citeNP{ci:gramps} -- see p.~22)} \]
you would then use:
\[ \hbox{\verb"(\citeNP{ci:gramps} -- see p.~22)"} \]
to obtain the desired result. Notice that you have to supply
the round brackets as well in the optional argument.

\section{Macros provided by {\mdseries\texttt{TLP2esym.sty}}}

\subsection{Automatic font/character changes}

\begin{itemize}\itemsep=6pt
\item The \verb|\le|, \verb|\leq|, \verb|\ge|, \verb|\geq| commands
use the equivalent AMS slanted symbols:
\[
\oldle \oldleq \oldge \oldgeq
 \lra
\le \leq \ge \geq
\]
The normal characters can be obtained by using the \verb|\old| form
(\eg \verb|\oldge|).
\end{itemize}

\subsection{Additional fonts}

\begin{itemize}\itemsep=6pt
\item The complete (v1) AMS symbols are available using the normal names:
\[
\hbox{\verb"\boxdot \boxplus \boxtimes"} \lra
  \boxdot \boxplus \boxtimes
\]

\item Blackboard bold:
\[
\hbox{\verb"$\mathbb{ABC}$"} \lra \mathbb{ABC}
\]

\item Fraktur/Gothic (bold math version available):
\[
   \hbox{\verb"$\mathfrak{ABC}$"} \lra \mathfrak{ABC}
\]

\item Bold math italic/symbols are provided by the \verb"\boldsymbol" macro
(from the \verb"amsbsy" package). The \verb"\bmath" macro is provided as
an alias.

\strut\hspace*{11pt}The \verb"TLP2esym" package also defines most of the
symbols from Appendix F of the \TeX book. These can be obtained by using
their normal (unbold) symbol name prefixed with a `b'. \eg \verb|\nabla|
becomes \verb|\bnabla|. The only exception to this rule is \verb|\eta|,
which whould lead to a clash with \verb|\beta|. In this case use
\verb|\boldeta| for bold eta.

\strut\hspace*{11pt}The problem with space disappearing around certain
bold math symbols (\verb"\bcdot") does not happen, when using the
\verb"amsbsy" package.

\item Sans serif symbols\\[6pt]
%
\verb"  \textsf{text}  " \lra \textsf{text}
  \qquad \verb"\mathsf{math}  " \lra $\mathsf{math}$\\
\verb"  \textsfi{text} " \lra \textsfi{text}
  \qquad \verb"\mathsfi{math} " \lra $\mathsfi{math}$\\
\verb"  \textsfb{text} " \lra \textsfb{text}
  \qquad \verb"\mathsfb{math} " \lra $\mathsfb{math}$\\
\verb"  \textsfbi{text}" \lra \textsfbi{text}
  \qquad \verb"\mathsfbi{math}" \lra $\mathsfbi{math}$
\end{itemize}

\subsection{Additional symbols}

\verb"  \colonequal   " \rch \colonequal \qquad \verb"\equalcolon     " \rch \equalcolon\\
\verb"  \colonequiv   " \rch \colonequiv \qquad \verb"\equivcolon     " \rch \equivcolon
%
\fi

\bibliographystyle{acmtrans}
\bibliography{tlp2egui}

\label{lastpage}
\end{document}

% end of TLP2egui.tex
\end{filecontents*}

\begin{filecontents*}{tlp2egui.bib}
% -*- Text -*-

@string{icse = "{International Conference on Software Engineering}"}
@string{popl = "{ACM} Conference Principles of Programming Languages"}
@string{lfp = "{ACM} Symposium on {L}isp and {F}unctional {P}rogramming"}
@string{lasc = "{Lisp and Symbolic Computation}"}
@string{pldi = "{ACM} {SIGPLAN} Conference on {P}rogramming {L}anguage {D}esign and {I}mplementation"}
@string{icfp = "{ACM SIGPLAN International Conference on Functional Programming}"}
@string{toplas = "{ACM} Transactions on Programming Languages and Systems"}
@string{cacm = "{Communications of the ACM}"}
@string{icalp = "{International Conference on Automata, Languages and Programming}"}
@string{tcs = "{Theoretical Computer Science}"}
@string{sas = "{Static Analysis Symposium}"}
@string{esop = "{European Symposium on Programming}"}
@string{lncs = "{Lecture Notes in Computer Science}"}
@string{tr = "Technical Report"}
@string{rice = "Rice University"}
@string{tools = "{Technology of Object-Oriented Languages and Systems}"}
@string{manuscript = "Unpublished manuscript"}
@string{dsl = "{USENIX} Conference on Domain-Specific Languages"}
@string{ecoop = "{European Conference on Object-Oriented Programming}"}
@string{tose = "{IEEE Transactions on Software Engineering}"}
@string{ieee-software = "{IEEE Software}"}
@string{gcse = "{International Symposium on Generative and Component-Based Software Engineering}"}
@string{jfp = "{Journal of Functional Programming}"}
@string{scp = "Science of {C}omputer {P}rogramming"}

@book{LaTeX,
  author="L.~Lamport",
  title="\LaTeX: A Document Preparation System",
  publisher="Addison-Wesley, New York",
  year="1986",
  edition="2"}

@book{Butcher,
  author="J.~Butcher",
  title="Copy-editing: The Cambridge Handbook",
  publisher="Cambridge University Press",
  year="1981"}

@book{Chicago,
  editor = {J.~Grossman},
  title="The Chicago Manual of Style",
  publisher="University of Chicago Press",
  year="1982"}

@techreport{admt:profiling,
  author="Andrew W.~Appel and Bruce F.~Duba and David B.~Mac{Q}ueen
    and Andrew P.~Tolmach",
  title="Profiling in the Presence of Optimization and Garbage
    Collection",
  institution="{P}rinceton {U}niversity",
  year="1988",
  type="Technical Report",
  number="CS-TR-197-88",
  month=nov}

@inproceedings{br:synclo,
  author="Alan Bawden and Jonathan Rees",
  title="Syntactic Closures",
  booktitle=lfp,
  year="1988",
  pages="86--95"}

@manual{gb:donkey,
  title="{D}onkey Reference Manual",
  author="Gann Bierner",
  organization="{R}ice {U}niversity"}

@inproceedings{fb:syntox,
  author="Fran{\c c}ois Bourdoncle",
  title="Abstract Debugging of Higher-Order Imperative Languages",
  booktitle=pldi,
  year="1993",
  pages="46--55"}

@booklet{crs:chez,
  title="{\it {C}hez} {S}cheme {R}eference {M}anual",
  author="{{C}adence {R}esearch {S}ystems}",
  year="1994"}

@article{ci:gramps,
  author="Robert D.~Cameron and M.~Robert Ito",
  title="Grammar-Based Definition of Metaprogramming Systems",
  journal=toplas,
  year="1984",
  volume="6",
  number="1",
  pages="20--54",
  month=jan}

@techreport{cma:extensible,
  author="Luca Cardelli and Florian Matthes and Mart\'{\i}n Abadi",
  title="Extensible Syntax with Lexical Scoping",
  institution="Digital SRC",
  year="1994",
  type="Research Report",
  number="121"}

@unpublished{cp:domain-theory,
  title="Domain Theory: An Introduction",
  author="Robert Cartwright and Rebecca Parsons",
  note=manuscript,
  month=jan,
  year="1994"}

@article{hc:adaptable-grammars,
  author="Henning Christiansen",
  title="A Survey of Adaptable Grammars",
  journal="{SIGPLAN Notices}",
  year="1990",
  volume="25",
  number="11",
  pages="35--44",
  month=nov}

@article{cr:r4rs,
  author="William Clinger and Jonathan Rees",
  title="The Revised${}^4$ Report on the Algorithmic Language
    {S}cheme",
  journal="{ACM} {L}isp Pointers",
  year="1991",
  volume="4",
  number="3",
  month="July"}

@inproceedings{cr:mtw,
  author="William Clinger and Jonathan Rees",
  title="Macros That Work",
  booktitle=popl,
  year="1991",
  pages="155--162"}

@book{dp:lattices-and-order,
  title="Introduction to Lattices and Order",
  author="B.~A.~Davey and H.~A.~Priestley",
  publisher="Cambridge",
  year="1990"}

@book{rkd:spl,
  author="R.~Kent Dybvig",
  title="The {S}cheme Programming Language",
  publisher="{P}rentice-{H}all",
  year="1987",
  edition="1"}

@article{dfh:eps,
  author="R.~Kent Dybvig and Daniel P.~Friedman and Christopher
    T.~Haynes",
  title="Expansion-Passing Style: A General Macro Mechanism",
  journal=lasc,
  year="1988",
  volume="1",
  number="1",
  pages="53--75",
  month=jan}

@article{dhb:sc,
  author="R.~Kent Dybvig and Robert Hieb and Carl Bruggeman",
  title="Syntactic abstraction in {S}cheme",
  journal=lasc,
  year="1993",
  volume="5",
  number="4",
  pages="295--326",
  month=dec}

@article{je:cfl-parse,
  author="Jay Earley",
  title="An Efficient Context-Free Parsing Algorithm",
  journal=cacm,
  year="1970",
  volume="13",
  number="2",
  pages="94--102",
  month=feb}

@techreport{me:bochser,
  author="Michael Eisenberg",
  title="Bochser: an Integrated {S}cheme Programming System",
  institution="{MIT}",
  year="1985",
  type="Technical Report",
  number="349",
  month=oct}

@article{mf:expressive,
  author="Matthias Felleisen",
  title="On the Expressive Power of Programming Languages",
  journal=scp,
  year="1991",
  volume="17",
  pages="35--75"}

@inproceedings{jf:rewrite,
  author="John Field",
  title="A Simple Rewriting Semantics for Realistic Imperative
    Programs and its Application to Program Analysis",
  booktitle="Workshop on Partial Evaluation and Semantics-Based
    Program Transformation",
  year="1992",
  pages="98--107"}

@inproceedings{ffkwf:mrspidey,
  author="Cormac Flanagan and Matthew Flatt and Shriram Krishnamurthi
    and Stephanie Weirich and Matthias Felleisen",
  title="Catching Bugs in the Web of Program Invariants",
  booktitle=pldi,
  year="1996",
  pages="23--32",
  month=may}

@techreport{mf:mzscheme,
  title="{PLT} {M}z{S}cheme: Language Manual",
  author="Matthew Flatt",
  organization="{R}ice {U}niversity",
  number="TR97-280",
  type=tr,
  institution=rice,
  year="1997"}

@techreport{ff:mred,
  title="{PLT} {M}r{E}d: Graphical Toolbox Manual",
  author=" Matthew Flatt and Robert Bruce Findler",
  organization="{R}ice {U}niversity",
  year="1997",
  type=tr,
  institution=rice,
  number="TR97-279"}

@book{cg:semantics-book,
  author="Carl A.~Gunter",
  title="Semantics of Programming Languages",
  publisher="{MIT} Press",
  year="1992"}

@inproceedings{hr:prog-depend-graph,
  author="Susan Horowitz and Thomas W.~Reps",
  title="The Use of Program Dependence Graphs in Software Engineering",
  booktitle="Proceedings of the Fourteenth International Conference on Software Engineering",
  year="1992",
  pages="392--411",
  month=may}

@article{hrb:slicing,
  author="Susan Horowitz and Thomas Reps and David Binkley",
  title="Interprocedural Slicing Using Dependence Graphs",
  journal=toplas,
  year="1990",
  volume="12",
  number="1",
  pages="26--60",
  month=jan}

@techreport{scj:yacc,
  author="Steven C.~Johnson",
  title="{YACC}~---~Yet Another Compiler Compiler",
  institution="{AT\&T} {B}ell {L}aboratories",
  year="1975",
  type="{C}omputing {S}cience Technical Report",
  number="32",
  address="Murray Hill, NJ, USA"}

@unpublished{tvj:macros-for-all,
  author="Todd V.~Jonker",
  title="Macros for All Languages",
  note=manuscript,
  year="1989"}

@article{kr:scheme48,
  author="Richard Kelsey and Jonathan Rees",
  title="A Tractable {S}cheme Implementation",
  journal=lasc,
  year="1994",
  volume="5",
  number="4",
  pages="315--335"}

@inproceedings{kmt:parascope,
  author="Ken Kennedy and Kathryn S.~M\raisebox{.2em}{c}Kinley and
    C.-W.~Tseng",
  title="Analysis and Transformation in the {ParaScope Editor}",
  booktitle="Proceedings of the 1991 ACM International Conference
    on Supercomputing",
  month=jun,
  year="1991"}

@book{kr:c,
  author="Brian W.~Kernighan and Dennis M.~Ritchie",
  title="The {C} Programming Language",
  publisher="Prentice Hall",
  year="1988"}

@inproceedings{khc:monitor,
  author="Amir Kishon and Paul Hudak and Charles Consel",
  title="Monitoring Semantics: a Formal Framework for Specifying,
    Implementing and Reasoning About Execution Monitors",
  booktitle=pldi,
  year="1991",
  pages="338--352",
  month=jun}

@article{dek:attribute-grammars,
  author="Donald E.~Knuth",
  title="Semantics of Context-Free Languages",
  journal="Mathematical Systems Theory",
  year="1968",
  volume="2",
  number="2",
  pages="127--145"}

@phdthesis{ek:thesis,
  author="Eugene E.~Kohlbecker",
  title="Syntactic Extensions in the Programming Language {L}isp",
  school="{I}ndiana {U}niversity",
  year="1986",
  month=aug}

@inproceedings{kffd:hygiene,
  author="Eugene E.~Kohlbecker and Daniel P.~Friedman and Matthias
    Felleisen and Bruce F.~Duba",
  title="Hygienic Macro Expansion",
  booktitle=lfp,
  year="1986",
  pages="151--161"}

@inproceedings{kw:mbe,
  author="Eugene E.~Kohlbecker and Mitchell Wand",
  title="Macros-by-Example: Deriving Syntactic Transformations from
    their Specifications",
  booktitle=popl,
  year="1987",
  pages="77--84"}

@techreport{sk:zodiac,
  title="Zodiac: A Framework for Building Interactive Programming Tools",
  author="Shriram Krishnamurthi",
  organization="{R}ice {U}niversity",
  year="1996",
  type=tr,
  institution=rice,
  number="TR96-262"}

@book{pl:rcg,
  author="Peter Lee",
  title="Realistic Compiler Generation",
  publisher="{MIT} Press",
  year="1989"}

@techreport{mel:lex,
  author="Michael E.~Lesk",
  title="{Lex}~---~A Lexical Analyzer Generator",
  institution="{AT\&T} {B}ell {L}aboratories",
  year="1975",
  type="{C}omputing {S}cience Technical Report",
  number="39",
  address="Murray Hill, NJ, USA"}

@inproceedings{mr:ml-parsers,
  author="Michel Mauny and Daniel de Rauglaudre",
  title="Parsers in {ML}",
  booktitle=lfp,
  year="1992",
  pages="76--85"}

@techreport{pm:sis,
  author="Peter Mosses",
  title="{SIS}~---~{S}emantics {I}mplementation {S}ystem",
  institution="Computer Science Department, {A}arhus {U}niversity",
  type="Technical Report",
  number="{DAIMI} {MD}-30",
  year="1979",
  address="{\AA}rhus, {D}enmark"}

@phdthesis{lp:compiler-generator,
  author="Lawrence Paulson",
  title="A Compiler Generator for Semantic Grammars",
  school="{S}tanford {U}niversity",
  year="1981"}

@article{gdp:lcf-as-pl,
  author="Gordon D.~Plotkin",
  title="{LCF} Considered as a Programming Language",
  journal=tcs,
  year="1977",
  pages="223--255"}

@book{rt:sg,
  author="Thomas W.~Reps and Tim Teitelbaum",
  title="The Synthesizer Generator",
  publisher="Springer-Verlag",
  year="1989"}

@inproceedings{sc:scannerless-nslr1,
  author="Daniel J.~Salomon and Gordon V.~Cormack",
  title="Scannerless {NSLR}(1) Parsing of Programming Languages",
  booktitle=pldi,
  year="1989",
  pages="170--178"}

@techreport{ss:cfg-parse,
  author="Sriram Sankar",
  title="An Efficient Top-Down Parsing Algorithm for General
    Context-Free Grammars",
  institution="{S}tanford {U}niversity",
  year="1993",
  type="Technical Report",
  number="CSL-TR-93-562",
  month=feb}

@phdthesis{wls:thesis,
  author="William L.~Scherlis",
  title="Expression Procedures and Program Derivation",
  school="{S}tanford {U}niversity",
  year="1980"}

@inproceedings{sp:profiling,
  author="Paul Sansom and Simon {Peyton Jones}",
  title="Time and Space Profiling for Non-Strict, Higher-Order
    Functional Languages",
  booktitle=popl,
  year="1995",
  pages="355--366",
  month=jan}

@inproceedings{dss:domains-denot-sem,
  author="Dana S.~Scott",
  title="Domains for Denotational Semantics",
  booktitle=icalp,
  year="1982"}

@book{mt:compiler-generator,
  author="Mads Tofte",
  title="Compiler Generators",
  publisher="Springer-Verlag",
  year="1990"}

@article{tl:evaltrace,
  author="David Touretzky and Peter Lee",
  title="Visualizing Evaluation in Applicative Languages",
  journal=cacm,
  year="1992",
  volume="35",
  number="10",
  month=oct}

@article{mw:deriv,
  author="Mitchell Wand",
  title="Deriving Target Code as a Representation of Continuation
    Semantics",
  journal=toplas,
  year="1991",
  volume="4",
  pages="496--517"}

@inproceedings{wc:c-macros,
  author="Daniel Weise and Roger Crew",
  title="Programmable Syntax Macros",
  booktitle=pldi,
  year="1993",
  pages="156--165",
  month=jun}

@techreport{dsw:popart,
  author="David S.~Wile",
  title="{POPART}: Producer of Parsers and Related Tools",
  institution="{U}niversity of {S}outhern {C}alifornia",
  year="1981",
  type="Technical Report",
  month=oct}  

@inproceedings{wc:soft,
  author="Andrew K.~Wright and Robert Cartwright",
  title="A Practical Soft Type System for {S}cheme",
  booktitle=lfp,
  year="1994",
  month=jun}

%% Robby additions from here

@inproceedings{ff:componential,
  author = "Cormac Flanagan and Matthias Felleisen",
  title = "Componential Set-Based Analysis",
  booktitle = pldi,
  year = 1997}

@techreport{ff:sba,
  author = "Cormac Flanagan and Matthias Felleisen",
  title = "Modular and Polymorphic Set-Based Analysis: Theory and Practice",
  year = 1996,
  type = tr, 
  number = "{TR-96-266}",
  institution = rice}

@manual{mit-scheme,
 title="{MIT Scheme Reference}",
 author="Chris Hanson and {The MIT Scheme Team} and {A Cast of Thousands}",
 year="1993"}

@manual{manual:microsoft-dev-studio,
  title="{M}icrosoft {D}eveloper {S}tudio",
  organization="{M}icrosoft", 
  key="{M}icrosoft", 
  year=1995}

@manual{manual:borland-c++,
  title="{B}orland {C++Builder} 5 Developer's Guide",
  year="1983, 2000",
  organization="{INPRISE} Corporation, Inc.",
  key="Borland"}
  
@manual{manual:code-warrior,
  title="{C}ode{W}arrior",
  organization="Metrowerks",
  key="Metrowerks",
  year="1993--1996"}

@manual{manual:mlworks,
  title="{MLW}orks",
  key="Harlequin Inc.",
  organization="Harlequin Inc.",
  year="1996"}

@manual{manual:smlnj,
  title="{S}tandard {ML} of {N}ew {J}ersey",
  organization="{AT\&T} {B}ell {L}abratories",
  key="{AT\&T} {B}ell {L}abratories",
  year="1993"}

@manual{manual:ocaml,
  title="The {O}bjective {C}aml system, {D}ocumentation and {U}ser's guide",
  author="Xavier Leroy",
  year="1997",
  url="http://pauillac.inria.fr/caml/"}

@book{mth:sml-definition,
  title="The Definition of Standard {ML}",
  author="Robin Milner and Mads Tofte and Robert Harper",
  publisher="{MIT} Press",
  year="1990"}

@manual{ti:pcscheme,
 title="{PC Scheme User's Guide \& Language Reference Manual---Student
Edition}",
 author="{Texas Instruments}",
 publisher="The Scientific Press, Redwood City, CA",
 year="1988"}

@inproceedings{fh:syntactic-control-state,
  author="Matthias Felleisen and Robert Hieb",
  title="The revised report on the syntactic theories of sequential control
and state",
  booktitle=tcs,
  year = "1992",
  pages="235--271"}

@TechReport{hw:haskell,
  author="Paul Hudak and Philip Wadler",
  title =        "Report on the Programming Language {Haskell}",
  institution =  "Yale University, Department of Computer Science",
  year =         1991,
  month  =       aug,
  number =       "{YALE/DCS/RR777}",
}


@manual{schemers-inc:edscheme,
 title="{E}d{S}cheme: {A} {M}odern {L}isp",
 publisher="{Schemer's Inc.}",
 key="{Schemer's Inc.}",
 year="1991",
 isbn="{0-9628745-8-2}"}

@book{if:schemers-guide,
 title="The schemer's guide",
 author="{Ferguson, I}. and {Martin, E.} and {Kaufman, B.}",
 year=1990,
 publisher="{Schemer's Inc.}"}

@unpublished{url:schemers,
  title="{S}cheme in colleges and high schools",
  author="{Schemer's Inc. and Terry Kaufman}",
  year="2000",
  note="Available on the web.\hfill\break URL: \verb|http://www.schemers.com/schools.html|"}

@article{pw:calculating,
  author="Philip Wadler",
  title="A critique of {A}belson and {S}ussman, or, Why calculating is better
than scheming",
  journal="{SIGPLAN Notices}",
  year="1987",
  volume="22",
  number="3",
  month="March"}

@inproceedings{nh:sba,
 author="Heintze, Nevin",
 title="Set based analysis of {ML} programs",
 booktitle=lfp,
 year=1994}

@inproceedings{mf:lambda-v-cs,
 author="Matthias Felleisen",
 title="An extended $\lambda$-calculus for {S}cheme",
 booktitle=lfp,
 year="1988",
 pages="72--84"}

@book{ass:structure,
 title="Structure and Interpretation of Computer Programs",
 author="Harold Abelson and Gerald Jay Sussman and Julie Sussman",
 publisher="MIT Press",
 year="1985"}

@inproceedings{gr:taming,
 title="Taming the {Y} combinator \ldots",
 author="{Rozas, G.~J.~}",
 year=1992,
 booktitle=lfp,
 pages="226--234"}

@book{jg:gemacs,
 title="The Emacs Screen Editor",
 author="{Gosling, James}",
 publisher="Unipress Software Inc.",
 year="1984"}
@book{rs:gnu,
 title="{GNU Emacs Manual}",
 publisher="Free Software Foundation Inc., 675 Mass. Ave., Cambridge, MA 02139",
 author="Stallman, Richard",
 year="1987"}

@techreport{hlpr:cm,
  title="Incremental Recompilation for {S}tandard {ML} of {N}ew {J}ersey",
  author="Robert Harper and Peter Lee and Frank Pfenning and Eugene
  Rollins",
  year="1994",
  institution="Carnegie Mellon University",
  type="Technical Report",
  number="{CMU-CS-94-116}"}

@unpublished{mb:cm,
 author = "Matthias Blume",
 title = "Standard {ML} of {N}ew {J}ersey Compilation Manager",
 institution = "Princeton University",
 note = "Manual accompanying SML/NJ software",
 year = "1995"}

@article{Koschmann:1988:BGB,
        author = "Timothy Koschmann and Martha Walton Evens",
        title = "Bridging the gap between object-oriented and logic
programming",
        journal = "{IEEE} Software",
        volume = {5},
        pages = {36--42},
        month = "July",
        year = {1988},
        coden = {IESOEG}}

@article{Francez:1985:ELP,
        author = "Nissim Francez and Shalom Goldenberg and Ron Y. Pinter
and Michael Tiomkin and Shalom Tsur",
        title = "An environment for logic programming",
        journal = "{SIGPLAN Notices}",
        volume = {20},
        number = {7},
        pages = "179--190",
        month = "July",
        year = {1985},
        coden = {SINODQ},
        isbn = {0-89791-165-2},
        issn = {0362-1340}}

@article{Komorowski:1985:MIL,
        author = "Henryk Jan Komorowski and Shigeo Omori",
        title = "A model and an implementation of a logic programming environment",
        journal = "{SIGPLAN Notices}",
        volume = {20},
        number = {7},
        pages = {191--198},
        month = "July",
        year = {1985},
        coden = {SINODQ},
        isbn = {0-89791-165-2},
        issn = {0362-1340}}

@article{Lane:1988:TPR,
        author = "A. Lane",
        title = "{Turbo Prolog} revisited",
        journal = {BYTE},
        volume = {13},
        number = {10},
        pages = {209--212},
        month = "October",
        year = {1988},
        coden = {BYTEDJ},
        issn = {0360-5280}}

@techreport{JH:ape,
        author = {J. Hsiang and M. Srivas},
        month = "July",
        year = {1984},
        title = "A {Prolog} environment",
        number = {84-074},
        institution = {State University of New York at Stony Brook},
        address = {Stony Brook, New York}}

@inproceedings{hs:prolog-data-dates,
        author = "J. Hsiang and M. Srivas",
        title = "A {Prolog} environment for developing and reasoning about data types",
        booktitle = "Formal Methods and Software Development ({TAPSOFT} 85)",
        month = {March},
        year = {1985},
        address = {Berlin},
        pages = {276--293},
        series = {lncs},
        volume = {186},
        editor = {H. Ehrig and others},
        publisher = "Springer"}

@unpublished{rbf:mod-abstr-interp,
  author="Robert Bruce Findler",
  title="Modular Abstract Interpreters",
  note="Carnegie Mellon University",
  month=jun,
  year=1995}

@inproceedings{fffkf:drscheme,
        author = "Robert Bruce Findler and Cormac Flanagan and
                  Matthew Flatt and Shriram Krishnamurthi and
		  Matthias Felleisen",
        title = "{DrScheme}: A Pedagogic Programming Environment for Scheme",
        booktitle = "Programming Languages: Implementations, Logics, and Programs",
        month = {September},
        year = {1997},
        address = {Southampton, UK},
        pages = {369--388},
        series = {LNCS},
        volume = {1292},
        editor = {Hugh Glaser and Pieter Hartel and Herbert Kuchen},
        publisher = "Springer"}

@phdthesis{cf:static-debugging,
  author="Cormac Flanagan",
  title="Effective Static Debugging via Componential Set-Based Analysis",
  school="{R}ice {U}niversity",
  year="1997"}

@article{rr:first-course,
  author="Reid, R.~J.",
  title="First-course Language for Computer Science Majors",
  journal="Posting to comp.edu",
  year=1995,
  month="October",
  day=16}

@InProceedings{fkf:mixins-popl,
  author = "Matthew Flatt and Shriram Krishnamurthi and
                  Matthias Felleisen",
  title = "Classes and Mixins",
  booktitle = popl,
  year = "1998",
  month = jan,
  url = "http://www.cs.rice.edu/CS/PLT/Publications/"
}

@inproceedings{ffk:syntactic-control,
 author="Matthias Felleisen and D.P. Friedman and Eugene Kohlbecker
         and Bruce Duba",
 title="A syntactic theory of sequential control",
 booktitle=tcs,
 year=1987,
 pages="205--237"}

@inproceedings{ff:syntactic-state,
 author="Matthias Felleisen and D.P. Friedman",
 title="A syntactic theory of sequential state",
 booktitle=tcs,
 year=1989,
 pages="243--287"}

@techreport{hj:sw-prototyping,
  author="Paul Hudak and Mark P.~Jones",
  title="{H}askell {\it vs}. {A}da {\it vs}. {C}++ {\it vs}. {A}wk {\it
    vs}. \ldots {A}n Experiment in Software Prototyping Productivity",
  institution="{D}epartment of {C}omputer {S}cience, {Y}ale {U}niversity",
  year=1994,
  type="Research Report",
  number="YALEU/DCS/RR-1049",
  address="New Haven, CT, USA",
  month=oct}
  
@InProceedings{ff:units,
  author = "Matthew Flatt and Matthias Felleisen",
  title = "Units: Cool Modules for {HOT} Languages",
  booktitle = pldi,
  month = jun,
  year = "1998",
  pages = "236--248"
}

@InProceedings{ff:units-mixins,
  author = "Robert Bruce Findler and Matthew Flatt",
  title = "Modular Object-Oriented Programming with Units and Mixins",
  booktitle = icfp,
  month = sep,
  year = "1998",
  pages = "94--104"
}


@inproceedings{m:software-components,
  author="M.~D.~McIlroy",
  title="Mass Produced Software Components",
  booktitle="Report on a Conference of the NATO Science Committee",
  year=1968,
  editor="P.~Naur and B.~Randell",
  pages="138--150"
}

@book{s:component-software,
 author = "Clemens Szyperski",
 title = "Component Software",
 publisher = "Addison-Wesley",
 year = 1998
}

@book{m:oo-software-construction,
  author="Bertrand Meyer",
  title="Object-oriented Software Construction",
  publisher="Prentice Hall",
  city="New York",
  year=1988}

@book{m:eiffel,
 author = "Bertrand Meyer",
 title = "Eiffel: The Language",
 publisher = "Prentice Hall",
 year = 1992
}

@book{s:eiffel,
 author = "Robert Switzer",
 title = "Eiffel: An Introduction",
 publisher = "Prentice Hall",
 year = 1993
}

@book{gjs:java,
 author = "James Gosling and Bill Joy and Guy Steele",
 title = "The {J}ava(tm) Language Specification",
 publisher = "Addison-Wesley",
 year = 1996,
 isbn = "0-201-63451-1"
}

@article{r:gedanken,
  author="John Reynolds", 
  title = "GEDANKEN: A Simple Typeless Language Based on the Principle of Completeness and the Reference Concept",
  journal = cacm,
  year="1970",
  volume="13",
  number="2",
  pages="308--319",
  month=may} 
  
@InProceedings{p:five-paradigm-shifts,
  author = "V. Pratt",
  title = "Five Paradigm Shifts in Programming Language Design and Their Realization 
  in Viron, a Dataflow Programming Environment",
  booktitle = popl,
  month = {January},
  year = "1983",
  pages = {1-- 9}}

@unpublished{fff:units,
  author="Matthew Flatt and Robert Bruce Findler and Matthias Felleisen",
  note="Submitted for publication",
  title="Units: Cool Modules for {HOT} Languages"}

@InProceedings{cf:soft,
  author="Robert Cartwright and Mike Fagan",
  title="Soft typing",
  booktitle=pldi,
  year="1991",
  pages={278--292}}

@inproceedings{fkf:classes-mixins,
  author="Matthew Flatt and Shriram Krishnamurthi and Matthias Felleisen",
  title="Classes and Mixins",
  booktitle=popl,
  year=1998,
  pages="171--183",
  month=jan}

@Conference{l:manifest-types,
  author =       "Xavier Leroy",
  title =        "Manifest types, modules, and separate compilation",
  booktitle =    popl,
  year =         "1994",
  month =        jan,
  pages =        "109--122"
}

@Conference{hl:ho-modules,
  author =       "Robert Harper and Mark Lillibridge",
  title =        "A Type-Theoretic Approach to Higher-Order Modules
                  with Sharing",
  booktitle =    popl,
  year =         "1994",
  month =        jan,
  pages =        "123--137"
}

@Conference{l:fully-transparent-ho-modules,
  author =       "Xavier Leroy",
  title =        "Applicative Functions and Fully Transparent
                  Higher-order Modules",
  booktitle =    popl,
  year =         "1995",
  month =        jan,
  pages =        "142--153"
}

@InProceedings{b:ho-functors,
  author =       "Sandip K. Biswas",
  title =        "Higher-order Functors with Transparent Signatures",
  booktitle =    popl,
  month =        jan,
  year =         "1995",
  pages =        "154--163"
}

@InProceedings{mt:ho-functors,
  author =       "David B. MacQueen and Mads Tofte",
  title =        "{A} Semantics for Higher-order Functors",
  year =         "1994",
  url =          "ftp://ftp.research.att.com/dist/ml/papers/94-esop-macqueen.ps",
  month =        apr,
  pages =        "409--423",
  publisher =    "Springer-Verlag",
  series =       lncs,
  colume =       "788",
  booktitle =    esop,
}

@InProceedings{t:ho-modules,
  author = "Mads Tofte",
  title =  "Principal Signatures for Higher-order Program Modules",
  booktitle = popl,
  month = jan,
  year  =  "1992",
  pages = "189--199"
}

@InProceedings{est:recursively-constrained-types,
  key =          "Eifrig, {\em et al.}",
  author =       "Jonathan Eifrig and Scott F. Smith and Valery Trifonov",
  title =        "Type Inference for Recursively Constrained Types and
                 its Application to {OOP}",
  booktitle =    "Mathematical Foundations of Programming Semantics, New
                 Orleans",
  series =       "Electronic Notes in Theoretical Computer Science",
  publisher =    "Elsevier",
  volume =       "1",
  year =         "1995",
  note =         "http://www.elsevier.nl/locate/entcs/volume1.html",
}

@inproceedings{am:static-types-dynamic-language,
  author="Alexander Aiken and Brian R. Murphy",
  title="Static Type Inference in a Dynamically Typed Language",
  booktitle= popl,
  year= "1991",
  pages = "279--290"}

@article{h:dynamic-typing,
 author="Fritz Henglein",
 title="Dynamic Typing: Syntax and Proof Theory",
 journal=scp,
 volume="22",
number="3",
pages="197--230",
year="1994"}

@inproceedings{ts:subtyping-constrained-types,
author="Valery Trifonov and Scott F. Smith",
title="Subtyping Constrained Types",
booktitle=sas,
year="1996",
pages="349--365"}

@Book{ghjv:design-patterns,
  author =       "Erich Gamma and Richard Helm and Ralph Johnson and
                 John Vlissides",
  title =        "Design Patterns: Elements of Reusable Object-Oriented
                 Software",
  publisher =    "Addison Wesley",
  address =      "Massachusetts",
  year =         "1994",
  ISBN =         "0-201-63361-2",
  descriptor =   "Wiederverwendung, Software-Design, Programmieren,
                 Pattern, Objekt-orientiert, Design",
  annote =       "Folgende Themengebiete werden behandelt: - Creational
                 Patterns: Abstract Factory, Builder, Factory Method,
                 Prototype, Singleton. - Structural Patterns: Adapter,
                 Bridge, Composit, Facade, Flyweight, Proxy. -
                 Behavioral Patterns: Chain of Responsibility, Command,
                 Interpreter, Iterator, Mediator, Observer, State,
                 Strategy, Template Method, Visitor. - Struktur,
                 Implementierung und Beispielanwendungen fuer alle
                 Patterns.",
}
@book{gb:ada95,
        author = "John Gilbert Presslie Barnes",
        title = "Programming in {A}da 95",
        publisher = "Addison-Wesley",
        year = 1996
}

@Manual{ada95,
  key =          "Ada",
  title =        "Ada 95 Reference Manual. The Language. The Standard
                 Libraries",
  month =        jan,
  year =         "1995",
  organization = "International Organization for Standardization",
}


@article{hm:essence-of-ml,
  author="Harper, R. and Mitchell, J.C.", 
  Title="On the type structure of {Standard ML}",
  Journal=toplas,
  volume="15",
  Number="2",
  Year="1993",
  pages="211--252",
  Note={Earlier version appears as ``The Essence of {ML}'' in 
        {\it Proc. 15th ACM Symp. on Principles of 
        Programming  Languages,}
        1988, pp. 28--46}}

@article{ps:constrained-type-expressiveness,
 title="Constrained types and their expressiveness",
 author="Jens Palsberg and Scott Smith",
 journal=toplas,
 number="18",
 volume="5",
 pages="519--527",
 month="September",
 year="1996"}

@inproceedings{awk:soft,
 author="Alexander Aiken and Edward L. Wimmers and T. K. Lakshman",
 title="Soft Typing with Conditional Types",
 booktitle= popl,
 year= "1994",
 pages="163--173"}

@inproceedings{kff:synth-fp-oo,
  author="Shriram Krishnamurthi and Matthias Felleisen and Daniel P.~Friedman",
  title="Synthesizing Object-Oriented and Functional Design to Promote Re-Use",
  booktitle=ecoop,
  year=1998,
  month=jul,
  pages="91--113"}

@inproceedings{c:type-systems,
  author="Luca Cardelli",
  editor = "Allen B. Tucker",
  booktitle="The {C}omputer {S}cience and {E}ngineering {H}andbook",
  title="Type Systems",
  isbn="0-8493-2909-4",
  pages="2208--2236",
  publisher="CRC Press",
  year="1997"}

@book{mt:compiler-generator,
  author="Mads Tofte",
  title="Compiler Generators",
  publisher="Springer-Verlag",
  year="1990"}
  

@inproceedings{ac:subtyping-recursive-types,
	title="Subtyping Recursive Types",
	author="Roberto Amadio and Luca Cardelli",
	booktitle=toplas,
	volume=15,
	pages="575--631",
	year=1993}

@book{fffk:how-to-design-programs,
 author = "Matthias Felleisen and Robert Bruce Findler and Matthew Flatt and Shriram Krishnamurthi",
 title = "How to {D}esign {P}rograms",
 publisher = "{MIT} Press",
 year = 2001,
 url = "http://www.htdp.org/"
}


@InProceedings{ffkf:mred,
 author = "Matthew Flatt and Robert Bruce Findler and Shriram Krishnamurthi and
                 Matthias Felleisen",
 title = "Programming Languages as Operating Systems
         ({\em or} Revenge of the Son of the {L}isp Machine)",
 pages = "138--147",
 booktitle = icfp,
 month = sep,
 year = "1999"
}

@article{s:bee,
  author="Manuel Serrano",
  journal=jfp,
  year="2000",
  title="Bee: an Integrated Development Environment for the Scheme
Programming Language"}

@Article{a:contracts,
  author =       "Edward A. Addy",
  title =        "A framework for performing verification and validation
                 in reuse-based software engineering",
  editor =       "William Frakes",
  journal =      "Annals of Software Engineering",
  publisher =    "Baltzer Science Publishers",
  publaddr =     "Bussum, The Netherlands",
  ISSN =         "1022-7091",
  year =         "1998",
  volume =       "5",
  pages =        "279--292",
  abstract =     "Verification and Validation (V\&V) is currently
                 performed during application development for many
                 systems, especially safety-critical and
                 mission-critical systems. The V\&V process is intended
                 to discover errors, especially errors related to
                 critical processing, as early as possible during the
                 development process. The system application provides
                 the context under which the software artifacts are
                 validated. This paper describes a framework that
                 extends V\&V from an individual application system to a
                 product line of systems that are developed within an
                 architecture-based software engineering environment.
                 This framework includes the activities of traditional
                 application-level V\&V, and extends these activities
                 into domain engineering and into the transition between
                 domain engineering and application engineering. The
                 framework includes descriptions of the types of
                 activities to be performed during each of the
                 life-cycle phases, and provides motivation for the
                 activities.",
  note =         "Systematic Software Reuse",
  annote =       "incomplete",
}

@Article{kd:software-quality,
  author =       "John C. Knight and Michael F. Dunn",
  title =        "Software quality through domain-driven certification",
  editor =       "William Frakes",
  journal =      "Annals of Software Engineering",
  publisher =    "Baltzer Science Publishers",
  publaddr =     "Bussum, The Netherlands",
  ISSN =         "1022-7091",
  year =         "1998",
  volume =       "5",
  pages =        "293--315",
  abstract =     "Software reuse is being pursued in an attempt to
		  improve programmer productivity. The concept of reuse
		  is to permit various work products of software
		  development to be used on more than one project in
		  order to amortize their development costs. Productivity
		  is not the only advantage of reuse although it is the
		  most widely publicized. By incorporating reusable
		  components into a new product, the components bring
		  with them whatever qualities they possess, and these
		  can contribute to the quality of the new product. This
		  suggests that reuse might be exploited for achieving
		  quality as an entirely separate goal from improving
		  productivity. If useful properties pertaining to
		  quality could be shown to be present in products as a
		  direct result of software development based on reuse,
		  this might be a cost-effective way of achieving those
		  qualities irrespective of the productivity advantages.
		  The adjective certified is sometimes used to describe
		  components that have been tested in some way prior to
		  entry into a library but the term certified is not
		  formally defined in the reuse literature. In this
		  paper, we address the issue of certifying reusable
		  components. We advocate the development of software by
		  reuse with the specific intent of establishing as many
		  of the required properties in the final product as
		  possible by depending upon properties present in the
		  reusable components. For this goal to succeed, a
		  precise definition of certification of reusable
		  components is required and such a definition is
		  presented. The benefits of the definition and the way
		  in which it supports the goal are explored.",
  note =         "Systematic Software Reuse",
  annote =       "incomplete",
}

@INPROCEEDINGS{hks:class-invariants,
   author = "Kees Huizing and Ruurd Kuiper and SOOP",
   title = "Verification of Object Oriented Programs Using Class Invariants",
   booktitle = "Third International Conference, {FASE} 2000",
   publisher =    "Springer-Verlag, LNCS 1783",
   year = 2000,
   month = mar,
   pages = "208--221"
}

@inproceedings{kfd:macro-to-gen-prog,
  author="Shriram Krishnamurthi and Matthias Felleisen and Bruce
    F.~Duba",
  title="From Macros to Reusable Generative Programming",
  booktitle=gcse,
  year=1999,
  month=sep,
  series=lncs,
  pages="105--120",
  number=1799}


@techreport{k:mcmicmac, 
  author="Shriram Krishnamurthi", 
  title="{PLT} {M}c{M}ic{M}ac: Elaborator Manual", 
  institution="{R}ice {U}niversity", 
  year="1999", 
  number="99-334", 
  address="Houston, TX, USA"} 

@inproceedings{af:interconnecting-objects-via-contracts, 
  title="Interconnecting Objects via Contracts", 
  author="L. Andrade and J. Fiadeiro", 
  booktitle="{UML'99} Beyond the Standard, R.France and B.Rumpe (eds)", 
  series=LNCS,
  number=1723, 
  pages="566--583", 
  publisher="Springer-Verlag",
  year="1999"}

@inproceedings{bhtw:realization-interface-constraints-ocl,
  author="M.Bidoit and R.Hennicker and F.Tort and M.Wirsing",
  title="Correct realization of interface constraints with OCL",
  booktitle="{UML'99} Beyond the Standard, R.France and B.Rumpe (eds)", 
  pages="399--415",
  series=LNCS,
  number=1723, 
  publisher="Springer-Verlag",
  year="1999"}
  
@inproceedings{hdf:ocl-tools,
  author="Heinrich Hussmann and Birgit Demuth and Frank Finger", 
  title="Modular Architecture for a {Toolset} Supporting {OCL}",
  booktitle="Proceedings of the UML 2000 Conference",
  year=2000,
  month=oct}

@inproceedings{b:san-francisco,
  author="Kathy Bohrer",
  title="Architecture of the San Francisco Frameworks",
  booktitle="IBM Systems Journal",
  vol=37,
  number=2,
  pages="156--169",
  year=1998}
  
@techreport{drlns:esc,
  author="David L. Detlefs and K. Rustan and M. Leino and Greg Nelson and James B. Saxe",
  title="Extended Static Checking",
  institution="Compaq SRC Research Report",
  year="1998",
  number="158"}

@inproceedings{cff:stepper,
	author="John Clements and Matthew Flatt and Matthias Felleisen",
	title="Modeling an Algebraic Stepper",
	booktitle=esop,
	year="2001"}

@inproceedings{db:smle,
  author="Dominic Duggan and Frederick Bent",
  title="Explaining type inference",
  booktitle=scp,
  vol=27,
  number=1,
  month=jun,
  year=1996}

@inproceedings{gkhf:web-server,
  author = "Paul Graunke and Shriram Krishnamurthi and Steve Van Der Hoeven 
and Matthias Felleisen",
  title = "Programming the Web with High-Level Programming Languages",
  booktitle = "European Symposium On Programming",
  year = "2001",
  month = "April"}

@article{fcffksf:drscheme,
  author="Robert Bruce Findler and John Clements and
          Cormac Flanagan and Matthew Flatt and
          Shriram Krishnamurthi and Paul Steckler and Matthias Felleisen",
  title="DrScheme: A Programming Environment for {Scheme}",
  journal=jfp,
  year="2001",
  note="to appear"}

@inproceedings{sb:memory-tools,
  title="Understanding Memory Allocation of Scheme programs",
  author="Manuel Serrano and Boehm, Hans J.",
  booktitle=icfp,
  year=2000,
  pages="245--256"}

@inproceedings{ps:jinsight,
  author="De Pauw, Wim and Gary Sevitsky",
  title="Visualizing Reference Patterns for Solving Memory Leaks in {J}ava",
  booktitle=ecoop,
  year=1999,
  pages="116--134"}

@inproceedings{w:type-errors,
  author="Mitch Wand",
  title="Finding the Source of Type Errors",
  booktitle=popl,
  year=1986,
  pages="38--43"}

@inproceedings{p:macros,
  year=1980,
  author="Kent M. Pitman",
  title="Special Forms in Lisp",
  booktitle="Lisp Conference",
  pages="179--187"}

@inproceedings{kef:struct-prop-lang-constr,
  author="Shriram Krishnamurthi and Yan-David Erlich and Matthias
    Felleisen",
  title="Expressing Structural Properties as Language Constructs",
  booktitle=esop,
  year=1999,
  month=mar,
  series=lncs,
  number=1576,
  pages="258--272"}

@article{fkf:mixins,
 author="Matthew Flatt and Shriram Krishnamurthi and Matthias Felleisen",
 title="A Programmer's Reduction Semantics for Classes and Mixins",
 journal="Formal Syntax and Semantics of {J}ava",
 year=1999,
 pages="241--269",
 publisher="Springer-Verlag",
 series=lncs,
 number=1523,
 note="preliminary version appeared in proceedings of {\it Principles of Programming Languages}, 1998",
 url = "http://www.cs.rice.edu/CS/PLT/Publications/"
}

@article{m:theory-of-type-polymorphism,
  author="Milner, R",
  title="A theory of type polymorphism in programming",
  journal="Journal of Computer Systems Science",
  volume=17,
  year=1978,
  pages="348--375"}


@inproceedings{lg:effect-systems,
  title="Polymorphic Effect Systems",
  author="John M. Lucassen and David K. Gifford",
  year=1988,
  booktitle=popl,
  pages="47--57"}

@phdthesis{m:lc-models,
  title="Lambda-Calculus Models of Programming Languages",
  author="Morris, J. H.",
  school="{Massachusetts Institute of Technology}",
  year=1968}
  
@inproceedings{fx:dependent-types,
  title="Dependent types in practical programming",
  author="Hongwei Xi and Frank Pfenning",
  booktitle=popl,
  year=1999,
  pages="214--227"}
\end{filecontents*}

\begin{filecontents*}{tlp2egui.bbl}
\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Butcher}{Butcher}{1981}]{Butcher}
{\sc Butcher, J.} 1981.
\newblock {\em Copy-editing: The Cambridge Handbook}.
\newblock Cambridge University Press.

\bibitem[\protect\citeauthoryear{{{C}adence {R}esearch {S}ystems}}{{{C}adence
  {R}esearch {S}ystems}}{1994}]{crs:chez}
{\sc {{C}adence {R}esearch {S}ystems}}. 1994.
\newblock {\it {C}hez} {S}cheme {R}eference {M}anual.

\bibitem[\protect\citeauthoryear{Cameron and Ito}{Cameron and
  Ito}{1984}]{ci:gramps}
{\sc Cameron, R.~D.} {\sc and} {\sc Ito, M.~R.} 1984.
\newblock Grammar-based definition of metaprogramming systems.
\newblock {\em {ACM} Transactions on Programming Languages and Systems\/}~{\em
  6,\/}~1 (Jan.), 20--54.

\bibitem[\protect\citeauthoryear{Grossman}{Grossman}{1982}]{Chicago}
{\sc Grossman, J.}, Ed. 1982.
\newblock {\em The Chicago Manual of Style}.
\newblock University of Chicago Press.

\bibitem[\protect\citeauthoryear{Lamport}{Lamport}{1986}]{LaTeX}
{\sc Lamport, L.} 1986.
\newblock {\em \LaTeX: A Document Preparation System\/}, 2 ed.
\newblock Addison-Wesley, New York.

\end{thebibliography}
\end{filecontents*}

\begin{filecontents*}{tlp2esam.tex}
% TLP2esam.tex / sample pages for TLP
% v2.11, released 6-nov-2002

\documentclass{tlp}
\usepackage{aopmath}

\newtheorem{definition}{Definition} % [section]
\newtheorem{example}{Example} % [section]
\newcommand{\pivot}[1]{\mathbin{\, {#1} \,}}
\newcommand{\Pivot}[1]{\mathbin{\; {#1} \;}}
\let\from=\leftarrow
\begin{document}
\bibliographystyle{acmtrans}

\long\def\comment#1{}


\title{Two Results for Prioritized Logic Programming}

\author[Y. Zhang]
{YAN ZHANG \\
School of Computing and Information Technology\\
University of Western Sydney\\
Locked Bag 1797, Penrith South DC\\ 
NSW 1797, Australia    \\
E-mail: yan@cit.uws.edu.au
}

\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\volume{\textbf{10} (3):}
\jdate{March 2002}
\setcounter{page}{1}
\pubyear{2002}

\maketitle

\label{firstpage}

\begin{abstract}
%
Prioritized default reasoning has illustrated its rich expressiveness and
flexibility in knowledge representation and reasoning.
However, many important aspects of 
prioritized default reasoning have yet to be thoroughly explored.
In this paper, we  
investigate two properties of 
prioritized logic programs in the context of answer set semantics.
Specifically, we reveal a close relationship between mutual defeasibility
and uniqueness of the answer set for a prioritized logic program.
We then explore how the splitting technique for 
extended logic programs can be extended to
prioritized logic programs. We prove splitting theorems
that can be used to simplify the evaluation of a prioritized logic program 
under certain conditions.


\end{abstract}
\begin{keywords}
 answer set, prioritized logic programming, splitting
\end{keywords}

\section{Introduction}

Prioritized default reasoning has illustrated its rich expressiveness and
flexibility in knowledge representation, reasoning about action and
rule updates \cite{brewka:plp,g:97,yan:plp}.
Recently, different approaches and
formulations for prioritized default reasoning based on
logic programming and default theories have been proposed
\cite{be:aij,d:plp,g:97,w:plp}. 
However, most of these proposals mainly focus on the semantic development,
while other important
properties are usually not thoroughly explored.

In this paper, we
investigate two specific properties of
prioritized logic programs in the context of answer set semantics.
First, we reveal a close relationship between mutual defeasibility
and uniqueness of the answer set for a prioritized logic program.
Mutual defeasibility can be viewed as a way of characterizing rules in
a logic program, where two rules in the program are mutually defeasible if
triggering one rule may cause a defeat of the other, and {\em vice versa}.
It is quite easy to observe that a logic program does not contain a pair of
mutually defeasible rules if this program is locally stratified. However, the converse
does not hold. We then 
provide a sufficient condition to ensure the uniqueness of the answer set for
a prioritized logic program.
We show that our characteristic condition is weaker than
the traditional local stratification for general logic programs \cite{apt:94}.

Second, we investigate the splitting technique for 
prioritized logic programs. It is well known that
Lifschitz and Turner's Splitting Set Theorem \cite{lt:lp94}
for extended logic programs
may significantly simplify the computation of
answer sets of an extended logic program.
The basic idea of splitting technique 
is that under certain conditions, an extended logic
program can be split into several ``smaller components'' such that
the computation of the answer set of the original 
program is reduced to the computation of the answer set of these smaller 
components. We show that this splitting technique 
is also suitable for computing answer sets of prioritized logic programs.
Furthermore, our splitting theorems for prioritized logic programs
also provide a generalization of Lifschitz and Turner's result. 

The paper is organized as follows. Section 2 develops  
the syntax and semantics of prioritized logic programs. In our formulation,
a prioritized logic program is defined to be an extended logic program associating 
with a strict partial ordering on rules in the program. An answer set semantics 
for prioritized logic programs
is then defined. Several basic properties of prioritized logic programs are
also studied in this section. By introducing the concept of mutual 
defeasibility, section 3 proves a sufficient condition to characterize
the unique answer set for a prioritized logic program.
Section 4 then extends the splitting technique for extended logic programs to
prioritized logic programs.
Finally, section 5 concludes the paper with some remarks.

\section{Prioritized Logic Programs}

To specify prioritized logic programs (PLPs), we first
introduce the extended logic program and its answer set semantics
developed by Gelfond and Lifschitz \cite{gl:logic}.
A language $\cal L$ of extended
logic programs is determined by its object constants, function
constants and predicate constants. {\em Terms} are
built as in the corresponding first order language; {\em atoms}
have the form $P(t_{1},\cdots,t_{n})$, where
$t_{i}$ ($1\leq i\leq n$) is a term and $P$ is a predicate constant of arity $n$;
a {\em literal} is either an atom $P(t_{1},\cdots,t_{n})$ or
a negative atom $\neg P(t_{1},\cdots,t_{n})$.
A {\em rule} is an expression of the form:
\begin{equation}
L_{0}\leftarrow L_{1},\cdots,L_{m}, not L_{m+1},\cdots, not L_{n},
\label{eq2}
\end{equation}
where each $L_{i}$ ($0\leq i\leq n$) is a literal.
$L_{0}$ is called the {\em head} of the rule,
while $\{L_{1},\cdots,L_{m}$, $not L_{m+1},\cdots$,
$not L_{n}\}$ is called the {\em body} of the rule.
Obviously, the body of a
rule could be empty. We also allow the head of a rule to be empty. In 
this case, the rule with an empty head is called {\em constraint}. 
A term, atom, literal, or rule is {\em ground} if no variable
occurs in it.
An {\em extended logic program} $\Pi$ is a collection of rules.
$\Pi$ is {\em ground} if each rule in $\Pi$ is
ground. 

Let $r$ be a ground rule of the form (\ref{eq2}), 
we use $pos(r)$ to denote the set of literals in the body of $r$
without negation as failure
$\{L_{1},\cdots,L_{m}\}$, and $neg(r)$ the set of literals
in the body of $r$ with negation as failure $\{L_{m+1},\cdots,L_{n}\}$. We specify
$body(r)$ to be
$pos(r)\cup neg(r)$. We also use $head(r)$ to denote the head of $r$: $\{L_{0}\}$.
Then we use $lit(r)$ to denote $head(r)\cup body(r)$. By extending these
notations, we use $pos(\Pi)$, $neg(\Pi)$,
$body(\Pi)$, $head(\Pi)$, and $lit(\Pi)$ to denote the unions of
corresponding components of all rules in the ground program $\Pi$, e.g.
$body(\Pi)=\bigcup_{r\in\Pi} body(r)$. If $\Pi$ is a non-ground program,
then notions $pos(\Pi)$, $neg(\Pi)$,
$body(\Pi)$, $head(\Pi)$, and $lit(\Pi)$ are defined based on the ground
instantiation (see below definition) of $\Pi$.


To evaluate an extended logic program, Gelfond and
Lifschitz proposed an answer set semantics for extended logic
programs. 
%For simplicity,
%we treat a rule $r$ in $\Pi$ with variables as
%the set of all ground instances
%of $r$ formed from the set of ground literals of the language of $\Pi$.
%In the rest of paper, we will not explicitly declare this assumption whenever
%there is no ambiguity in our discussion.
Let $\Pi$ be a ground extended logic program not containing {\em not}
and {\em Lit} the set of all ground literals in the language of $\Pi$.
An {\em answer set} of $\Pi$ 
is the smallest subset $S$ of {\em Lit} such that
(i) for any rule $L_{0}\leftarrow L_{1},\cdots,L_{m}$ from
$\Pi$, if $L_{1},\cdots,L_{m}\in S$, then $L_{0}\in S$; and (ii)
if $S$ contains a pair of complementary literals, then
$S=Lit$.
Now let $\Pi$ be a ground arbitrary extended logic program. For any subset $S$
of $Lit$, let $\Pi^{S}$ be the logic program obtained
from $\Pi$ by deleting
(i) each rule that has a formula
{\em not} $L$ in its body with $L\in S$, and
(ii) all formulas of the form {\em not} $L$ in the bodies
of the remaining rules\footnote{We also
call $\Pi^{S}$ the Gelfond-Lifschitz transformation of
$\Pi$ in terms of $S$.}.
We define that $S$ is an {\em answer set} of $\Pi$
iff $S$ is an answer set of $\Pi^{S}$.

For a non-ground extended logic program $\Pi$, we usually view a rule
in $\Pi$ containing variables to be the set of all ground instances of this
rule formed from the set of ground literals in the language. The 
collection of all these ground rules forms the 
{\em ground instantiation} $\Pi'$ of $\Pi$. 
Then a set of ground literals is an answer set of
$\Pi$ if and only if it is an answer set of $\Pi'$.
%
It is easy to see that an
extended logic program may have one, more than one, or
no answer set at all.

A {\em prioritized logic program} (PLP) ${\cal P}$ is a triple
$(\Pi,{\cal N},<)$, where
$\Pi$ is an extended logic program, $\cal N$ is a
naming function
mapping each rule in $\Pi$ to a name, and $<$ is a strict
partial ordering on names.
The partial ordering $<$ in ${\cal P}$ plays an essential role in
the evaluation of ${\cal P}$.
We also use ${\cal P}(<)$ to denote the set of $<$-relations of ${\cal P}$. 
Intuitively $<$ represents a preference
of applying rules during the evaluation of the program.
In particular, if
${\cal N}(r)<{\cal N}(r')$ holds in ${\cal P}$, rule $r$ would be
preferred to apply over rule $r'$ during the evaluation of ${\cal P}$
(i.e. rule $r$ is more preferred than rule $r'$).
Consider the following
classical example represented in our formalism:
\begin{quote}
${\cal P}_{1}=(\Pi,{\cal N},<)$:\\
\hspace*{.1in} $N_{1}: Fly(x)\leftarrow Bird(x)$, {\em not} $\neg Fly(x)$,\\
\hspace*{.1in} $N_{2}: \neg Fly(x)\leftarrow Penguin(x)$, {\em not} $Fly(x)$, \\
\hspace*{.1in} $N_{3}: Bird(Tweety)\leftarrow$,\\
\hspace*{.1in} $N_{4}: Penguin(Tweety)\leftarrow$,\\
\hspace*{.1in} $N_{2}<N_{1}$.
\end{quote}
Obviously, rules $N_{1}$ and $N_{2}$ conflict with each other
as their heads are complementary literals,
and applying $N_{1}$ will defeat
$N_{2}$ and {\em vice versa}.
However, as $N_{2}<N_{1}$, we would expect that rule $N_{2}$ is preferred
to apply first and then defeat rule $N_{1}$ so that
the desired solution $\neg Fly(Tweety)$ can be derived.

\begin{definition}
Let $\Pi$ be a ground extended logic program and $r$ a ground rule of the
form (\ref{eq2}) 
($r$ does not necessarily belong to $\Pi$).
Rule $r$ is {\em defeated}
by $\Pi$ iff $\Pi$ has an answer set and
for any answer set $S$ of $\Pi$,
there exists some $L_{i}\in S$, where $m+1\leq i\leq n$.
\end{definition}

Now our idea of evaluating a PLP is as follows.
Let ${\cal P}=(\Pi,{\cal N},<)$. If there are two rules
$r$ and $r'$ in $\Pi$ and ${\cal N}(r)<{\cal N}(r')$,
$r'$ will be ignored in the evaluation of ${\cal P}$, {\em only if}
keeping $r$ in $\Pi$ and deleting $r'$
from $\Pi$ will result in a defeat of $r'$.
By eliminating all such potential rules from $\Pi$,
$\cal P$ is eventually reduced to an extended logic program in which
the partial ordering $<$ has been removed. Our evaluation for
${\cal P}$ is then based on this {\em reduced} extended logic program.

Similarly to the case of extended logic programs, 
the evaluation of a PLP will be based on its ground form. 
We say that a PLP ${\cal P'}=(\Pi',{\cal N'},<')$ is the
{\em ground instantiation} of ${\cal P}=(\Pi,{\cal N},<)$ if 
(1) $\Pi'$ is the ground instantiation of $\Pi$; and (2) 
${\cal N'}(r_1')<' {\cal N'}(r_2')\in {\cal P'}(<')$ if and only
if there exist rules $r_1$ and $r_2$ in $\Pi$ such that
$r_1'$ and $r_2'$ are ground instances of $r_1$ and $r_2$ respectively and
${\cal N}(r_1) < {\cal N}(r_2)\in {\cal P}(<)$.
Under this definition, 
however, we require a restriction on a PLP since
not every PLP's ground instantiation presents a consistent
information with respect to the original PLP.
Consider a PLP as follows:
\begin{quote}
$N_{1}: P(f(x))\leftarrow not P(x)$,\\
\hspace*{.1in} $N_{2}: P(f(f(x)))\leftarrow not P(f(x))$,\\
\hspace*{.1in} $N_{2}<N_{1}$.
\end{quote}
If the only constant in the language is $0$, then the set of ground
instances of $N_{1}$ and $N_{2}$ includes rules like:
\begin{quote}
$N_{1}': P(f(0))\leftarrow not P(0)$,\\
\hspace*{.1in} $N_{2}': P(f(f(0)))\leftarrow not P(f(0))$,\\
\hspace*{.1in} $N_{3}': P(f(f(f(0))))\leftarrow not P(f(f(0)))$,\\
\hspace*{.1in} $\cdots$,
\end{quote}
It is easy to see that $N_{2}'$ can be viewed as an
instance for both $N_{1}$ and $N_{2}$. Therefore, the ordering $<'$
among rules $N_1', N_2',N_3',\cdots$
is no longer a partial ordering because of
$N_{2}'<'N_{2}'$.
Obviously, we need to exclude this kind of programs in our context.
On the other hand,
we also want to avoid a situation like
$\cdots <'N_{3}'<'N_{2}'<'N_{1}'$ in the ground
prioritized logic program because this $<'$ indicates that
there is no most preferred rule in the program.

Given a PLP ${\cal P}=(\Pi, {\cal N}, <)$. We say that
${\cal P}$ is {\em well formed} if
there is no rule $r'$ that is an instance of two different rules
$r_{1}$ and $r_{2}$ in $\Pi$ and
${\cal N}(r_{1})<{\cal N}(r_{2}) \in {\cal P}(<)$.
Then it is not difficult to observe that
the following fact holds.

\begin{quote}
{\bf Fact}: If a PLP ${\cal P}=(\Pi, {\cal N}, <)$ is well formed, then
in its ground instantiation ${\cal P'}=(\Pi', {\cal N'}, <')$, $<'$ is
a partial ordering and
every non-empty subset of $\Pi'$ has a least element with respect to $<'$.
\end{quote}

Due to the above fact,
in the rest of this paper, we will only consider well formed PLP programs
in our
discussions, and consequently, the evaluation for an arbitrary
PLP ${\cal P}=(\Pi,{\cal N},<)$  will be based on its ground
instantiation ${\cal P'}=(\Pi', {\cal N'}, <')$. Therefore, in our context
a ground prioritized (or extended) logic program may contain
infinite number of rules. In this case, we will assume that
this ground program is the ground instantiation of
some program that only contains
finite number of rules. In the rest of the paper, whenever
there is no confusion, we will only consider
ground prioritized (extended) logic programs without explicit 
declaration.

\begin{definition}
\cite{yan:plp}
Let ${\cal P}=(\Pi,{\cal N},<)$ be a prioritized logic program.
${\cal P}^{<}$ is a {\em reduct} of $\cal P$ with respect to $<$
if and only if there exists a sequence of sets $\Pi_{i}$
($i=0, 1, \cdots$) such that:
\begin{enumerate}
\item $\Pi_{0}=\Pi$;
\item $\Pi_{i}=\Pi_{i-1}-\{r_{1},r_{2},\cdots \mid$ (a)
there exists $r\in \Pi_{i-1}$ such that \\
\hspace*{.2in} for every $j$ ($j=1,2, \cdots$),
${\cal N}(r)<{\cal N}(r_{j})\in {\cal P}(<)$ and \\
\hspace*{.2in} $r_{1}, r_2, \cdots$
are defeated by $\Pi_{i-1}-\{r_{1}, r_{2}, \cdots\}$, and (b) there \\
\hspace*{.2in} are no rules $r',r'', \cdots \in\Pi_{i-1}$
such that $N(r_{j})<N(r')$, \\
\hspace*{.2in} $N(r_{j})<N(r''),\cdots$ 
for some $j$ ($j=1, 2, \cdots$)
and $r', r'', \cdots$ \\
\hspace*{.2in} are defeated by $\Pi_{i-1}-\{r', r'', \cdots\} \}$;
\item ${\cal P}^{<}=\bigcap_{i=0}^{\infty} \Pi_{i}$.
\end{enumerate}
\end{definition}

In Definition 2,
${\cal P}^{<}$ is an extended logic program
obtained from
$\Pi$ by eliminating some rules from $\Pi$.  In particular,
if ${\cal N}(r)<{\cal N}(r_{1})$, ${\cal N}(r)<{\cal N}(r_{2})$,
$\cdots$,
and $\Pi_{i-1}-\{r_{1}, r_{2},\cdots\}$ defeats $\{r_{1}, r_{2},\cdots\}$, then rules
$r_{1},r_{2},\cdots$
will be eliminated from $\Pi_{i-1}$ if no {\em less preferred rule} can be
eliminated (i.e. conditions (a) and (b)).
This procedure is continued until a fixed point is reached.
It should be noted that condition (b) in the above definition is 
necessary because without it some unintuitive 
results may be derived. For instance, consider ${\cal P}_{1}$ again,
if we add additional preference $N_3<N_2$ in ${\cal P}_{1}$, then using
a modified version of Definition 2 without condition (b), 
\begin{quote}
$\{Fly(Tweety)\leftarrow Bird(Tweety), not \neg Fly(Tweety)$, \\
\hspace*{.2in} $Bird(Tweety)\leftarrow$,\\
\hspace*{.2in} $Penguin(Tweety)\leftarrow\}$
\end{quote} 
is a reduct of ${\cal P}_1$, from which we will 
conclude that Tweety can fly.

\begin{definition}
\cite{yan:plp}
Let ${\cal P}=(\Pi,{\cal N},<)$ be a PLP and $Lit$ the set of all
ground literals in the language of $\cal P$. For any subset $S$ of $Lit$, $S$
is an {\em answer set} of $\cal P$ iff
$S$ is an answer set for some reduct ${\cal P}^{<}$ of ${\cal P}$.
\end{definition}

Using Definitions 2 and 3, it is easy to conclude that ${\cal P}_{1}$
has a unique reduct as follows:
\begin{quote}
${\cal P}_{1}^{<}=\{\neg Fly(Tweety)\leftarrow Penguin(Tweety)$, 
{\em not} $Fly(Tweety)$,\\
\hspace*{.5in} $Bird(Tweety)\leftarrow$, \\
\hspace*{.5in} $Penguin(Tweety)\leftarrow\}$,
\end{quote}
from which we obtain the following answer set of ${\cal P}_{1}$:
\begin{quote}
$S=\{Bird(Tweety)$, $Penguin(Tweety)$, $\neg Fly(Tweety)\}$.
\end{quote}

Now we consider another program ${\cal P}_{2}$:

\begin{quote}
$N_{1}: A\leftarrow$,\\
\hspace*{.1in} $N_{2}: B\leftarrow$ {\em not} $C$,\\
\hspace*{.1in} $N_{3}: D\leftarrow$,\\
\hspace*{.1in} $N_{4}: C\leftarrow$ {\em not} $B$,\\
\hspace*{.1in} $N_{1}<N_{2}, N_{3}<N_{4}$.
\end{quote}

According to Definition 2, it is easy to see that
${\cal P}_{2}$ has two reducts:
\begin{quote}
$\{A\leftarrow$, \hspace*{.05in}
$D\leftarrow$, 
\hspace*{.05in} $C\leftarrow$ {\em not} $B\}$, and\\
\hspace*{.1in}  $\{A\leftarrow$, 
\hspace*{.05in} $B\leftarrow$ {\em not} $C$,\
\hspace*{.05in} $D\leftarrow\}$.
\end{quote}
%
From Definition 3, it follows that ${\cal P}_{2}$ has two answer sets:
$\{A,C,D\}$ and $\{A,B,D\}$.

To see whether our PLP semantics gives intuitive results in
prioritized default reasoning, we further consider a program
${\cal P'}_2$ - a variation of program ${\cal P}_2$, as follows.
\begin{quote}
$N_1: A\leftarrow$,\\
\hspace*{.1in} $N_2: B\leftarrow$ {\em not} $C$, \\
\hspace*{.1in} $N_3: C\leftarrow$ {\em not} $B$,\\
\hspace*{.1in} $N_1<N_2$.
\end{quote}
It is easy to see that ${\cal P'}_2$ has one answer set $\{A, C\}$.
People may think that this result is not quite intuitive because 
rule $N_2$ is defeated in the evaluation although there is no
preference between $N_2$ and $N_3$. To explain why 
$\{A, C\}$ is a {\em reasonable} answer set of ${\cal P'}_2$, we should
review the concept of defeatness in our formulation (Definition 1).
In a PLP, when we specify one rule is less preferred than the other, for instance,
$N_1<N_2$ ($N_2$ is less preferred than $N_1$), it does not mean
that $N_2$ should be defeated by $N_1$ iff conflict occurs between them. 
Instead, it just means that $N_2$ has a lower priority than $N_1$
to be taken into account in the evaluation of
the {\em whole} program while other rules should be retained in 
the evaluation process if no preference is specified between 
$N_2$ and them. This intuition is captured by
the notion of defeatness in Definition 1 and Definition 2. 

Back to the above example, although there is no direct conflict between
$N_1$ and $N_2$ {\em and} no preference is specified between
$N_2$ and $N_3$ (where conflict exists between them), $N_2$ 
indeed has a lower priority than $N_1$ to be 
applied in the evaluation of ${\cal P'}_2$, which causes
$N_2$ to be defeated.

Now we illustrate several basic properties of
prioritized logic programs. As we mentioned earlier,
when we evaluate a
PLP, a rule including variables is viewed
as the set of its all ground instances.  
Therefore, we are actually dealing with {\em ground} 
prioritized logic programs that may consist of infinite collection 
of rules.
We first introduce some useful notations.
Let $\Pi$ be an extended logic program. We use ${\cal A}(\Pi)$ to
denote the class of all answer sets of $\Pi$.
Suppose ${\cal P}=(\Pi,{\cal N},<)$ is a PLP. From Definition 2, we can see
that a reduct ${\cal P}^{<}$ of ${\cal P}$ is generated
from a sequence of extended logic programs:
$\Pi=\Pi_{0}, \Pi_{1}, \Pi_{2}$, $\cdots$. We use 
$\{\Pi_{i}\}$ ($i=0, 1, 2, \cdots$) to denote this
sequence and call it
a {\em reduct chain} of ${\cal P}$.

\begin{proposition}
Let ${\cal P}=(\Pi,{\cal N},<)$ be a PLP and
$\{\Pi_{i}\}$ ($i=0, 1, 2, \cdots$) its reduct chain. Suppose
$\Pi$ has an answer set.  Then for any $i$ and $j$ where $i<j$,
${\cal A}(\Pi_{j})\subseteq {\cal A}(\Pi_{i})$.
\end{proposition}

\noindent
\begin{proof}
Let $\{\Pi_{i}\}$ ($i=0, 1, 2, \cdots$) be a reduct
chain of ${\cal P}$.
Suppose $S_{j}$ is an answer set of $\Pi_{j}$ for some $j>0$. To prove the
result, it is sufficient to show that
$S_{j}$ is also an answer set of $\Pi_{j-1}$.
According to Definition 2, $\Pi_{j}$ is obtained by eliminating
some rules from $\Pi_{j-1}$ where all these eliminated rules are
defeated by $\Pi_{j}$. So we can express:
\begin{quote}
$\Pi_{j}=\Pi_{j-1}-\{r_{1},r_{2},\cdots\}$.
\end{quote} 
Since $r_{1},r_{2}, \cdots$ are defeated by $\Pi_{j}$, we can write rules
$r_{1},r_{2}, \cdots$ to the following forms:
\begin{quote}
$r_{1}: L_{1}\leftarrow \cdots$, {\em not} $L_{1}', \cdots$,\\
\hspace*{.1in} $r_{2}: L_{2}\leftarrow \cdots$, {\em not} $L_{2}', \cdots$,\\
\hspace*{.1in} $\cdots$,
\end{quote} 
where $L_{1}',L_{2}',\cdots\in S_{j}$. Now consider Gelfond-Lifschitz transformation of
$\Pi_{j}$ in terms of $S_{j}$. It is clear that during the transformation, each
rule in $\Pi_{j}$ including $not$ $L_{1}'$, $not$ $L_{2}'$, $\cdots$ in
its body will be deleted. From here it follows that adding any rule with
$not$ $L_{1}'$ $not$ $L_{2}'$, $\cdots$  in its body will not play any role in the
evaluation of the answer set of the program. So we add
rules $r_{1}, r_{2}, \cdots$ into $\Pi_{j}$, This makes $\Pi_{j-1}$.
Then we have $\Pi_{j}^{S_{j}}=\Pi_{j-1}^{S_{j}}$.
So $S_{j}$ is also an answer set of $\Pi_{j-1}$.
\end{proof}


Proposition 1 shows an important property of the reduct chain
of ${\cal P}$: each $\Pi_{i}$ is consistent
with $\Pi_{i-1}$ but becomes more {\em specific} than
$\Pi_{i-1}$ in the sense
that all answer sets of $\Pi_{i}$ are answer sets of
$\Pi_{i-1}$ but some answer sets of $\Pi_{i-1}$ are
filtered out if they conflict with the preference partial ordering $<$.

\begin{example}
Consider a PLP ${\cal P}_{3}=(\Pi,{\cal N},<)$:
\begin{quote}
$N_{1}: A\leftarrow$ {\em not} $B$,\\
\hspace*{.1in} $N_{2}: B\leftarrow$ {\em not} $A$,\\
\hspace*{.1in} $N_{3}: C\leftarrow$ {\em not} $B$, {\em not} $D$,\\
\hspace*{.1in} $N_{4}: D\leftarrow$ {\em not} $C$,\\
\hspace*{.1in} $N_{1}<N_{2}, N_{3}<N_{4}$.
\end{quote}
From Definition 2, we can see that ${\cal P}_{3}$ has a reduct chain
$\{\Pi_{i}\}$ ($i=0,1,2$):
\begin{quote}
$\Pi_{0}$:\\
\hspace*{.2in} $A\leftarrow$ {\em not} $B$,\\
\hspace*{.2in} $B\leftarrow$ {\em not} $A$,\\
\hspace*{.2in} $C\leftarrow$ {\em not} $B$, {\em not} $D$,\\
\hspace*{.2in} $D\leftarrow$ {\em not} $C$,\\
\hspace*{.1in} $\Pi_{1}$:\\
\hspace*{.2in} $A\leftarrow$ {\em not} $B$,\\
\hspace*{.2in} $C\leftarrow$ {\em not} $B$, {\em not} $D$,\\
\hspace*{.2in} $D\leftarrow$ {\em not} $C$,\\
\hspace*{.1in} $\Pi_{2}$:\\
\hspace*{.2in} $A\leftarrow$ {\em not} $B$,\\
\hspace*{.2in} $C\leftarrow$ {\em not} $B$, {\em not} $D$.
\end{quote}
It is easy to verify that $\Pi_{0}$ has three answer sets
$\{A,C\}$, $\{B,D\}$ and $\{A,D\}$,
$\Pi_{1}$ has two answer sets $\{A,C\}$ and $\{A,D\}$, and
$\Pi_{2}$ has a unique answer set which is also the answer set
of ${\cal P}_{3}$: $\{A,C\}$.
%\rule{2mm}{2mm}
\end{example}

The following theorem shows the answer set relationship between
a PLP and its corresponding extended logic programs.

\begin{theorem}
Let ${\cal P}=(\Pi,{\cal N},<)$ be a PLP and $S$ a subset of $Lit$.
Then the following are equivalent:
\begin{enumerate}
\item $S$ is an answer set of ${\cal P}$.
\item $S$ is an answer set
of each $\Pi_{i}$ for some reduct chain $\{\Pi_{i}\}$ ($i=0,1,2,\cdots$)
of ${\cal P}$.
\end{enumerate}
\end{theorem}

\noindent   
\begin{proof}
(1 $\Rightarrow$ 2) Let ${\cal P}^{<}$ be a reduct of ${\cal P}$ obtained
from a reduct chain $\{\Pi_{i}\}$ ($i=0,1,2,\cdots$)
of ${\cal P}$. By applying Theorem 3 in section 3, it is easy to show that
any reduct chain of ${\cal P}$ is finite.
Therefore,
there exists some $k$ such that $\{\Pi_{i}\}$ ($i=0,1,2,\cdots, k$)
is the reduct chain. This follows that ${\cal P}^{<}=\Pi_k\subseteq \Pi_i$
($i=1,\cdots,k$). 
So from Proposition
1, an answer set of ${\cal P}^{<}$ is also an answer set of $\Pi_{i}$
($i=1,\cdots,k$).
            
(2 $\Rightarrow$ 1) Given a reduct chain
$\{\Pi_{i}\}$ ($i=0,1,2,\cdots$) of
${\cal P}$. 
From the above, since $\{\Pi_{i}\}$ ($i=0,1,2,\cdots$) is finite, 
we can assume that $\{\Pi_{i}\}$ ($i=0,1,2,\cdots, k$)
is the reduct chain. As $\Pi_j\subseteq \Pi_i$ if $j>i$, it 
follows that $\bigcap _{i=0}^{k}\Pi_{i}=\Pi_k$. So the
fact that $S$ is an answer set of
$\Pi_k$ implies that $S$ is also an answer set of ${\cal P}$.
\end{proof} 

\begin{corollary}
If a PLP ${\cal P}=(\Pi,{\cal N},<)$ has an answer set $S$, then $S$ is also
an answer set of $\Pi$.
\end{corollary}

\noindent   
\begin{proof}
From Theorem 1, it shows that if ${\cal P}$ has an answer set
$S$, then $S$ is also an answer set of each $\Pi_{i}$ for
${\cal P}$'s a reduct chain $\{\Pi_{i}\}$ ($i=0, 1, 2, \cdots$),
where $\Pi_{0}=\Pi$. So $S$ is also an answer set of $\Pi$.
\end{proof} 

The following theorem presents a sufficient and necessary
condition for the answer set existence of a PLP.

\begin{theorem}
Let ${\cal P}=(\Pi,{\cal N},<)$ be a PLP.
${\cal P}$ has an answer set if and only if
$\Pi$ has an answer set.
\end{theorem}

\noindent   
\begin{proof}
According to Corollary 1, we only need to prove that if $\Pi$ has an
answer set, then ${\cal P}$ also has an answer set.
Suppose $\Pi$ has an answer set and $\{\Pi_i\}$ ($i=0,1,\cdots$) 
is a reduct chain of ${\cal P}$. From the construction of
$\{\Pi_i\}$ (Definition 2), it is easy to see that every 
$\Pi_i$ ($i=0,1,\cdots$) must have an answer set. On the other hand,
as we have mentioned
in the proof of Theorem 1, 
${\cal P}$'s reduct chain is actually finite: $\{\Pi_i\}$ ($i=0,1,\cdots, k$).
That follows ${\cal P}^{<}=\Pi_k$. Since $\Pi_k$ has an answer set, 
it concludes ${\cal P}$ has an answer set as well.
\end{proof} 
            
\begin{proposition}
Suppose a PLP ${\cal P}$ has a unique reduct. If
${\cal P}$ has a consistent answer set, then ${\cal P}$'s every answer
set is also consistent.
\end{proposition}

\noindent   
\begin{proof}
The fact that ${\cal P}$ has a consistent answer set implies that
${\cal P}$'s reduct ${\cal P}^{<}$ (note
${\cal P}^{<}$ is an extended logic program)
has a consistent answer set. Then from
the result showed in section 2 of \cite{lt:lp94}
(i.e. if an extended logic program has a consistent answer set, then its
every answer set is also consistent), it follows that
${\cal P}^{<}$'s every answer set is also consistent.
\end{proof} 
            
\section{Mutual Defeasibility and Unique Answer Set}

In this section, we try to provide a sufficient condition to 
characterize the uniqueness
of the answer set for a prioritized logic program.
The following definition extends the concept of local stratification for
general logic programs \cite{apt:94,ch:stra,lp:92} to extended logic programs.

\begin{definition}
Let $\Pi$ be an extended logic program 
and $Lit$ be the set of all
ground literals of $\Pi$.
\begin{enumerate}
\item A {\em local stratification} for $\Pi$ is a function
{\em stratum} from $Lit$ to the countable ordinals.
\item Given a local stratification $stratum$, we extend it to ground literals with
negation as failure by setting
$stratum(\mbox{not }L)=stratum(L)+1$, where $L$ is a ground literal.
\item A rule
$L_{0}\leftarrow L_{1},\cdots, L_{m}$, not $L_{m+1},\cdots$, not $L_{n}$
in $\Pi$ is {\em locally stratified} with respect to
$stratum$ if
\begin{quote}
$stratum(L_{0})\geq stratum(L_{i})$, where $1\leq i\leq m$, and\\
$stratum(L_{0})> stratum(not L_{j})$, where $m+1\leq j\leq n$.
\end{quote}
\item $\Pi$ is called {\em locally stratified} with respect to $stratum$
if all of its rules are locally stratified. $\Pi$ is called
{\em locally stratified} if it is locally stratified with respect to
some local stratification.
\end{enumerate}
\end{definition}

It is easy to see that the corresponding extended logic 
program of ${\cal P}_{1}$ (see section 2) is not locally stratified. 
In general, we have the following sufficient condition to
ensure the uniqueness of the answer set for an extended logic program.

\begin{proposition}
Let $\Pi$ be an extended logic program. If $\Pi$ is
locally stratified,
then $\Pi$ has a unique answer set\footnote{Recall that
if $\Pi$ has an inconsistent answer set, we will denote it as
$Lit$. This proposition is a direct generalization of the result for 
general logic programs as described in \cite{gl:stable}.}.
\end{proposition}

Now we define the concept of mutual defeasibility
which plays a key role in investigating a sufficient condition for
the unique answer set of a PLP.

\begin{definition}
Let $\Pi$ be an extended logic program
and $r_{p}$ and $r_{q}$ be two rules in $\Pi$.
We define a set ${\cal D}(r_{p})$ of literals with respect to
$r_{p}$ as follows:
\begin{quote}
${\cal D}_{0}=\{head(r_p)\}$;\\
\hspace*{.1in} ${\cal D}_{i}={\cal D}_{i-1}\cup \{head(r)\mid head(r')\in pos(r)$
where $r\in \Pi$ and 
$r'$ are those\\
\hspace*{1.4in}  rules such that $head(r')\in {\cal D}_{i-1}\}$;\\ 
\hspace*{.1in} ${\cal D}(r_{p})=\bigcup_{i=1}^{\infty} {\cal D}_{i}$.
\end{quote}
We say that
$r_{q}$ is {\em defeasible through} $r_{p}$ in $\Pi$ if and only if
$neg(r_{q})\cap {\cal D}(r_{p})\neq \emptyset$.
$r_{p}$ and $r_{q}$ are called {\em mutually defeasible} in $\Pi$ if
$r_{q}$ is defeasible through $r_{p}$ and
$r_{p}$ is defeasible through $r_{q}$ in $\Pi$.
\end{definition}

Intuitively, if $r_{q}$ is defeasible through $r_{p}$ in $\Pi$, then
there exists a sequence of rules
$r_{1}, r_{2}, \cdots, r_{l}, \cdots$ such that
$head(r_{p})$ occurs in $pos(r_{1})$, $head(r_{i})$ occurs
in $pos(r_{i+1})$ for all $i=1, \cdots$, and for some $k$, $head(r_{k})$ occurs in
$neg(r_{q})$. Under this condition, it is clear that by triggering rule
$r_{p}$ in $\Pi$, it is possible to defeat rule $r_{q}$ if
rules $r_{1}, \cdots, r_{k}$ are triggered as well.
As a special case that ${\cal D}(r_{p})=\{head(r_p)\}$, $r_{q}$ is defeasible
through $r_{p}$ iff $head(r_{p})\in neg(r_{q})$.
The following proposition simply describes the relationship between
local stratification and mutual defeasibility.

\begin{proposition}
Let $\Pi$ be an extended logic program.
If $\Pi$ is locally stratified, then there does not exist
mutually defeasible pair of rules in $\Pi$.
\end{proposition}

The above result is easy to prove from the corresponding result for general
logic programs showed in \cite{gl:stable} based on
Gelfond and Lifschitz's translation
from an extended logic program to a general logic program \cite{gl:logic}.
It is observed that for a PLP ${\cal P}=(\Pi,{\cal N},<)$, if
$\Pi$ is locally stratified, then ${\cal P}$ will have a unique answer set.
In other words, $\Pi$'s local stratification implies that ${\cal P}$
has a unique answer set.
However, this condition seems too strong because
many prioritized logic programs will still have unique answer sets although
their corresponding extended logic programs
are not locally stratified. For
instance, program ${\cal P}_{1}$ presented in section 2 has a unique
answer set but its corresponding
extended logic program is not locally stratified.
But one fact is clear: the uniqueness of reduct for a PLP is necessary
to guarantee this PLP to have a unique answer set.

The above observation suggests that we should first investigate
the condition under which a prioritized logic program has a unique
reduct. Then by applying Proposition 3 to the unique reduct of the PLP,
we obtain the unique answer set condition for this PLP.

\begin{definition}
Let ${\cal P}=(\Pi,{\cal N},<)$ be a PLP.
A $<$-{\em partition} of $\Pi$ in
${\cal P}$ is a finite collection $\{\Pi_{1},\cdots, \Pi_{k}\}$,
where $\Pi=\Pi_{1}\cup\cdots \cup\Pi_{k}$ and
$\Pi_{i}$ and $\Pi_{j}$ are disjoint for any $i\neq j$, such that
\begin{enumerate}
\item
${\cal N}(r)<{\cal N}(r')$ $\in {\cal P}(<)$ implies that
there exist some $i$ and $j$ ($1\leq i<j$) such that
$r'\in \Pi_{j}$ and $r\in \Pi_{i}$;
\item
for each rule $r' \in \Pi_{j}$ ($j>1$),
there exists some rule $r\in \Pi_{i}$ ($1\leq i < j$) such that
${\cal N}(r)<{\cal N}(r') \in {\cal P}(<)$.
\end{enumerate}
\end{definition}

\begin{example}
Consider a PLP ${\cal P}_{4}=(\Pi,{\cal N},<)$:
\begin{quote}
$N_{1}: A\leftarrow$ {\em not} $B$, {\em not} $C$,\\
\hspace*{.1in} $N_{2}: B\leftarrow$ {\em not} $\neg C$,\\
\hspace*{.1in} $N_{3}: C\leftarrow$ {\em not} $A$, {\em not} $\neg C$,\\
\hspace*{.1in} $N_{4}: \neg C\leftarrow$ {\em not} $C$, \\
\hspace*{.1in} $N_{1}<N_{2}, N_{2}<N_{4}, N_{3}<N_{4}$.
\end{quote}
It is easy to verify that a $<$-partition of $\Pi$ in
${\cal P}_{4}$ is $\{\Pi_{1}, \Pi_{2}, \Pi_{3}\}$, where
\begin{quote}
$\Pi_{1}$:  \\
\hspace*{.2in} $N_{1}: A\leftarrow$ {\em not} $B$, {\em not} $C$, \\
\hspace*{.2in} $N_{3}: C\leftarrow$ {\em not} $A$, {\em not} $\neg C$,\\
\hspace*{.1in} $\Pi_{2}$:\\
\hspace*{.2in} $N_{2}: B\leftarrow$ {\em not} $\neg C$,\\
\hspace*{.1in} $\Pi_{3}$:  \\
\hspace*{.2in} $N_{4}: \neg C\leftarrow$ {\em not} $C$.
\end{quote}
In fact, this program has a unique answer set $\{B, C\}$.
%\rule{2mm}{2mm}
\end{example}

\begin{theorem}
Every prioritized logic program has a $<$-partition.
\end{theorem}

\noindent
\begin{proof}
For a given PLP ${\cal P}=(\Pi,{\cal N},<)$,
we construct a series of subsets of $\Pi$ as follows:\\
%\begin{quote}
\hspace*{.1in} $\Pi_{1}=\{r\mid \mbox{there does not exist a rule } r'\in \Pi$
$\mbox{ such that } {\cal N}(r')<{\cal N}(r)\}$;\\
\hspace*{.1in} $\Pi_{i}=\{r\mid \mbox{for all rules such that }$
${\cal N}(r')<{\cal N}(r)$, $r'\in \bigcup_{j=1}^{i-1}\Pi_{j}\}$.\\
%\end{quote}
We prove that $\{\Pi_{1},\Pi_{2},\cdots\}$ is a
$<$-partition of ${\cal P}$.
First, it is easy to see that $\Pi_{i}$ and $\Pi_{j}$ are disjoint.
Now we show that this partition satisfies conditions 1 and 2 described in
Definition 6. Let ${\cal N}(r)<{\cal N}(r')\in {\cal P}(<)$. If
there does not exist any rule $r''\in \Pi$ such that
${\cal N}(r'')<{\cal N}(r)$, then $r\in\Pi_{1}$. Otherwise, there exists some
$i$ ($i>1$) such that $r\in \Pi_{i}$ and for all rules satisfying
${\cal N}(r'')<{\cal N}(r)$ $r''\in \Pi_{1}\cup\cdots\cup\Pi_{i-1}$.
Let $r'\in \Pi_{j}$. Since ${\cal N}(r)<{\cal N}(r')$, it follows that $1<j$.
From the construction of $\Pi_{j}$, we also conclude
$r\in \Pi_{1}\cup\cdots\cup\Pi_{j-1}$. Since $r'\in \Pi_{j}$,
it follows $i\leq j-1$. That is, $i<j$.
Condition 2 directly follows
from the construction of the partition described above.

Now we show that $\{\Pi_{1},\Pi_{2}, \cdots\}$ must be a finite set.
First, if $\Pi$ is finite, it is clear
$\{\Pi_{1},\Pi_{2}, \cdots\}$ must be a finite set.
If $\Pi$ contains infinite rules, then according to our assumption presented in
section 2,
${\cal P}$ must be the ground instantiation of some program, say
${\cal P}^{*}=(\Pi^{*}, {\cal N}^{*}, <^{*})$.
Then we can use the same way to define
a $<$-partition for ${\cal P}^{*}$. Since
$\Pi^{*}$ is finite, the partition of ${\cal P}^{*}$ must be
also finite: $\{\Pi_{1}^{*}, \Pi_{2}^{*}, \cdots, \Pi_{k}^{*}\}$.
As ${\cal P}^{*}$ is well formed, it implies that for each $i$,
$\Pi_{i}$ is the ground instantiation of $\Pi_{i}^{*}$. So
$\{\Pi_{1},\Pi_{2},\cdots\}$ is finite.
%\rule{2mm}{2mm}
\end{proof}



\begin{theorem}

({\bf Unique Answer Set Theorem})
Let ${\cal P}=(\Pi,{\cal N}<)$ be a PLP and $\{\Pi_{1},\cdots, \Pi_{k}\}$
be a $<$-partition of $\Pi$ in ${\cal P}$.
${\cal P}$ has a unique reduct if there does not exist
two rules $r_{p}$ and $r_{q}$
in $\Pi_{i}$ and $\Pi_{j}$ ($i,j>1$) respectively such that
$r_{p}$ and $r_{q}$ are mutually defeasible in $\Pi$.
${\cal P}$ has a unique answer set if ${\cal P}$ has a unique locally
stratified reduct.
\end{theorem}

\noindent
\begin{proof}
According to Proposition 3, it is sufficient to only prove the
first part of this theorem: ${\cal P}$ has a unique
reduct if there does not exist
two rules $r_{p}$ and $r_{q}$
in $\Pi_{i}$ and $\Pi_{j}$ ($i,j>1$) respectively such that
$r_{p}$ and $r_{q}$ are mutually defeasible in $\Pi$.

We assume that ${\cal P}$ has two different reducts, say
${\cal P}^{<(1)}$ and ${\cal P}^{<(2)}$. This follows that there exist at least
two different rules $r_{p}$ and $r_{q}$ such that (1) $r_{p} \in \Pi_{i}$ and
$r_{q}\in \Pi_{j}$, where $i, j>1$;
(2) $r_{q}\in {\cal P}^{<(1)}$, $r_{q}\not\in {\cal P}^{<(2)}$, and
$r_{p}\not\in {\cal P}^{<(1)}$; and
(3) $r_{p}\in {\cal P}^{<(2)}$, $r_{p}\not\in {\cal P}^{<(1)}$, and
$r_{q}\not\in {\cal P}^{<(2)}$.
According to Definition 2, ${\cal P}^{<(1)}$ and
${\cal P}^{<(2)}$ are generated from two
reduct chains $\{\Pi_{0}^{(1)}, \Pi_{1}^{(1)}, \cdots\}$ and
$\{\Pi_{0}^{(2)}, \Pi_{1}^{(2)}, \cdots\}$ respectively.

Without loss of generality, we may assume that 
for all
$0\leq i < k$, $\Pi_{i}^{(1)}=\Pi_{i}^{(2)}$, and
\begin{quote}
$\Pi_{k}^{(1)}=\Pi_{k-1}^{(1)} - \{r_{1},\cdots, r_{l}, r_{p},\cdots\}$,\\
\hspace*{.1in} $\Pi_{k}^{(2)}=\Pi_{k-1}^{(2)} - \{r_{1},\cdots, r_{l}, r_{q},\cdots\}$,
\end{quote}
where we set $\Pi_{k-1}=\Pi_{k-1}^{(1)}=\Pi_{k-1}^{(2)}$ and the only difference
between $\Pi_{k}^{(1)}$ and $\Pi_{k}^{(2)}$ is due to rules $r_{p}$ and $r_{q}$.
%\footnote{Usually
%the difference between $\Pi_{k}^{(1)}$ and $\Pi_{k}^{(2)}$ could be
%more than just $r_{p}$ and $r_{q}$. But a minor modification of this proof is enough to 
%capture the general case.}.
Let $r_{p}$ and $r_{q}$ have the following forms:
\begin{quote}
$r_{p}: L_{p}\leftarrow\cdots$, {\em not} $L_{p}', \cdots$,\\
\hspace*{.1in} $r_{q}: L_{q}\leftarrow\cdots$, {\em not} $L_{q}', \cdots$.
\end{quote}
Comparing $\Pi_{k}^{(1)}$ and $\Pi_{k}^{(2)}$, it is clear that the only difference
between these two programs is about rules $r_{p}$ and $r_{q}$.  Since
$\Pi_{k}^{(1)}$ defeats $r_{p}$ and $\Pi_{k}^{(2)}$ defeats $r_{q}$, it follows that
$L_{q}'\in S_{k}^{(1)}$ and $L_{p}'\in S_{k}^{(2)}$, where
$S_{k}^{(1)}$ and $S_{k}^{(2)}$ are answer sets of
$\Pi_{k}^{(1)}$ and $\Pi_{k}^{(2)}$ respectively.
%
Then there must exist some rule in $\Pi_{k}^{(1)}$ of the form:
\begin{quote}
$r^{(1)}: L_{p}'\leftarrow\cdots$,
\end{quote}
and some rule in $\Pi_{k}^{(2)}$ of the form:
\begin{quote}
$r^{(2)}: L_{q}'\leftarrow\cdots$.
\end{quote}
Furthermore, since $\Pi_{k}^{(1)}-\{r_{p}, r_{q}\}$
does not defeat rule $r_{p}$ and $\Pi_{k}^{(2)}-\{r_{p}, r_{q}\}$
does not defeat rule $r_{q}$ (otherwise
$\Pi_{k}^{(1)}=\Pi_{k}^{(2)}$), it is observed that
rule $r_{q}$ triggers rule $r^{(1)}$ in $\Pi_{k}^{(1)}$
that defeats $r_{p}$, and rule $r_{p}$
triggers rule $r^{(2)}$ in $\Pi_{k}^{(2)}$
that defeats $r_{q}$. This follows that $r_{p}$ and
$r_{q}$ are mutually defeasible in $\Pi$.
%\rule{2mm}{2mm}
\end{proof}


Note that according to Proposition 4, the condition 
for ${\cal P}=(\Pi,{\cal N},<)$ to have a unique answer set 
stated in Theorem 4 is weaker than the  
local stratification requirement for $\Pi$ to have
a unique answer set as showed by Proposition 3.

\begin{example}
Consider PLP ${\cal P}_{5}=(\Pi, {\cal N}, <)$ as follows:
\begin{quote}
$N_{1}: A\leftarrow$ {\em not} $B$, {\em not} $C$, {\em not} $D$,\\
\hspace*{.1in} $N_{2}: B\leftarrow$ {\em not} $A$, {\em not} $D$, \\
\hspace*{.1in} $N_{3}: C\leftarrow$ {\em not} $A$, {\em not} $D$,\\
\hspace*{.1in} $N_{4}: D\leftarrow$ {\em not} $A$,\\
\hspace*{.1in} $N_{1}<N_{2}<N_{3}$.
\end{quote}
Clearly, a $<$-partition of $\Pi$ is as follows:
\begin{quote}
$\Pi_{1}$:\\
\hspace*{.2in} $N_{1}: A\leftarrow$ {\em not} $B$, {\em not} $C$ {\em not} $D$,\\
\hspace*{.2in} $N_{4}: D\leftarrow$ {\em not} $A$,\\
\hspace*{.1in} $\Pi_{2}$:\\
\hspace*{.2in} $N_{2}: B\leftarrow$ {\em not} $A$, \\
\hspace*{.1in} $\Pi_{3}$:\\
\hspace*{.2in} $N_{3}: C\leftarrow$ {\em not} $A$.
\end{quote}
Although $\Pi$ is not locally stratified, from Theorem 4,
${\cal P}_{5}$ should have a unique reduct $\{N_{1}\}$ since 
$N_{2}$ and $N_{3}$ are not mutually defeasible. This also
concludes that ${\cal P}_{5}$ has a unique answer set $\{A\}$.
%\rule{2mm}{2mm}
\end{example}


\section{Splitting Prioritized Logic Programs}


It has been observed that deciding whether a prioritized logic
program has an answer set is NP-complete \cite{yan:00lp}. That means,
in practice it is unlikely to implement a polynomial algorithm to compute
the answer set of
a prioritized logic program. Hence,
finding suitable strategy to simplify such computation is an important issue.
Similarly to the case of extended logic programs \cite{lt:lp94}, we will show that
under proper conditions, 
a PLP ${\cal P}$ can be split into several smaller components
${\cal P}_{1}, \cdots, {\cal P}_{k}$ such that the evaluation of ${\cal P}$'s
answer sets can be based on the evaluation of the answer sets of
${\cal P}_{1}, \cdots, {\cal P}_{k}$.
To describe our idea, we
first consider the case of splitting a PLP into two parts.

\begin{example}
Consider the following PLP ${\cal P}_{6}=(\Pi, {\cal N}, <)$:
\begin{quote}
$N_{1}: A\leftarrow not \neg A, not D$, \\
\hspace*{.1in} $N_{2}: D\leftarrow not \neg D$,\\
\hspace*{.1in} $N_{3}: \neg D\leftarrow not D$,\\
\hspace*{.1in} $N_{4}: B\leftarrow not C$,\\
\hspace*{.1in} $N_{5}: C\leftarrow not B$, \\
\hspace*{.1in} $N_{6}: A\leftarrow C, \neg D$,\\
\hspace*{.1in} $N_{1}<N_{4}, N_{6}<N_{2}$.
\end{quote}
Clearly, this PLP has a unique reduct $\{N_{1}, N_{3}, N_{5}, N_{6}\}$, which gives
a unique answer set $\{A, C, \neg D\}$.

We observe that $\Pi$ actually can be split into two segments
$\Pi_{1}=\{N_{1}, N_{2}, N_{3}\}$ and $\Pi_{2}=\{N_{4}, N_{5}, N_{6}\}$ such that
$head(\Pi_{2})\cap body(\Pi_{1})=\emptyset$. Now we try to reduce
the computation of ${\cal P}_{6}$'s answer sets to the computation of two
smaller PLPs' answer sets. Firstly, we define a PLP
${\cal P}_{6}^{1}=(\Pi_{1}^{*}, {\cal N}, <)$ by setting
$\Pi_{1}^{*}=\Pi_{1}\cup\{N_{0}: First\leftarrow\}$ and
${\cal P}_{6}^{1}(<)=\{N_{0}<N_{2}\}$.
The role of rule $N_{0}$ is to introduce a $<$-relation
$N_{0}<N_{2}$ to replace the original $<$-relation $N_{6}<N_{2}$ in ${\cal P}_{6}$
that is missed from ${\cal P}_{6}^{1}$ by eliminating $N_{6}$ from $\Pi_{1}$.
The unique answer set of ${\cal P}_{6}^{1}$ is $S_{1}=\{First, A, \neg D\}$.
Since $head(\Pi_{2})\cap body(\Pi_{1})=\emptyset$, it is easy to see that
in each of ${\cal P}_{6}$'s answer sets,
any literals derived by using rules in $\Pi_{2}$ will
not trigger or defeat any rules in $\Pi_{1}$. This implies that every literal in
${\cal P}_{6}^{1}$'s answer set (except {\em First}) will also occur in an answer set of
the original ${\cal P}_{6}$. Therefore, we can define another PLP
${\cal P}_{6}^{2}=(\Pi_{2}^{*}, {\cal N}, <)$ by setting
$\Pi_{2}^{*}$
$=\{N_{4}, N_{5}\}\cup\{N_{0}: First\leftarrow, \hspace*{.05in} N_{6}': A\leftarrow C\}$
and $N_{0}<N_{4}$. Here $N_{6}$ in $\Pi_{2}$ is
replaced by $N_{6}'$ under ${\cal P}_{6}^{1}$'s
answer set $S_{1}$ providing $\neg D$ to be true. Then
${\cal P}_{6}^{2}$ also has a unique answer set $S_{2}=\{First, A, C\}$.
Finally,  the unique answer set of
${\cal P}_{6}$ is obtained by $S_{1}\cup S_{2}-\{First\}=\{A, C, \neg D\}$.
%\rule{2mm}{2mm}
\end{example}

From the above example, we see that if in a PLP ${\cal P}=(\Pi, {\cal N}, <)$,
$\Pi$ can be split into two parts $\Pi_{1}$ and $\Pi_{2}$ such that
$head(\Pi_{2})\cap body(\Pi_{1})=\emptyset$, then it is possible to
also split ${\cal P}$ into two smaller PLPs
${\cal P}^{1}$ and ${\cal P}^{2}$ such that
${\cal P}$'s every answer set can be computed from ${\cal P}^{1}$ and ${\cal P}^{2}$'s.
To formalize our result, we first introduce some useful notions.
%
Given a PLP ${\cal P}=(\Pi,{\cal N},<)$,
we define a map $first^{<}: \Pi \longrightarrow \Pi$, such that
$first^{<}(r)=r'$ if there exists some
$r'$ such that ${\cal N}(r')<{\cal N}(r)\in {\cal P}(<)$ and there does not exist
another $r'' \in \Pi$ satisfying ${\cal N}(r'')<{\cal N}(r')\in {\cal P}(<)$;
otherwise $first^{<}(r)=undefined$.
Intuitively, $first^{<}(r)$ gives the rule which is most preferred than $r$
in ${\cal P}$. As $<$ is a strict partial ordering,
there may be more than one most preferred rules than $r$.

To define a split of a PLP, we first introduce the concept of $e$-reduct of 
an extended logic program. Let $\Pi$ be an extended logic 
program and $X$ be a set of ground literals.
The $e$-{\em reduct} of $\Pi$
with respect to set $X$ is an extended logic program, denoted as $e(\Pi,X)$, 
obtained from $\Pi$ by deleting (1) each rule in $\Pi$ that has 
a formula $not L$ in its body with $L\in X$, and (2) all
formulas of the form $L$ in the bodies of the remaining rules with $L\in X$.
%
Consider an example that $X=\{C\}$ and $\Pi$ consists of two rules:
\begin{quote}
$A\leftarrow B, not C$,\\
\hspace*{.1in} $B\leftarrow C, not A$.
\end{quote}
Then $e(\Pi,X)=\{B\leftarrow not A\}$. Intuitively, the $e$-reduct
of $\Pi$ with respect to $X$ can be viewed as a simplified 
program of $\Pi$ given the fact that every literal in $X$ is true.
For a
rule $r\in e(\Pi,X)$, we use
$original(r)$ to denote $r$'s original form in $\Pi$.
In the above example, it is easy to see that
$original(B\leftarrow not A)$ is $B\leftarrow C, not A$.
Now a split of a PLP can be formally defined as follows.

\begin{definition}
Let ${\cal P}=(\Pi, {\cal N},<)$. We say that $({\cal P}^{1}, {\cal P}^{2})$ is
a {\em split} of ${\cal P}$, if there exist two disjoint
subsets $\Pi_{1}$ and $\Pi_{2}$ of
$\Pi$, where $\Pi=\Pi_{1}\cup\Pi_{2}$,  such that
\begin{enumerate}
\item $head(\Pi_{2})\cap body(\Pi_{1})=\emptyset$,
%
\item ${\cal P}^{1}=(\Pi_{1}\cup\{N_{0}: First\leftarrow\}, {\cal N},<)$\footnote{Here
we assume that {\em First} is a ground literal not occurring in ${\cal P}$.}, where
for any $r, r'\in \Pi_{1}$, ${\cal N}(r)<{\cal N}(r')\in {\cal P}(<)$ implies
${\cal N}(r)<{\cal N}(r')\in {\cal P}^{1}(<)$, and if there exists some
$r''\in \Pi_{2}$ and $first^{<}(r)=r''$, then $N_{0}<{\cal N}(r)\in {\cal P}^{1}(<)$;
%
\item ${\cal P}^{2}=(e(\Pi_{2},S_{1})\cup\{N_{0}: First\leftarrow\}, {\cal N},<)$, where
$S_{1}$ is an answer set of ${\cal P}^{1}$,
for any $r, r'\in e(\Pi_{2},S_{1})$,
${\cal N}(original(r))<{\cal N}(original(r'))\in {\cal P}(<)$ implies
${\cal N}(r)<{\cal N}(r')\in {\cal P}^{2}(<)$, and if there exists some
$r''\in \Pi_{1}$ and $first^{<}(original(r))$ $=r''$,
then $N_{0}<{\cal N}(r)\in {\cal P}^{2}(<)$.
\end{enumerate}
A split $({\cal P}^{1}, {\cal P}^{2})$ is called $S$-{\em dependent} if
$S$ is an answer set of ${\cal P}^{1}$ and ${\cal P}^{2}$ is formed based on
$S$ as described in condition 3 above,
i.e. ${\cal P}^{2}=(e(\Pi_{2},S)\cup\{N_{0}: First\leftarrow\}, {\cal N},<)$.
\end{definition}

In Example 4, it is easy to verify that
$({\cal P}_{6}^{1},{\cal P}_{6}^{2})$ is a split of ${\cal P}_{6}$.
Now we have the major result of splitting a PLP.

\begin{theorem}
Let $({\cal P}^{1}, {\cal P}^{2})$ be a $S_1$-dependent split of 
${\cal P}$ as defined in Definition 7.  A set of ground literals $S$
is a consistent answer set of ${\cal P}$ if and only if
$S=S_{1}\cup S_{2}-\{First\}$, where 
$S_{2}$ is an answer set of ${\cal P}^{2}$, and
$S_{1}\cup S_{2}$ is consistent.
\end{theorem}


\noindent
\begin{proof}
We prove this theorem in two steps. Suppose $\Pi^{*}$ is a reduct of ${\cal P}$.
According to Definition
2, $\Pi^{*}$ can be represented as the form
$\Pi^{*}=\Pi_{1}^{*}\cup\Pi_{2}^{*}$, where $\Pi_{1}^{*}\subseteq\Pi_{1}$ and
$\Pi_{2}^{*}\subseteq \Pi_{2}$.
So every answer set of $\Pi^{*}$ is also an answer set of ${\cal P}$.
In the first step, 
we prove \underline{\em Result 1}: a set $S$ of ground literals is a
consistent answer set of $\Pi^{*}$ iff $S=S_{1}\cup S_{2}$, where
$S_{1}$ is an answer set of $\Pi_{1}^{*}$, $S_{2}$ is an answer set of
$e(\Pi_{2}^{*},S_{1})$, and $S_{1}\cup S_{2}$ is consistent.
In the second step, we prove \underline{\em Result 2}:
$\Pi_{1}^{*}\cup\{First\leftarrow\}$ is a reduct of
${\cal P}^{1}$ and $e(\Pi_{2}^{*},S_{1})\cup\{First\leftarrow\}$ is a reduct of
${\cal P}^{2}$. Then the theorem is proved  directly from these two results.

We first prove \underline{\em Result 1}. ($\Leftarrow$)
Let $S=S_{1}\cup S_2$ and
$\Pi^{*}=\Pi_{1}^{*}\cup\Pi_{2}^{*}$, where $S_{1}$ is an answer set
of $\Pi_{1}^{*}$ and $S_2$ is an answer set of
$e(\Pi_{2}^{*},S_{1})$ and  $S_{1}\cup S_2$
is consistent. 
Consider the Gelfond-Lifschitz transformation of
$\Pi^{*}$ in terms of $S$, $\Pi^{* S}$.
$\Pi^{* S}$ is obtained from $\Pi^{*}$ by deleting
\begin{enumerate}[(ii)]
\item[(i)] each rule in
$\Pi_{1}^{*}\cup\Pi_{2}^{*}$ that has a formula {\em not} $L$ in its
body with $L\in S$; and
\item[(ii)] all formulas of the form
{\em not} $L$ in the bodies of the remaining rules.
\end{enumerate}
Since $body(\Pi_{1}^{*})\cap head(\Pi_{2}^{*})=\emptyset$, during the
step (i) in the above transformation, for each literal
$L\in S_{1}$, only rules of the
form $L'\leftarrow\cdots$, {\em not} $L, \cdots$
in $\Pi_{1}^{*}$ or $\Pi_{2}^{*}$ will be deleted.
On the other hand, for each literal $L\in S_2$,
only rules of the form $L'\leftarrow\cdots$, {\em not} $L, \cdots$ in
$\Pi_{2}^{*}$ will be deleted and no rules in $\Pi_{1}^{*}$ can be deleted
because $head(\Pi_2^{*})\cap body(\Pi_1^{*})=\emptyset$.
%     
Therefore, we can denote
$\Pi^{* S}$ as $\Pi_{1}^{*'}\cup \Pi_{2}^{*'}$, where
$\Pi_{1}^{*'}$ is obtained from $\Pi_{1}^{*}$ in terms of literals in $S_{1}$, and
$\Pi_{2}^{*'}$ is obtained from $\Pi_{2}^{*}$ in terms of literals in
$S_{1}\cup S_2$
during the above transformation procedure. Then it is easy to see
that $\Pi_{1}^{*'}=\Pi_{1}^{* S_{1}}$. So $S_{1}$ is an answer set of
$\Pi_{1}^{*'}$.

On the other hand, from the construction of $e(\Pi_{2}^{*},S_{1})$,
it is observed that there exists the following correspondence
between $\Pi_{2}^{*'}$ and $e(\Pi_{2}^{*},S_{1})$:
for each rule
\begin{quote}
$L_{0}\leftarrow L_{1},\cdots, L_{k},L_{k+1},\cdots, L_{m}$
\end{quote}
in $\Pi_{2}^{*'}$, there is a rule of the form
\begin{quote}
$L_{0}\leftarrow L_{1},\cdots, L_{k},not L_{m+1},\cdots, not L_{n}$ 
\end{quote}
in $e(\Pi_{2},S_{1})$ such that
$L_{k+1},\cdots, L_{m}\in S_{1}$ and
$L_{m+1},\cdots$, $L_{n}\not\in S_{1}$; on the other hand,
for each rule
$L_{0}\leftarrow L_{1},\cdots, L_{k}$, {\em not} $L_{m+1},\cdots$,
{\em not} $L_{n}$ in $e(\Pi_{2}^{*},S_{1})$,
if none of $L_{m+1},\cdots, L_{n}$ is in $S_2$, then
there exists a rule $L_{0}\leftarrow L_{1},\cdots, L_{k},L_{k+1},\cdots, L_{m}$ in
$\Pi_{2}^{*'}$ such that $L_{k+1},\cdots, L_{m}\in S_{1}$.
From this observation, it can be seen that there
exists a subset $\Delta$ of $S_{1}$ such that
$\Delta\cup S_2$ is an answer set of $\Pi_{2}^{*'}$.
This follows that $S_{1}\cup S_2$ is the smallest set
such that for each rule $L_{0}\leftarrow L_{1},\cdots, L_{m}\in \Pi^{* S}$,
$L_{1},\cdots,L_{m}\in S$ implies $L_{0}\in S$.
That is, $S$ is an answer set of $\Pi^{* S}$ and also
an answer set of $\Pi^{*}$.

($\Rightarrow$) Let $\Pi^{*}=\Pi_{1}^{*}\cup \Pi_{2}^{*}$ and
$S$ be a consistent answer set of $\Pi^{*}$.
It is clear that for each literal $L\in S$, there
must exist some rule of the form $L\leftarrow \cdots$ in $\Pi$.
So we can write $S$ as a form of $S'_{1}\cup S'_{2}$
such that $S'_{1}\subseteq head(\Pi_{1}^{*})$ and
$S'_{2}\subseteq head(\Pi_{2}^{*})$. Note that
$S'_{1}\cap S'_{2}$ may not be empty.
Now we transfer set $S'_{1}$ into $S_{1}$ by the following step:
if $S'_{1}\cap S'_{2}=\emptyset$, then
$S_{1}=S'_{1}$; otherwise, let
% 
% 
\begin{quote}
$S_{1} =S'_{1} -$
$\{L\mid L\in S'_{1}\cap S'_{2}$, and for each rule\\
\hspace*{.9in}
$L\leftarrow L_{1},\cdots,L_{m}$, {\em not}$L_{m+1},\cdots$, {\em not}$L_{n}$ in
$\Pi_{1}^{*}$, there exists some\\
\hspace*{.9in}
$L_{j}$ ($1\leq j\leq m$) $\not\in S'_{1}$ or
$L_{j}\in S'_{1} (m+1\leq j\leq n)\}$.
% 
\end{quote}
In above translation,
since every $L$ deleted from $S_{1}$ is also in $S'_{2}$,
the answer set $S$ of $\Pi^{*}$ can then be expressed as
% 
$S=S_{1}\cup S'_{2}$.
An important fact is observed from the construction of
$S_{1}$:\\
{\bf Fact 1}. $L\in S_{1}$ iff there exists some rule
in $\Pi_{1}^{*}$ of the form
\begin{quote}
$L\leftarrow L_{1},\cdots,L_{m},not L_{m+1},\cdots, not L_{n}$, 
\end{quote}
such that $L_{1},\cdots,L_{m}$
$\in S_{1}$ and $L_{m+1},\cdots$, or $L_{n}$
$\not\in S_{1}$.

Now we prove $S_{1}$ is an answer set of $\Pi_{1}^{*}$.
We do Gelfond-Lifschitz transformation on $\Pi^{*}$ in terms of
set $S=S_{1}\cup S'_{2}$. After such transformation,
we can write $\Pi^{* S}$ as form
$\Pi_{1}^{*'}\cup\Pi_{2}^{*'}$, where
$\Pi_{1}^{*'}\subseteq \Pi_{1}^{*}$ and $\Pi_{2}^{*'}\subseteq \Pi_{2}^{*}$.
As $head(\Pi_{2}^{*}) \cap body(\Pi_{1}^{*})=\emptyset$,
any literal
in $S'_{2}$ will not cause a deletion of a rule from $\Pi_{1}^{*}$ in
the Gelfond-Lifschitz transformation.
Then it is easy to see that $\Pi_{1}^{*'} =\Pi_{1}^{* S_{1}}$.
From {\bf Fact 1}, it concludes that
literal $L\in S_{1}$ iff there is a rule
$L\leftarrow L_{1},\cdots L_{m}$ in $\Pi_{1}^{* S_{1}}$ and
$L_{1},\cdots,L_{m} \in S_{1}$. This follows that
$S_{1}$ is an answer set of $\Pi_{1}^{* S_{1}}$, and then
an answer set of $\Pi_{1}^{*}$.

Now we transfer $S'_{2}$ into $S_2$ by the following step:
if $S_{1}\cap S'_{2}=\emptyset$, then
$S_2=S'_{2}$; otherwise, let
\begin{quote}
$S_2=S'_{2}-\{L\mid L\in S_{1}\cap S'_{2}$,
and for each rule \\
\hspace*{.9in} $L\leftarrow L_{1},\cdots,L_{m}$,
{\em not} $L_{m+1},\cdots$, {\em not} $L_{n}$ in $\Pi_{2}^{*}$, there exists
some \\
\hspace*{.9in} $L_{j} (1\leq j\leq m) \not\in S_{1}\cup S'_{2}$, or
$L_{j}\in S_{1}\cup S'_{2} (m+1\leq j\leq n)\}$.
\end{quote}
After this translation, $S$ can be expressed as
$S=S_{1}\cup S_2$.
An important fact is also observed from the translation of $S_{2}$:\\
{\bf Fact 2}. $L\in S_2$ iff
there exists some rule in $\Pi_{2}^{*'}$ of the form
\begin{quote}
$L\leftarrow L_{1},\cdots,L_{k},L_{k+1},\cdots,L_{m}$
\end{quote}
such that $L_{1},\cdots,L_{k}\in S_{1}$ and
$L_{k+1},\cdots,L_{m}\in S_2$.

Now we prove $S_2$ is an answer set of $e(\Pi_{1}^{*}, S_{1})$.
Recall that
$\Pi^{* S}=\Pi_{1}^{*'}\cup \Pi_{2}^{*'}=\Pi_{1}^{* S_{1}}\cup \Pi_{2}^{*'}$.
From {\bf Fact 2}, it is clear that there exists a subset $\Delta$ of
$S_{1}$ such that $S_2$ is an answer set of
$e(\Pi_{2}^{*'},\Delta)$ and $e(\Pi_{2}^{*'},\Delta)^{S_2}=e(\Pi_{2}^{*'},\Delta)$.
On the other hand, from the construction
of $e(\Pi_{2}^{*},S_{1})$, it is easy to see that
$e(\Pi_{2}^{*},S_{1})^{S_2}=e(\Pi_{2}^{*'},\Delta)$
$=e(\Pi_{2}^{*'},\Delta)^{S_2}$. So $S_2$ is also an answer set
of $e(\Pi_{2}^{*},S_{1})$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\comment{

(Sketch)
Under the condition of $head(\Pi_{2}^{*})$
$\cap$ $body(\Pi_{1}^{*})=\emptyset$,
we apply
Gelfond-Lifschitz transformation on $\Pi^{*}$ in terms of $S$, denoted as
$\Pi^{* S}$.
%obtained from $\Pi^{*}$ by deleting (i) each rule in
%$\Pi_{1}^{*}\cup\Pi_{2}^{*}$ that has a
%formula $not L$ in its body with $L\in S$; and (ii)
%all formulas of the form $not L$ in the bodies of the remaining rules.
%Since $head(\Pi_{2}^{*})\cap body(\Pi_{1}^{*})=\emptyset$, during step (i) in the above
%transformation,
Then we observe that for each $L\in S_{1}$, only rules
with the form $L'\leftarrow\cdots, not L$ in
$\Pi_{1}^{*}$ will be deleted, and for each $L\in S_{2}$, only rules
with the form $L'\leftarrow\cdots, not L$ in $\Pi_{2}^{*}$ will be deleted,
and no other rules in
$\Pi_{1}^{*}$ can be deleted. So we can represent
$\Pi^{* S}$ as $\Pi_{1}^{*'}\cup \Pi_{2}^{*'}$, where $\Pi_{1}^{*'}$ is obtained
from $\Pi_{1}^{*}$ in terms of literals in $S_{1}$, and $\Pi_{2}^{*'}$ is obtained from
$\Pi_{2}^{*}$ in terms of literals in $S_{1}\cup S_{2}$ during the transformation.
Then it is easy to see that $\Pi_{1}^{*'}=\Pi_{1}^{*S_{1}}$. So $S_{1}$ is also an answer
set of $\Pi_{1}^{*'}$. From this fact, we can show that
$S_{1}\cup S_{2}$ is the smallest set such that for each
$L_{0}\leftarrow L_{1},\cdots,L_{m}\in \Pi^{* S}$,
$L_{1},\cdots, L_{m}\in S$ implies $L_{0}\in S$. That is, $S$ is an answer set of
$\Pi^{* S}$, and also an answer set of $\Pi^{*}$.

($\Rightarrow$) Suppose $S$ is a consistent answer set of $\Pi^{*}$.
Let $S=S_{1}'\cup S_{2}'$ where $S_{1}'\subseteq head(\Pi_{1}^{*})$ and
$S_{2}'\subseteq head(\Pi_{2}^{*})$. Note that $S_{1}'\cap S_{2}'$ may not be empty. Now
we transfer $S_{1}'$ to $S_{1}$ as follows: if
$S_{1}'\cap S_{2}'=\emptyset$, then $S_{1}'=S_{1}$; otherwise
$S_{1}=S_{1}'-\{L\mid S_{1}'\cap S_{2}'$, and for each
rule
$L\leftarrow L_{1},\cdots, L_{m}, not L_{m+1},\cdots, not L_{n} \in \Pi_{1}^{*}$, there
exists some $L_{j} (1\leq j\leq m) \not\in S_{1}'$ or
$L_{j} (m+1\leq j\leq n) \in S_{1}'\}$.  Note that in this translation, every
literal deleted from $S_{1}'$ is also in $S_{2}'$.
So $S$ can be also represented as the form $S=S_{1}\cup S_{2}'$. It can be verified that
$S_{1}$ is indeed an  answer set of $\Pi_{1}^{*}$. Similarly, we transfer $S_{2}'$ to
$S_{2}$ as follows: if $S_{1}\cap S_{2}'=\emptyset$, then
$S_{2}=S_{2}'$; otherwise, let
$S_{2}=S_{2}'-\{L\mid L\in S_{1}\cap S_{2}'$, and for each rule
$L\leftarrow L_{1},\cdots, L_{m}, not L_{m+1},\cdots, not L_{n}\in \Pi_{2}^{*}$,
there exists some $L_{j} (1\leq j\leq m)\not\in S_{1}\cup S_{2}'$, or
$L_{j} (m+1\leq j\leq n)\in S_{1}\cup S_{2}'\}$.
After this translation, $S$ can be represented as
$S=S_{1}\cup S_{2}$. Then it can be also verified
that $S_{2}$ is an answer set of $e(\Pi_{2}^{*},S_1)$.

}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Now we show \underline{\em Result 2}. 
The fact that $\Pi_{1}^{*}\cup \{First\leftarrow\}$ is a reduct of ${\cal P}^{1}$ is proved
based on a construction of a 1-1 correspondence between the computation of
${\cal P}$'s reduct and ${\cal P}^{1}$'s reduct.
Let $\{\Pi^{i}\}$ ($i=0, 1, \cdots$)
be the series generated by computing ${\cal P}$'s reduct
(see Definition 2), and $\{\Pi'^{i}\}$ ($i=0, 1, \cdots$) be the series
generated by computing ${\cal P}^{1}$'s reduct. From the specification of
${\cal P}^{1}$ and condition $head(\Pi_{2})\cap body(\Pi_{1})=\emptyset$,
we observe that for each $\Pi^{i}$, which is obtained from
$\Pi^{i-1}$ by eliminating some rules from $\Pi^{i-1}$,
if some rule in $\Pi_{1}$ is deleted, then this rule must be also deleted in
$\Pi'^{i}$; if no rule in  $\Pi_{1}$ is deleted (e.g. all rules deleted
from $\Pi^{i-1}$ are in $\Pi_{2}$),
then we set $\Pi'^{i}=\Pi'^{i-1}$. Then it is clear that
every rule in $\Pi_{1}^{*}\cup \{First\leftarrow\}$ 
must be also in the reduct of ${\cal P}^{1}$ and
{\em vice versa}. This concludes that $\Pi_{1}^{*}\cup\{First\leftarrow\}$ 
is a reduct of ${\cal P}^{1}$.
Similarly we can show that $e(\Pi_{2}^{*},S_{1})\cup \{First\leftarrow\}$ 
is a reduct of ${\cal P}^{2}$.
%\rule{2mm}{2mm}
\end{proof}

Once a PLP has a split, by applying Theorem 5, 
we eventually reduce the computation of a large PLP's answer sets
to the computation of two smaller PLPs' answer sets.
In a general case, it is also possible to split a large PLP into
a series of smaller PLPs.

\begin{definition}
Let ${\cal P}=(\Pi, {\cal N},<)$. We say that $({\cal P}^{1}, \cdots, {\cal P}^{k})$ is
a {\em split} of ${\cal P}$,
if there exist $k$ disjoint subsets $\Pi_{1},\cdots, \Pi_{k}$ of
$\Pi$, where $\Pi=\bigcup_{i=1}^{k}\Pi_{i}$,  such that
\begin{enumerate}
\item $head(\Pi_{i})\cap body(\bigcup_{j=1}^{i-1}\Pi_{j})=\emptyset$, ($i=2, \cdots, k$),
%
\item ${\cal P}^{1}=(\Pi_{1}\cup\{N_{0}: First\leftarrow\}, {\cal N},<)$, where
for any $r, r'\in \Pi_{1}$, ${\cal N}(r)<{\cal N}(r')\in {\cal P}(<)$ implies
${\cal N}(r)<{\cal N}(r')\in {\cal P}^{1}(<)$, and if there exists some
$r''\not\in \Pi_{1}$ and $first^{<}(r)=r''$, then $N_{0}<{\cal N}(r)\in {\cal P'}(<)$;
%
\item ${\cal P}^{i}=(e(\Pi_{i},\bigcup_{j=1}^{i-1} S_{j})$
$\cup\{N_{0}: First\leftarrow\}, {\cal N},<)$, where
$S_{j}$ is an answer set of ${\cal P}^{j}$,
for any $r, r'\in e(\Pi_{i},\bigcup_{j=1}^{i-1} S_{j})$,
${\cal N}(original(r))<{\cal N}(original(r'))\in {\cal P}(<)$ implies
${\cal N}(r)<{\cal N}(r')\in {\cal P}^{i}(<)$, and if there exists some
$r''\not\in \Pi_{i}$ and $first^{<}(original(r))$ $=r''$,
then $N_{0}<{\cal N}(r)\in {\cal P}^{i}(<)$.
\end{enumerate}
A split $({\cal P}^{1},\cdots, {\cal P}^{k})$ is called
$\bigcup_{i=1}^{k-1}S_i$-{\em dependent} if
$S_i$ is an answer set of ${\cal P}^{i}$ ($i=1,\cdots,k-1$) 
and each ${\cal P}^{i+1}$ is formed based on 
$\bigcup_{j=1}^{i}S_j$ as described in condition 3 above.
\end{definition}

Now using a similar technique as described in the proof of Theorem 5, we
have the following general splitting result.

\begin{theorem}
Let $({\cal P}^{1}, \cdots, {\cal P}^{k})$ be a 
$\bigcup_{i=1}^{k-1}S_i$-{\em dependent} split of ${\cal P}$ as defined in
Definition 8.  A set of ground literals $S$
is a consistent answer set of ${\cal P}$ if and only if
$S=\bigcup_{i=1}^{k} S_{i}-\{First\}$, where $S_{k}$ is an answer set of
${\cal P}^{k}$, and $\bigcup_{i=1}^{k} S_{i}$ is consistent.
\end{theorem}

\begin{example}
Consider PLP ${\cal P}_{7}=(\Pi, {\cal N},<)$ as follows:
\begin{quote}
$N_{1}: A\leftarrow not B$,\\
\hspace*{.1in} $N_{2}: B\leftarrow not A$,\\
\hspace*{.1in} $N_{3}: C\leftarrow not \neg C$, \\
\hspace*{.1in} $N_{4}: D\leftarrow not B$,\\
\hspace*{.1in} $N_{5}: \neg D\leftarrow not D$,\\
\hspace*{.1in} $N_{1}<N_{2}<N_{3}<N_{4}<N_{5}$.
\end{quote}
Let $\Pi_{1}=\{N_{1}, N_{2}\}$, $\Pi_{2}=\{N_{3}, N_{4}\}$, and $\Pi_{3}=\{N_{5}\}$.
Clearly, $head(\Pi_{2})\cap body(\Pi_{1})=\emptyset$ and
$head(\Pi_{3})\cap body(\Pi_{1}\cup \Pi_{2})=\emptyset$. Then a split
of ${\cal P}_{7}$, denoted as
$({\cal P}_{7}^{1}, {\cal P}_{7}^{2}, {\cal P}_{7}^{3})$,
can be constructed. Ignoring the detail,
this split is illustrated as follows:
\begin{quote}
${\cal P}_{7}^{1}$: \hspace*{1.in}
${\cal P}_{7}^{2}$: \hspace*{1.in} ${\cal P}_{7}^{3}$:\\
\hspace*{.1in} $N_{0}: First\leftarrow$,  \hspace*{.45in} $N_{0}: First\leftarrow$,
\hspace*{.5in} $N_{0}: First\leftarrow$, \\
% line 1
\hspace*{.1in} $N_{1}: A\leftarrow not B$,
\hspace*{.3in} $N_{3}: C\leftarrow not \neg C$, \\
% line 2
\hspace*{.1in} $N_{2}: B\leftarrow not A$,
\hspace*{.3in} $N_{4}: D\leftarrow not B$,\\
% line 3
\hspace*{.1in} $N_{1}<N_{2}$,
\hspace*{.65in} $N_{0}<N_{3}<N_{4}$,
\end{quote} 
Then according to Theorem 6,
each answer set of ${\cal P}_{7}$
can be represented as $S_{1}\cup S_{2}\cup S_{3} - \{First\}$,
where $S_{1}$, $S_{2}$, and $S_{3}$ are answer sets of
${\cal P}_{7}^{1}$, ${\cal P}_{7}^{2}$ and
${\cal P}_{7}^{3}$ respectively, which are
$\{First, A\}$, $\{First, C, D\}$ and $\{First\}$ respectively.
So $\{A, C, D\}$ is the unique answer set of ${\cal P}_{7}$.
\end{example}


\section{Conclusion}

In this paper, we have proved two major results for 
prioritized logic programs:
the unique answer set theorem and
splitting theorems for prioritized logic programs.
By introducing the concept of mutual defeasibility,
the first result provides a sufficient condition for the unique answer 
set of a prioritized logic program. It is observed that the sufficient condition
in Theorem 4 is weaker than the local stratification as required for
extended logic programs.

Our splitting theorems, on the other hand, 
illustrated that as in the case of extended logic programs, under  
certain
conditions, the computation of answer sets of a prioritized logic 
program can be simplified.
It is interesting to note that by omitting preference relation $<$,
our splitting theorems actually also present new results for splitting usual 
extended logic program which 
generalizes Lifschitz and Turner's result \cite{lt:lp94}. Consider
an extended logic program $\Pi$ consisting of the following rules:
\begin{quote}
$A\leftarrow$ {\em not} $C$,\\     
\hspace*{.1in} $A\leftarrow$ {\em not} $B$,\\
\hspace*{.1in} $B\leftarrow$ {\em not} $A$. 
\end{quote}        
This program does not have a non-trivial split under
Lifschitz and Turner's Splitting Set Theorem,
but under our splitting theorem condition, $\Pi$ can 
be split into $\Pi_{1}$ and $\Pi_{2}$ as follows:
\begin{quote}                      
$\Pi_{1}$: \hspace*{1.2in} $\Pi_{2}$:\\
\hspace*{.1in} $A\leftarrow$ {\em not} $C$,
\hspace*{.7in} $A\leftarrow$ {\em not} $B$,\\
\hspace*{1.55in} $B\leftarrow$ {\em not} $A$,
\end{quote}                        
such that $body(\Pi_{1})\cap head(\Pi_{2})=\emptyset$. It is observed that
$\{A\}$ is the unique answer set of $\Pi_{1}$, and
the unique answer set of $\Pi$ is then obtained from
$\Pi_{1}$'s answer set $\{A\}$ and the answer set of
$e(\Pi_{2},\{A\})$, which is also $\{A\}$. So we get the unique answer set
of $\Pi$ $\{A\}$.   A detailed discussion on the relationship between 
Lifschitz and Turner's Splitting Set Theorem and our splitting result on 
extended  logic programs 
is referred to the author's another paper \cite{yan:iclp99}. 

%but has a major difference from
%Choelwinski's default theory splitting result \cite{ch:stra} and none of these
%two splitting methods generalizes the other.

We should state that
our results proved in this paper 
are based on a specific formulation of prioritized logic programming, and hence
it is not clear yet whether they are generally suitable for other prioritized 
default reasoning systems, e.g. \cite{d:plp,g:97,w:plp}. 
However, since the traditional
answer set semantics was employed in our development of 
prioritized logic programming, we would expect that our results could be extended 
to other answer set semantics based PLP frameworks. This will be
an interesting topic for our future work.

Finally, 
it is also worth mentioning that besides the idea of developing
a ``prioritized version'' of answer set semantics for PLP (like the approach 
we discussed in this paper),
there are other approaches to PLP
in which the semantics of PLP is defined by 
modular and simple translation of PLP programs into standard logic
programs. Work on this direction is due to 
Gelfond and Son \cite{ms:98}, Delgrande, Schaub and Tompits \cite{d:plp} and
some other researchers. Recently, Schaub and Wang
further investigated a series of uniform characterizations among these
approaches \cite{sw:01}. For these approaches, the classical splitting
set theorem \cite{lt:lp94} can be used to simplify the reasoning 
procedure of PLP.




\bibliography{tlp2esam}

\end{document}



\end{filecontents*}

\begin{filecontents*}{tlp2esam.bib}

@article{apt:94,
  author={K.R. Apt and R.N. Bol},
  title={Logic programming and negation: A survey},
  journal={Journal of Logic Programming},
  year=1994,
  volume= {19,20},
  pages={9-71}
}


@article{brewka:plp,
  author={G. Brewka}, 
  title={Well-founded semantics for extended logic programs with
          dynamic preferences},
  journal={Journal of Artificial Intelligence Research},
  year=1996, 
  volume=4,
  pages={19-36}
}

@article{be:aij,
  author={G. Brewka and T. Eiter},
  title={Preferred answer sets for extended logic programs},
  journal={Artificial Intelligence},
  year=1999,
  volume=109,
  pages={297-356}
}

@conference{ch:stra,
  author={P. Choelwinski},
  title={Stratified default logic},
  booktitle={Proceedings of Computer Science Logic}, 
  year=1994,
  publisher={Springer, LNCS 933},
  pages={456-470}
}

@book{lp:92,
  author={S.K. Das},
  title={Deductive Database and Logic Programming},
  publisher={Addison-Wesley Publishers Ltd},
  year=1992
}

@conference{d:plp,
  author={J. Delgrande and T. Schaub and H. Tompits},
  title={Logic programs with complied preferences},
  booktitle={Proceedings of the 14th European Conference
                on Artificial Intelligence (ECAI-2000)}, 
  year=2000,
  pages={392-398}
}

@conference{gl:stable,
  author={M. Gelfond and V. Lifschitz},
  title={The stable model semantics for logic programming},
  booktitle={Proceedings of the Fifth Joint International
              Conference and Symposium},
  year=1988,
  publisher={MIT Press},
  pages={1070-1080}
}


@article{gl:logic,
  author={M. Gelfond and V. Lifschitz},
  title={Classical negation in logic programs and disjunctive databases},
  journal={New Generation Computing}, 
  volume={9},
  year=1991,
  pages={365-386}
}

@conference{ms:98,
   author={M. Gelfond and T.C. Son},
   title={Reasoning with prioritized defaults},
   booktitle={LNAI 1471},
   year=1998,
   publisher={Springer}, 
   pages={164-224},
}

@conference{g:97,
   author={B.N. Grosof},
   title={Prioritized conflict handling for logic programs},
   booktitle={Proceedings of the 1997 International Logic Program Symposium
              (ILPS'97)}, 
   publisher={MIT Press},
   year=1997,
   pages={197-212}
}

@conference{lt:lp94,
    author={V. Lifschitz and H. Turner},
    title={Splitting a logic program},
    booktitle={Proceedings of Eleventh International Conference on Logic Programming},
    year=1994,
    publisher={MIT Press},
    pages={23-37}
}

@conference{sw:01,
    author={T. Schaub and K. Wang},
    title={A comparative study of logic programs with preference},
    booktitle={Proceedings of the 17th International Joint Conference
                on Artificial Intelligence (IJCAI-2001)},
    year={2001},
    publisher={Morgan Kaufmann Publishers Inc.},
    pages={597-602}
}

@conference{w:plp,
    author={K. Wang and L. Zhou and F. Lin},
    title={Alternating fixpoint theory for logic programs with priority},
    booktitle={Proceedings of International Joint Conference on
                  Computational Logic (CL-2000)}, 
    year=2000,
    pages={164-178}
}

@conference{yan:ijcai97,
    author={Y. Zhang and N.Y. Foo},
    title={Towards generalized rule-based updates},
    booktitle={Proceedings of the 15th International Joint Conference on 
                Artificial Intelligence (IJCAI'97)}, 
    year=1997,
    publisher={Morgan Kaufmann Publishers Inc.},
    pages={82-88}
}

@conference{yan:plp,
    author={Y. Zhang and N.Y. Foo},
    title={Answer sets for prioritized logic programs},
    booktitle={Proceedings of the 1997 International Logic Programming
               Symposium (ILPS'97)}, 
    year=1997,
    publisher={MIT Press},
    pages={69-83}
}

@conference{yan:ecai98,
    author={Y. Zhang and N.Y. Foo},
    title={Updating logic programs},
    booktitle={Proceedings of the 13th European Conference
                on Artificial Intelligence (ECAI'98)},
    year=1998,
    publisher={John Wiley \& Sons, Inc.},
    pages={403-407}
}

@conference{yan:iclp99,
     author={Y. Zhang}, 
     title={Monotonicity in rule based update},
     booktitle={Proceedings of the 1999 International Conference on 
                Logic Programming (ICLP'99)}, 
     year=1999,
     publisher={MIT Press},
     pages={471-485}
}

@conference{yan:00lp,
     author={Y. Zhang},
     title={The complexity of logic program update},
     booktitle={Proceedings of the 14th Australian Joint Conference on Artificial
                Intelligence (AI2001)},
     year=2001,
     publisher={Springer, LNAI 2256},
     pages={630-643}
}

@conference{yan:plp-impl01,
    author={Y. Zhang and C-M. Wu and Y. Bai},
    title={Implementing prioritized logic programming},
    journal={Artificial Intelligence Communications}, 
    volume={14},
    year=2001,
    pages={in Press}
}



\end{filecontents*}

\begin{filecontents*}{tlp2esam.bbl}
\begin{thebibliography}{}

\bibitem[\protect\citeauthoryear{Apt and Bol}{Apt and Bol}{1994}]{apt:94}
{\sc Apt, K.} {\sc and} {\sc Bol, R.} 1994.
\newblock Logic programming and negation: A survey.
\newblock {\em Journal of Logic Programming\/}~{\em 19,20}, 9--71.

\bibitem[\protect\citeauthoryear{Brewka}{Brewka}{1996}]{brewka:plp}
{\sc Brewka, G.} 1996.
\newblock Well-founded semantics for extended logic programs with dynamic
  preferences.
\newblock {\em Journal of Artificial Intelligence Research\/}~{\em 4}, 19--36.

\bibitem[\protect\citeauthoryear{Brewka and Eiter}{Brewka and
  Eiter}{1999}]{be:aij}
{\sc Brewka, G.} {\sc and} {\sc Eiter, T.} 1999.
\newblock Preferred answer sets for extended logic programs.
\newblock {\em Artificial Intelligence\/}~{\em 109}, 297--356.

\bibitem[\protect\citeauthoryear{Choelwinski}{Choelwinski}{1994}]{ch:stra}
{\sc Choelwinski, P.} 1994.
\newblock Stratified default logic.
\newblock In {\em Proceedings of Computer Science Logic}. Springer, LNCS 933,
  456--470.

\bibitem[\protect\citeauthoryear{Das}{Das}{1992}]{lp:92}
{\sc Das, S.} 1992.
\newblock {\em Deductive Database and Logic Programming}.
\newblock Addison-Wesley Publishers Ltd.

\bibitem[\protect\citeauthoryear{Delgrande, Schaub, and Tompits}{Delgrande
  et~al\mbox{.}}{2000}]{d:plp}
{\sc Delgrande, J.}, {\sc Schaub, T.}, {\sc and} {\sc Tompits, H.} 2000.
\newblock Logic programs with complied preferences.
\newblock In {\em Proceedings of the 14th European Conference on Artificial
  Intelligence (ECAI-2000)}. 392--398.

\bibitem[\protect\citeauthoryear{Gelfond and Lifschitz}{Gelfond and
  Lifschitz}{1988}]{gl:stable}
{\sc Gelfond, M.} {\sc and} {\sc Lifschitz, V.} 1988.
\newblock The stable model semantics for logic programming.
\newblock In {\em Proceedings of the Fifth Joint International Conference and
  Symposium}. MIT Press, 1070--1080.

\bibitem[\protect\citeauthoryear{Gelfond and Lifschitz}{Gelfond and
  Lifschitz}{1991}]{gl:logic}
{\sc Gelfond, M.} {\sc and} {\sc Lifschitz, V.} 1991.
\newblock Classical negation in logic programs and disjunctive databases.
\newblock {\em New Generation Computing\/}~{\em 9}, 365--386.

\bibitem[\protect\citeauthoryear{Gelfond and Son}{Gelfond and
  Son}{1998}]{ms:98}
{\sc Gelfond, M.} {\sc and} {\sc Son, T.} 1998.
\newblock Reasoning with prioritized defaults.
\newblock In {\em LNAI 1471}. Springer, 164--224.

\bibitem[\protect\citeauthoryear{Grosof}{Grosof}{1997}]{g:97}
{\sc Grosof, B.} 1997.
\newblock Prioritized conflict handling for logic programs.
\newblock In {\em Proceedings of the 1997 International Logic Program Symposium
  (ILPS'97)}. MIT Press, 197--212.

\bibitem[\protect\citeauthoryear{Lifschitz and Turner}{Lifschitz and
  Turner}{1994}]{lt:lp94}
{\sc Lifschitz, V.} {\sc and} {\sc Turner, H.} 1994.
\newblock Splitting a logic program.
\newblock In {\em Proceedings of Eleventh International Conference on Logic
  Programming}. MIT Press, 23--37.

\bibitem[\protect\citeauthoryear{Schaub and Wang}{Schaub and
  Wang}{2001}]{sw:01}
{\sc Schaub, T.} {\sc and} {\sc Wang, K.} 2001.
\newblock A comparative study of logic programs with preference.
\newblock In {\em Proceedings of the 17th International Joint Conference on
  Artificial Intelligence (IJCAI-2001)}. Morgan Kaufmann Publishers Inc.,
  597--602.

\bibitem[\protect\citeauthoryear{Wang, Zhou, and Lin}{Wang
  et~al\mbox{.}}{2000}]{w:plp}
{\sc Wang, K.}, {\sc Zhou, L.}, {\sc and} {\sc Lin, F.} 2000.
\newblock Alternating fixpoint theory for logic programs with priority.
\newblock In {\em Proceedings of International Joint Conference on
  Computational Logic (CL-2000)}. 164--178.

\bibitem[\protect\citeauthoryear{Zhang}{Zhang}{1999}]{yan:iclp99}
{\sc Zhang, Y.} 1999.
\newblock Monotonicity in rule based update.
\newblock In {\em Proceedings of the 1999 International Conference on Logic
  Programming (ICLP'99)}. MIT Press, 471--485.

\bibitem[\protect\citeauthoryear{Zhang}{Zhang}{2001}]{yan:00lp}
{\sc Zhang, Y.} 2001.
\newblock The complexity of logic program update.
\newblock In {\em Proceedings of the 14th Australian Joint Conference on
  Artificial Intelligence (AI2001)}. Springer, LNAI 2256, 630--643.

\bibitem[\protect\citeauthoryear{Zhang and Foo}{Zhang and Foo}{1997}]{yan:plp}
{\sc Zhang, Y.} {\sc and} {\sc Foo, N.} 1997.
\newblock Answer sets for prioritized logic programs.
\newblock In {\em Proceedings of the 1997 International Logic Programming
  Symposium (ILPS'97)}. MIT Press, 69--83.

\end{thebibliography}
\end{filecontents*}

\begin{filecontents*}{aopmath.sty}
\DeclareMathVersion{zed}
\SetMathAlphabet{\mathrm}{zed}{\encodingdefault}{\rmdefault}{m}{n}%
\SetMathAlphabet{\mathbf}{zed}{\encodingdefault}{\rmdefault}{bx}{n}%
\SetMathAlphabet{\mathsf}{zed}{\encodingdefault}{\sfdefault}{m}{n}%
\SetMathAlphabet{\mathtt}{zed}{\encodingdefault}{\ttdefault}{m}{n}%
\DeclareSymbolFont{italics}{\encodingdefault}{\rmdefault}{m}{it}%
\DeclareSymbolFontAlphabet{\mathrm}{operators}
\DeclareSymbolFontAlphabet{\mathit}{letters}
\DeclareSymbolFontAlphabet{\mathcal}{symbols}
\DeclareSymbolFont{lasy}{U}{lasy}{m}{n}
\DeclareSymbolFont{AMSa}{U}{msa}{m}{n}
\DeclareSymbolFont{AMSb}{U}{msb}{m}{n}
\let\mho\undefined
\let\Join\undefined
\let\Box\undefined
\let\Diamond\undefined
\let\leadsto\undefined
\let\sqsubset\undefined
\let\sqsupset\undefined
\let\lhd\undefined
\let\unlhd\undefined
\let\rhd\undefined
\let\unrhd\undefined
\DeclareMathSymbol{\mho}{\mathord}{lasy}{"30}
\DeclareMathSymbol{\Join}{\mathrel}{lasy}{"31}
\DeclareMathSymbol{\Box}{\mathord}{lasy}{"32}
\DeclareMathSymbol{\Diamond}{\mathord}{lasy}{"33}
\DeclareMathSymbol{\leadsto}{\mathrel}{lasy}{"3B}
\DeclareMathSymbol{\sqsubset}{\mathrel}{lasy}{"3C}
\DeclareMathSymbol{\sqsupset}{\mathrel}{lasy}{"3D}
\DeclareMathSymbol{\lhd}{\mathrel}{lasy}{"01}
\DeclareMathSymbol{\unlhd}{\mathrel}{lasy}{"02}
\DeclareMathSymbol{\rhd}{\mathrel}{lasy}{"03}
\DeclareMathSymbol{\unrhd}{\mathrel}{lasy}{"04}
\DeclareSymbolFontAlphabet{\bbold}{AMSb}
\mathversion{zed}


\def\@setmcodes#1#2#3{{\count0=#1 \count1=#3
    \loop \global\mathcode\count0=\count1 \ifnum \count0<#2
    \advance\count0 by1 \advance\count1 by1 \repeat}}
\@setmcodes{`A}{`Z}{"7\hexnumber@\symitalics41}% 
\@setmcodes{`a}{`z}{"7\hexnumber@\symitalics61}% 

\DeclareRobustCommand\em
        {\@nomath\em \ifdim \fontdimen\@ne\font >\z@
                       \upshape \else \slshape \fi}

% Now to give sensible names for Squiggol and category theory symbols

\def\implies{\Rightarrow}
\def\iff{\Leftrightarrow}
\def\concat{\mathbin{\plus\!\!\!\plus}}
\def\suchthat{\mathrel{|}}
\def\compose{\mathbin{\cdot}}
\def\set#1{\mathord{\{#1\}}}
\def\seq#1{\mathord{[#1]}}
\def\emptyseq{\seq{\,}}
\def\emptyrel{\emptyset}
\def\nilset{\set{\,}}

\newcommand{\split}[2]{\langle #1,#2\rangle}
\newcommand{\converse}[1]{#1^{\circ}}
\newcommand{\lbana}{\mbox{$(\![$}}
\newcommand{\rbana}{\mbox{$]\!)$}}
\newcommand{\lbcat}{\mbox{$[\!($}}
\newcommand{\rbcat}{\mbox{$)\!]$}}
\newcommand{\lccat}{\mbox{$[\!\langle$}}
\newcommand{\rccat}{\mbox{$\rangle\!]$}}
\newcommand{\cata}[1]{\mbox{$\lbana #1 \rbana$}}
\newcommand{\ana}[1]{\mbox{$\lbcat #1 \rbcat$}}
\newcommand{\cockett}[1]{\mbox{$\lccat #1 \rccat$}}
\newcommand{\spe}{\mbox{$\ni$}}
\newcommand{\eps}{\mbox{$\in$}}
\newcommand{\snoc}{\mathbin{+\!\!\!+\!\!\!<}}
\newcommand{\bnoc}{\mathbin{+\!\!\!<}}
\newcommand{\func}[1]{{\sf #1}}
\newcommand{\Pow}{{\sf P}}
\newcommand{\Ext}{{\sf E}}
\newcommand{\toprel}{\Pi}
\newcommand{\botrel}{0}
\newcommand{\id}{id}
\newcommand{\union}{\;\cup\;}
\newcommand{\bigunion}{\mbox{$\bigcup$}}
\newcommand{\bigmeet}{\mbox{$\bigcap$}}
\newcommand{\from}{\mathbin{\leftarrow}}
\newcommand{\terminator}{{1}}
\newcommand{\ffrom}{\Leftarrow}
\newcommand{\wfrom}{\hookleftarrow}
\newcommand{\wto}{\hookrightarrow}
\newcommand{\acc}[1]{\mbox{$\lfloor #1 \rfloor$}}
\newcommand{\bang}{\mbox{$!$}}
\newcommand{\bong}{\mbox{!`}}
\newcommand{\graph}{\mbox{\sf J}}
\newcommand{\sse}{\subseteq}
\newcommand{\spse}{\supseteq}
\newcommand{\wok}[1]{\mbox{${#1}^{\circ}$}}
\newcommand{\rtc}[1]{\mbox{${#1}^{\star}$}}
\newcommand{\conj}{\;\wedge\;}
\newcommand{\bs}{\mbox{$\backslash$}}
\newcommand{\dom}[1]{\mbox{${#1}\Box$}}
\newcommand{\ran}[1]{\mbox{$\Box{#1}$}}
\newcommand{\tgt}{\triangleleft}
\newcommand{\src}{\triangleright}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
\newcommand{\bscor}{\mathbin{\backslash\!\!\!\!-}}

% general utilities 

\def\emark{$\Box$}
\def\pause{\vspace{2ex}}
\def\text#1{\mbox{\rm #1}} 
\newcommand{\idisp}[1]{\makebox[0 in][l]{$#1$}}

% Make ~ do a thin space in maths mode. We need to insert a space between a
% function and its argument, because spaces aren't significant in maths mode.
% Thus, you say "f~x".

\let\twiddle=~
\def\applicationspace{\makebox[.15ex]{}}
\def~{\ifmmode \applicationspace \else \twiddle \fi}


% Make . active in maths mode, as a "compose". Save old . as \period
% Thus, you can say "map~tails . inits", and "3\period 14"

\mathchardef\period=\mathcode`. % ordinary symbol
{\catcode`.=\active \gdef.{\compose}}
\mathcode`.="8000

% Now define the abbreviations we will use. We have
%           =>     is an abbreviation for     \implies
%           <=              "                 \le
%           >=              "                 \ge
%           ++              "                 \concat
%           <=>             "                 \iff
%           ->              "                 \rightarrow

\mathchardef\equals=\mathcode`=
\mathcode`=="8000

{\catcode`==\active \gdef={\futurelet\@next\@newequals}}
\def\@newequals{\ifx>\@next \def\@next##1{\implies} 
                      \else \def\@next{\equals} 
                \fi 
                \@next}

\def\Relbar{\mathrel{=}} % \Relbar (in plain TeX) screwed up by making = active



\mathchardef\lessthan=\mathcode`<
\mathcode`<="8000

{\catcode`<=\active \gdef<{\futurelet\@next\@newlessthan}}
\def\@newlessthan{\ifx=\@next \def\@next##1{\futurelet\@next\@newle} 
                  \else \ifx<\@next \def\@next##1{\ll}
                              \else \def\@next{\lessthan} 
                        \fi
                  \fi 
                  \@next}

\def\@newle{\ifx>\@next \def\@next##1{\iff}
                  \else \def\@next{\le}
            \fi
            \@next}




\mathchardef\greaterthan=\mathcode`>
\mathcode`>="8000

{\catcode`>=\active \gdef>{\futurelet\@next\@newgreaterthan}}
\def\@newgreaterthan{\ifx=\@next \def\@next##1{\ge} 
                     \else \ifx>\@next \def\@next##1{\gg}
                                 \else \def\@next{\greaterthan} 
                           \fi
                     \fi 
                     \@next}


\mathchardef\plus=\mathcode`+
\mathcode`+="8000

{\catcode`+=\active \gdef+{\futurelet\@next\@newplus}}
\def\@newplus{\ifx+\@next \def\@next##1{\concat} 
                    \else \def\@next{\plus} 
              \fi 
              \@next}



\mathchardef\minus=\mathcode`-
\mathcode`-="8000

{\catcode`-=\active \gdef-{\futurelet\@next\@newminus}}
\def\@newminus{\ifx>\@next \def\@next##1{\rightarrow} 
                     \else \def\@next{\minus} 
                \fi 
                \@next}

% The derivation environment

\newenvironment{derivation}{\begin{eqnarray*}
                          }{\end{eqnarray*}
                            \global\@ignoretrue}
\def\given#1{&&\begin{array}[t]{@{}l@{}}%
                #1
               \end{array} \\ \nopagebreak}
\def\step{\@ifnextchar({\@step}{\@step(=)}}
\def\@step(#1)[#2]#3{&#1& \begin{oldtabular}[t]{@{}l@{}}%
                          \quad  \{#2\}
                          \end{oldtabular} \\
                     &  & \begin{array}[t]{@{}l@{}}%
                           #3  
                          \end{array} \\ }
\def\step{\@ifnextchar({\@step}{\@step(=)}}
\def\result{\@ifnextchar({\@result}{\@result(=)}}
\def\@result(#1)[#2]#3{&#1& \begin{oldtabular}[t]{@{}l@{}}%
                            \quad\{#2\}
                           \end{oldtabular} \\
                       &  & \begin{array}[t]{@{}l@{}}%
                             #3  
                            \end{array}  }

% Set up Theorems, Lemmas and Corollaries and Propositions:


\newtheorem{theorem}{Theorem}
\newtheorem{fact}{Fact}
\newtheorem{lemma}[fact]{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}

%\newcounter{facts}
%\newenvironment{fact}{\begin{quote}\normalsize\sl
%                      \noindent{\bf Fact \refstepcounter{facts}\thefacts}}
%					 {\end{quote}}
%\newenvironment{lemma}{\begin{quote}\normalsize \sl
%                     \noindent{\bf Lemma \refstepcounter{facts}\thefacts}}
%					 {\end{quote}}
\newenvironment{refact}[1]{\begin{quote}\normalsize 
                     \noindent{\it Restatement of Fact #1.}}{\end{quote}}


\newenvironment{program}{\[\begin{array}{rcll}
                        }{\end{array}\]}


% common hyphenation exceptions:

\hyphenation{de-ter-mi-nism de-ter-mi-nistic non-de-ter-mi-nism}
\hyphenation{analy-sis}
\hyphenation{defi-ni-tion}
\hyphenation{lit-era-ture}
\hyphenation{cat-egory cat-egories cat-egorical}
\hyphenation{tabu-lation}
\hyphenation{equiv-al-ent equiv-al-ence}
\hyphenation{necess-ary}
\hyphenation{monic monics}
\hyphenation{op-er-ation}
\hyphenation{typi-cal}
\hyphenation{sum-mar-izing sum-mary}


\newdimen\mathindent
\AtEndOfClass{\mathindent\leftmargini}
\renewcommand{\[}{\relax
                 \ifmmode\@badmath
                 \else
                   \begin{trivlist}%
                     \@beginparpenalty\predisplaypenalty
                     \@endparpenalty\postdisplaypenalty
                     \item[]\leavevmode
                     \hbox to\linewidth\bgroup $\m@th\displaystyle %$
                       \hskip\mathindent\bgroup
                 \fi}
\renewcommand{\]}{\relax
                 \ifmmode
                       \egroup $\hfil% $
                     \egroup
                   \end{trivlist}%
                 \else \@badmath
                 \fi}
\renewenvironment{equation}%
    {\@beginparpenalty\predisplaypenalty
     \@endparpenalty\postdisplaypenalty
     \refstepcounter{equation}%
     \trivlist \item[]\leavevmode
       \hbox to\linewidth\bgroup $\m@th% $
         \displaystyle
         \hskip\mathindent}%
        {$\hfil % $
         \displaywidth\linewidth\hbox{\@eqnnum}%
       \egroup
     \endtrivlist}
\renewenvironment{eqnarray}{%
    \stepcounter{equation}%
    \def\@currentlabel{\p@equation\theequation}%
    \global\@eqnswtrue\m@th
    \global\@eqcnt\z@
    \tabskip\mathindent
    \let\\=\@eqncr
    \setlength{\abovedisplayskip}{\topsep}%
    \ifvmode
      \addtolength{\abovedisplayskip}{\partopsep}%
    \fi
    %    \addtolength{\abovedisplayskip}{\parskip}%
    \setlength{\belowdisplayskip}{\abovedisplayskip}%
    \setlength{\belowdisplayshortskip}{\abovedisplayskip}%
    \setlength{\abovedisplayshortskip}{\abovedisplayskip}%
    $$\everycr{}\halign to\linewidth% $$
    \bgroup
      \hskip\@centering
      $\displaystyle\tabskip\z@skip{##}$\@eqnsel&%
      \global\@eqcnt\@ne \hskip \tw@\arraycolsep \hfil${##}$\hfil&%
      \global\@eqcnt\tw@ \hskip \tw@\arraycolsep
        $\displaystyle{##}$\hfil \tabskip\@centering&%
      \global\@eqcnt\thr@@
        \hbox to \z@\bgroup\hss##\egroup\tabskip\z@skip\cr}%
      {\@@eqncr
    \egroup
    \global\advance\c@equation\m@ne$$% $$
    \global\@ignoretrue
    }
\end{filecontents*}


\begin{document}

\typeout{------------------------------------------}
\typeout{^^JYou can now safely delete tlpcls.*^^J}
\typeout{------------------------------------------}

\end{document}
 
%% 
%% End of file tlpcls.ltx 
%% 

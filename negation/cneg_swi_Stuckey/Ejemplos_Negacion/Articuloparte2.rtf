{\rtf1\ansi\ansicpg1252\deff0\deflang1034{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset0 Times New Roman;}{\f2\fmodern\fprq1\fcharset0 Courier New;}{\f3\fswiss\fprq2\fcharset0 Arial Narrow;}}
\viewkind4\uc1\pard\f0\fs12\par
\pard\sl-120\slmult0\f1\par
\pard\sl-201\slmult0\ul\f0\fs16 -\par
\pard\fi3024\sb1660\sl-220\slmult0\ulnone\f1\fs18 .! r (b). loops infinitely\par
\pard\fi3024\sb139\sl-220\slmult0 .! r (X) .One answer: X = _A, _A ~ b, _A ~. c; and then, it loops infinitely\par
\pard\fi3024\sb144\sl-240\slmult0\f2\fs20 .!p(X,Y). Four answers (the last two infinitely repeated);\par
\pard\fi3744\sb172\sl-220\slmult0\f1\fs18 .X=_A, Y=_B, _B~g(*C), _A~f(*D);\par
\pard\fi3744\sb105\sl-220\slmult0 .X = f (_A), Y = _B, _B ~ g (* C), _A ~ a;\par
\pard\fi3744\sb192\sl-220\slmult0 .X=_A, Y=g(c), _A~f(*B);\par
\pard\fi3744\sb86\sl-240\slmult0\f2\fs20 .X = f(_A), y = g(c), _A ~ a;\par
\pard\fi3096\sb158\sl-220\slmult0\f1\fs18 .! q (Z). One answer: Z = _A, _A ~ a;\par
\pard\fi3096\sb139\sl-220\slmult0 .Ip(g(Z),f(Z)),q(Z). Oneanswer: Z = a;\par
.p(X, g(Y)), q(Y). Twoanswers:\par
\pard\fi3744\sb120\sl-240\slmult0\f2\fs20 .X = f(a), Y = a;\par
\pard\fi3744\sb91\sl-240\slmult0 .y = a;\par
\pard\sb153\sl-220\slmult0\qc\f1\fs18 .! P (X, Y) , r (Y) .Two answers (infinitely repeated):_.\par
\pard\sb177\sl-220\slmult0\qc .X=_A,Y=c,_A~f(*B);\par
\pard\fi3744\sb100\sl-240\slmult0\f2\fs20 .X = f(_A), y = c, _A ~ a;\par
\pard\fi1512\sb321\sl-220\slmult0\f1\fs18 9. The following is a definite program to compute symmetric (non-symmetric) terms (trees) ofthe signature\par
\pard\fi1872\sb14\sl-220\slmult0\{ \i ala, f/2, \i0 gil) is:\par
\pard\fi-72\li1872\sb172\sl-249\slmult0\f2\fs20 symmetric(a). % File synunetric.pnt in programs.zip symmetric(g(X));- symmetric(X).\par
\pard\fi1872\sl-225\slmult0\f1\fs18 symmetric(f(X,Y)) :-mirror(X,Y)."\par
\pard\fi1800\sb19\sl-225\slmult0\f2\fs20 mirror(a,a) .\par
\pard\fi1800\sl-196\slmult0 mirror(g(X),g(Y)) :-mirror(X,Y).\par
\pard\fi1872\sb28\sl-196\slmult0\f1\fs18 mirror(f(X,Y) ,f(Z,W)):- mirror(X,W) ,mirror(Y,Z).\par
\pard\fi1800\sb230\sl-196\slmult0 The BCN-answers for the question I symmetric (Z) are:\par
\pard\fi3096\sb182\sl-196\slmult0 .Z = f (a, A), A ~ a;\par
\pard\fi4320\sl-153\slmult0\f0\fs12 --\'a1\par
\pard\li3096\sl-360\slmult0\f1\fs18 .Z = f(f(_A,_B),_C), _C ~ f(*E,*D); \'a1 .Z = f(g(_A),_B), _B ~ g(*C); 1. .Z = g(f(a,_A)), -~ ~ a;\par
\pard\fi3096\sb4\sl-360\slmult0 .Z = g(f(f(_A,_B),_C)), _C ~ f(*E,*D);\par
\pard\fi3096\sb9\sl-360\slmult0 .Z=g(f(g(_A),_B)),_B~g(*C);\par
\pard\fi3096\sb14\sl-360\slmult0 .Z = f(g(a),g(_A)), _A ~ a;\par
\pard\fi3096\sb9\sl-360\slmult0 .Z = f(g(f(_A,_B)) ,g(_C)), _C ~ f(*E,*D);\par
.Z = f(g(g(_A) ),g(_B)), _B ~ g(*C);\par
\pard\fi3600\sl-360\slmult0 and so on\par
\pard\fi2016\sl-326\slmult0 The question ! symmetric (f (X, X) ) also produces an infinite number of answers, whereas the question\par
\pard\fi2016\sl-240\slmult0 ! symmetric (f (X, X) ) , mirror (X, X) produces (as expected) an infinite computation (without\par
\pard\fi2016\sb43\sl-240\slmult0\fs20 answers).\par
\pard\sb2198\sl-240\slmult0\f3\fs8 -~\par
\pard\f0\fs12\par
\pard\sl-120\slmult0\f1\par
\pard\fi72\sl-220\slmult0\fs18 100 The following example is a variant of a program introduced in\par
\pard\fi1296\sb28\sl-220\slmult0 DoChan, Constructive Negation Based On The Completed Database, in Ro Ao Kowalski and Ko Ao\par
\pard\fi1224\sb9\sl-220\slmult0 Bowen, editors, \i Proceedings ofthe Fifth lnternational Conference and Symposium on Logic\par
\pard\fi1224\sl-220\slmult0 Programming, \i0 pages 111-125, Seatle, 1988. The MIT presso\par
\pard\li360\sb230\sl-206\slmult0 has_duplicates([ X!Y] );- member(X,Y). % File programs.zip has_duplicates ([ _1 Y] ) : -has_duplicates (Y) .\par
\pard\fi288\sb38\sl-206\slmult0 member(X,[XI~).\par
\pard\fi360\sl-201\slmult0 member (X,[ _1 Y] ) : -member1X, Y) .\par
list_of_digi ts ([ ] ) .\par
\pard\fi360\sb28\sl-201\slmult0 list_of_digi ts ([ XI Y] ) : -digit (X), list_of_digits (Y) .\par
\pard\fi360\sl-192\slmult0 digit(l).\par
\pard\fi360\sb28\sl-192\slmult0 digit(2)..\par
\pard\fi288\sb38\sl-192\slmult0\f2\fs20 digit(3) .\par
\pard\fi288\sb33\sl-192\slmult0\fs22 digit(4) .\par
\pard\fi288\sb14\sl-192\slmult0\fs20 digit(5) .\par
\pard\fi288\sb326\sl-192\slmult0\f1\fs18 The goal! has_duplicates ([ Xl, X2, X3] ), list_of_digi ts ([ Xl, X2, X3] ) .asks \i for \i0 all the\par
\pard\fi360\sl-192\slmult0 list ofthree digits without repetitions and the prototype gives fue 60 possible combinations and then fails:\par
\pard\li1512\ri6048\sl-360\slmult0\qj\f2\fs20 .Xl = 5, X2 = 2, X3 = 1; .Xl = 4, X2 = 2, X3 = 1; .Xl = 3, X2 = 2, X3 = 1; .Xl = 5, X2 = 3, X3 = 1;\par
\pard\fi1584\sl-345\slmult0\f1\fs18 .o o. and so on\par
\pard\sl-336\slmult0 11. The following is a program that computes pairs of disjoint lists ofnumbers:\par
\pard\li288\sb264\sl-192\slmult0 list ([ ] ) .% File disjoint. pnt in programs. zip list([EIL):-element(E), list(L). ..\par
\pard\fi288\sb57\sl-192\slmult0\f2\fs22 element(O).\par
\pard\fi288\sb9\sl-192\slmult0\f1\fs18 element (s (E) ) : -element (E) .\par
\pard\fi288\sb24\sl-192\slmult0 member (X,[ X.I_] ) .\par
\pard\fi288\sb33\sl-192\slmult0 member (X,[ -' L] ) : -member (X, L) .\par
\pard\fi288\sb28\sl-192\slmult0 disjoint ([] ,-),\par
\pard\fi288\sb4\sl-192\slmult0 disjoint([ EfLl] ,L2);- ! member(E,L2), disjoint(Ll,L2).\par
\pard\fi216\sb302\sl-192\slmult0 Thegoal! disjoint(Ll,L2), list(Ll), list(L2). asksforthepairsofdisjointlistsofnumbers:\par
\pard\fi1512\sb38\sl-192\slmult0 .Ll = [ O), L2 = [ \i O] \i0 ;\par
\pard\fi1512\sb177\sl-192\slmult0 .Ll = [ s (O)], L2 = [ s (O)] ;\par
\pard\fi1512\sb168\sl-192\slmult0 .Ll = [ O, O], L2 = [ O] ;\par
.Ll = [ O, O], L2 = [ O, O) ;\par
\pard\fi1512\sb144\sl-192\slmult0 .o.. and so on\par
\pard\fi10512\sb3984\sl-192\slmult0\f3\fs12 ,\\\par
\pard\f0\par
\pard\sl-120\slmult0\f1\par
\pard\sl-201\slmult0\ul\f0\fs16 -\par
\pard\fi216\sb1036\sl-201\slmult0\ulnone\f3 j\par
\pard\fi1584\sb384\sl-220\slmult0\f1\fs18 12. The following is the classical insertion sort program:\par
\pard\fi-72\li1944\sb168\sl-244\slmult0\f2\fs20 greater(s(_),O). % Filelist_sort.pnt in programs.zip greater(s(El),s(E2)):- greater(E1,E2).\par
\pard\fi1944\sl-244\slmult0\f1\fs18 insert_sort (E,[ ] ,[ E] ) .\par
\pard\fi1944\sl-168\slmult0 insert_sort(E1,[ E2IL] ,lE11[ E2IL]]):- ! greater(E1,E2).\par
\pard\fi-72\li1944\sb19\sl-196\slmult0\f2\fs20 insert_sort(E1,[ E2IL],[ E2INL]):- greater(E1,E2), insert sort(E1,L,NL). \f1 list_sort(L,NL):- sort(L,[],NL). -\par
\pard\fi1944\sb100\sl-196\slmult0\fs18 sort (( ] , L, L) .\par
\pard\fi1944\sb19\sl-196\slmult0 sort(( EIL1] ,L2,NL):- insert_sort(E,L2,LAux), sort(L1,LAux,NL).\par
\pard\fi1944\sb24\sl-196\slmult0 list (( ] ) .\par
list(( EIL] ):-element(E), list(L).\par
\pard\fi1944\sb33\sl-196\slmult0\fs22 element (O) .\par
\pard\fi1944\sl-196\slmult0\fs18 element (s (E) ) : -element (E) .\par
\pard\fi1944\sb206\sl-196\slmult0 Notice that the variable LAux in the predicate sort/ 3 doesn't arrear in the head, hence it produces. universal\par
\pard\fi1944\sb72\sl-196\slmult0 quantification\par
\pard\fi1944\sb244\sl-196\slmult0 Thegoal! list_sort(L1,12), list(11), list(12). givesallthepairsofnumberlistssuchthat\par
\pard\fi1944\sb38\sl-196\slmult0 the second list is not the ordering ofthe first one:\par
\pard\fi3168\sb72\sl-196\slmult0 .11=[],12=[0];\par
\pard\fi3168\sb153\sl-196\slmult0 .L1 = ( s (O)], L2 = [ ] ;\par
\pard\fi3168\sb158\sl-196\slmult0 .11 = [ s (O)\}, L2 = [ O\} ;\par
\pard\fi3168\sb168\sl-196\slmult0 .11 = [ ], L2 = ( S (O)\} ;\par
\pard\fi3744\sb148\sl-196\slmult0 and so on\par
\pard\fi1584\sb360\sl-196\slmult0 13. This program returns the maximum ora list ofnumbers:\par
\pard\fi1944\sb211\sl-196\slmult0\f2\fs20 greater(O,E,E). % File max_list.pnt in programs.zip\par
\pard\fi1944\sb62\sl-196\slmult0 greater(E,O,E) .\par
\pard\fi1944\sb4\sl-196\slmult0 greater(s(E1),s(E2),s(E3)):- greater(E1,E2,E3).\par
\pard\fi1944\sb57\sl-196\slmult0\f1\fs18 max_list([] ,0).\par
\pard\fi1944\sl-168\slmult0 max_list ([ EI;L\} , NE) : -max_list (L, EAux), greater (E, EAux, NE) .\par
\pard\fi1944\sb81\sl-168\slmult0 list (( \} ) .\par
\pard\fi1944\sb52\sl-168\slmult0 list([EIL]):-element(E), list(L).\par
\pard\fi1944\sb67\sl-168\slmult0\fs22 element(O) .\par
\pard\fi1944\sb28\sl-168\slmult0\fs18 element (s (E) ) : -element (E) .\par
\pard\fi1944\sb268\sl-168\slmult0 Notice also in this program that the variable EAux in the predicate max list/2 produces universal\par
\pard\fi1944\sb4\sl-168\slmult0 quantification. -\par
\pard\fi1944\sb302\sl-168\slmult0 The goal! max_list (1, E), list (1), element (E) .gives all the pairs (Iist ofnumbers, number)\par
\pard\fi1944\sb110\sl-168\slmult0 such that the number is not the maximum ofthe list:\par
\pard\fi3168\sb81\sl-168\slmult0\f2\fs20 .1 = [], E = s(O);\par
\pard\fi3168\sb192\sl-168\slmult0\f1\fs18 .1 = [ O], E = s (O);\par
\pard\fi3168\sb206\sl-168\slmult0\f2\fs20 .1 = [], E = s(s(O\'bb);\par
\pard\fi3168\sb182\sl-168\slmult0\f1\fs18 .L = ( O], E = s (s (O));\par
\pard\fi3744\sb182\sl-168\slmult0 and so on\par
\pard\fi11160\sb3067\sl-168\slmult0\ul\f3 ,-~ "..\par
}
 